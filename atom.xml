<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>美丽新世界</title>
  <icon>https://www.gravatar.com/avatar/7e3d2d69172a3a1a291da558f2ac4b01</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yazhidev.github.io/"/>
  <updated>2022-06-07T22:58:54.435Z</updated>
  <id>https://yazhidev.github.io/</id>
  
  <author>
    <name>扬州慢</name>
    <email>yazhidev@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android OpenGL ES 开发</title>
    <link href="https://yazhidev.github.io/2020/08/11/Android-OpenGL-ES-%E5%BC%80%E5%8F%91/"/>
    <id>https://yazhidev.github.io/2020/08/11/Android-OpenGL-ES-开发/</id>
    <published>2020-08-10T23:15:30.000Z</published>
    <updated>2022-06-07T22:58:54.435Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL(Open Graphics Library) 是开放图形库，是一个跨平台的图形 API。OpenGL ES(OpenGL for Embedded System)是专为移动端提供的一个子集。目前主要版本有1.0/1.1/2.0/3.0/3.1：</p><ul><li>1.0：Ａndroid 1.0和更高的版本支持这个API规范</li><li>2.0：不兼容 OpenGL ES 1.x。Android 2.2(API 8)和更高的版本支持这个API规范</li><li>3.0：向下兼容 OpenGL ES 2.x。Android 4.3(API 18)及更高的版本支持这个API规范</li><li>3.1：向下兼容 OpenGL ES3.0/2.0。Android 5.0（API 21）和更高的版本支持这个API规范</li></ul><p>先了解一下 OpenGl 几个相关的概念</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="管线"><a href="#管线" class="headerlink" title="管线"></a>管线</h3><p>也称渲染管线，因为 OpenGL ES 在渲染处理过程中会顺序执行一系列操作，这一系列相关的处理阶段就被称为 OpenGL ES 渲染管线。OpenGL ES 渲染过程就如流水线作业一样，这样的实现极大地提高了渲染的效率。如图就是 OpenGL ES 的管线图，学习OpenGL ES 就是学习这张图中的每一个部分。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200911_071858_20200906111207301_120328481.png" alt="OpenGL渲染管线"></p><p>图中阴影部分的 Vertex Shader(顶点着色器) 和 Fragment Shader(片元着色器) 是可编程管线 。</p><h3 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h3><p>OpenGl 物体图形都由点、线、多边形组成，组成他们的关键就在于顶点数据。绘制时需要准备绘制的位置，这些位置就是顶点，顶点组合起来就是顶点坐标。</p><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p>OpenGl 使用右手坐标系，手机屏幕中心坐标系（0，0，0），左上角坐标（-1, 1, 0），依此类推。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200911_071858_20200906111014612_1350569553.png" alt="右手坐标系"></p><h3 id="着色器语言"><a href="#着色器语言" class="headerlink" title="着色器语言"></a>着色器语言</h3><p>着色器的编程语言是基于 C 语言开发的，被称为 GLSL（OpenGL Shading Language），和 C 语言最大的区别是它新增了许多适合图形处理的东西，比如定义了向量和矩阵两个数据类型，另外 GLSL 也对高并发进行了特殊优化。</p><p>GLSL 详细语法可见：<a href="https://github.com/wshxbqq/GLSL-Card" target="_blank" rel="noopener">GLSL 中文手册</a></p><h3 id="顶点着色器（Vertex-Shader）"><a href="#顶点着色器（Vertex-Shader）" class="headerlink" title="顶点着色器（Vertex Shader）"></a>顶点着色器（Vertex Shader）</h3><p>顶点着色器分为输入和输出两部分，负责的功能是把输入的数据进行矩阵变换位置，计算光照公式生成逐顶点颜⾊，⽣成/变换纹理坐标。并且把位置和纹理坐标这样的参数发送到片段着色器。</p><p>顶点着色器的输入数据由下面组成：</p><ul><li>Attributes：使用顶点数组封装每个顶点的数据，一般用于每个顶点都各不相同的变量，如顶点位置、颜色等。</li><li>Uniforms：顶点着色器使用的常量数据，不能被着色器修改，一般用于对同一组顶点组成的单个3D物体中所有顶点都相同的变量，如当前光源的位置。</li><li>Samplers：这个是可选的，一种特殊的 uniforms，表示顶点着色器使用的纹理。</li><li>Shader program：顶点着色器的源码或可执行文件，描述了将对顶点执行的操作。</li></ul><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200911_071858_20200902074045970_1307915562.png" alt="顶点着色器"></p><p>顶点着色器对于 3D 模型网格的每个顶点执行一次，确定顶点的最终位置。顶点着色器取得一个位置及相关的颜色数据作为输入属性，用一个 4x4 矩阵变换位置，并输出变换后的位置和颜色。</p><p>顶点着色器是可编程渲染管道，例如一个简单的顶点着色器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 aPosition;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_Position = aPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子里的 gl_Position 是顶点着色器的内建输出变量。</p><p>gl_Position： 顶点坐标<br>gl_PositionSize：点的大小，默认值是 1</p><h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p>图元指的是点、直线和三角形。该过程还有两个重要操作：裁剪和淘汰。对不在屏幕可见的 3D 区域内的图元进行裁剪，根据图元面向前方或后方选择抛弃它们（比如物体内部的点）。</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>将图元转为片段的过程称为光栅化。片段可以理解为带有深度信息的像素点。屏幕上的一个像素点可能对应多个片段。</p><h3 id="片段着色器（Fragment-Shader）"><a href="#片段着色器（Fragment-Shader）" class="headerlink" title="片段着色器（Fragment Shader）"></a>片段着色器（Fragment Shader）</h3><p>片段着色器用于对片段进行处理，例如纹理采样、颜色汇总等，将每个片段的颜色等属性计算出来并向后传输。编写片元着色器可以实现滤镜、美颜、图片处理、类似抖音的一些特效等效果。片段着色器对光栅化之后 2D 图像中的每个像素处理一次，3D 物体的表面最终显示成什么样子由片段着色器决定。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200911_071858_20200907071634306_518331695.png" alt="片段着色器"></p><p>片段着色器也是可编程的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gl_FragColor 是片段着色器的内建输出变量，指当前片元的颜色。</p><h3 id="GLSurfaceView"><a href="#GLSurfaceView" class="headerlink" title="GLSurfaceView"></a>GLSurfaceView</h3><p>我们都知道 SurfaveView 最大的特点是可以在子线程中绘制图象，GLSurfaceView 继承自 SurfaceView，其实是对 SurfaceView 再做了一次封装，方便在 Android 中使用 OpenGL。</p><p>GLSurfaceView 的渲染被委托给渲染器在独立的渲染线程里进行，通过 <code>setRender(Render)</code> 设置渲染器。</p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>了解相关概念后，先动手编写个简单的 Demo 实操一下。Android 上使用 OpenGl ES 流程如下：</p><ol><li>在 AndroidMenifest 中设置 OpenGL 版本：</li></ol><p>如果应用不指定 android:glEsVersion 属性，则系统默认使用 OpenGL ES 1.0，即所有 Android 设备都支持的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义渲染器</li></ol><p>新建类实现 <code>GLSurfaceView.Renderer</code> 接口，并在三个回调方法中做相应操作。</p><ul><li>在 Surface 创建时，设置设置清除后的颜色预设值</li><li>在 Surface 变化时，更新视口矩形宽高、窗口位置</li><li>在每次绘制帧时，清空颜色缓冲并置为预设颜色</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CustomRender: GLSurfaceView.Renderer &#123;</span><br><span class="line">    override fun onDrawFrame(gl: GL10?) &#123;</span><br><span class="line">        //绘制当前帧</span><br><span class="line">        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) &#123;</span><br><span class="line">        //surface 变化时的回调，包括尺寸变化、设备屏幕方向变化等</span><br><span class="line">        GLES20.glViewport(0, 0, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) &#123;</span><br><span class="line">        //surface 创建时的回调</span><br><span class="line">        GLES20.glClearColor(0.0f, 0.0f, 1.0f, 1.0f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义 GLSurfaceView</li></ol><p>新建类继承自 GLSurfaceView，并在初始化时设置渲染器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class CustomGLSurfaceView(context: Context?) : GLSurfaceView(context) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        setRenderer(CustomRender())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>展示 GLSurfaceView</li></ol><p>将 GLSurfaceView 添加到布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class KotlinActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private val glSurfaceView by lazy &#123; CustomGLSurfaceView(this) &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(glSurfaceView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，页面会显示蓝色背景，这是 GLSurfaceView 最简单的运用，简单到我都不好意思放效果图。但千里之行始于足下，下一次我们接着深入 GLSurfaceView 的使用，动手编写着色器来实现图形绘制。</p><p>Comming soon  :P</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OpenGL(Open Graphics Library) 是开放图形库，是一个跨平台的图形 API。OpenGL ES(OpenGL for Embedded System)是专为移动端提供的一个子集。目前主要版本有1.0/1.1/2.0/3.0/3.1：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
    
      <category term="OpenGL" scheme="https://yazhidev.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Java 类型转换精度问题</title>
    <link href="https://yazhidev.github.io/2020/08/01/Java-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>https://yazhidev.github.io/2020/08/01/Java-类型转换精度问题/</id>
    <published>2020-08-01T12:41:06.000Z</published>
    <updated>2022-06-07T22:58:54.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型占用内存大小"><a href="#基本数据类型占用内存大小" class="headerlink" title="基本数据类型占用内存大小"></a>基本数据类型占用内存大小</h2><p>最近项目中修复了一个关于类型转换精度丢失的问题，以前对于类型转换会丢失精度只知其然，不知其所以然，这次了解了下相关原理，也分享给大家。先来回顾一下 Java 的基本数据类型中整型与浮点型及其所占用的内存大小：</p><p><strong>整型：</strong></p><ul><li>int：4 字节 32 位</li><li>long：8 字节 64 位</li></ul><p><strong>浮点型：</strong></p><ul><li>float：4 字节 32 位</li><li>double：8 字节 64 位</li></ul><p>Java 运算时，当两个不同类型的数进行基本运算符操作时，低精度会自动向高精度转换，字节短的会自动向字节长的转换。</p><p>《Java 核心技术》一书中这么归纳到：</p><blockquote><p>如果两个操作数其中有一个是 double 类型，另一个操作就会转换为 double 类型。<br>否则，如果其中一个操作数是 float 类型，另一个将会转换为 float 类型。<br>否则，如果其中一个操作数是 long 类型，另一个会转换为 long 类型。<br>否则，两个操作数都转换为 int 类型。</p></blockquote><p>需要注意 Java 自动转换类型可能会带来精度的丢失，附上一张不会丢失精度的合法类型转换说明图：</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200901_204139_20200824075634064_585870421.png" alt="合法转换"></p><p>图中实现箭头类型转换代表不会丢失精度，虚线箭头类型转换可能会丢失精度。</p><h2 id="基本数据类型表示范围"><a href="#基本数据类型表示范围" class="headerlink" title="基本数据类型表示范围"></a>基本数据类型表示范围</h2><p>精度和数据类型可表示的数值大小范围息息相关，计算机中所有数值归根到底都是使用二进制 0、1 来组成，因此一个数据类型所占用的内存大小越大，就意味着可用的二进制位数越多，当然可表示的范围就越大。回顾一下几个常见的参与运算的基本数据类型的取值范围：</p><p><strong>int</strong></p><p>二进制位数：32<br>最小值：Integer.MIN_VALUE= -2147483648 （-2 的 31 次方）<br>最大值：Integer.MAX_VALUE= 2147483647 （2 的 31 次方 -1）</p><p><strong>long</strong></p><p>二进制位数：64<br>最小值：Long.MIN_VALUE=-9223372036854775808 （-2 的 63 次方）<br>最大值：Long.MAX_VALUE=9223372036854775807 （2 的 63 次方 -1）</p><p><strong>float</strong></p><p>二进制位数：32<br>最小值：Float.MIN_VALUE=1.4E-45 （2 的 -149 次方）<br>最大值：Float.MAX_VALUE=3.4028235E38 （2 的 128 次方 -1）</p><p><strong>double</strong></p><p>二进制位数：64<br>最小值：Double.MIN_VALUE=4.9E-324 （2 的 -1074 次方）<br>最大值：Double.MAX_VALUE=1.7976931348623157E308 （2 的 1024 次方 -1）</p><p>当 long 类型的数大于 <code>Integer.MAX_VALUE</code> 时，long 强制转换 int，就会出现丢失精度。转换过程是将 long 类型数值的二进制数从低位到高位截取 32 位，再将 32 位二进制数转为 int。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l3 = 24696061952L; //10111000000000000000000000000000000</span><br><span class="line">int c3 = (int)l3; //-1073741824</span><br><span class="line">System.out.println(Integer.toBinaryString(c3)); //1000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>上面的例子中，long 类型截取 32 位后转为 int，最高位作为符号位，1 代表负数，强转后的 int 值为  <code>-1073741824</code>。<br>类似这种不合理的强制转换丢失的已经不仅仅是精度了。</p><p>不知道有没有人注意到，long 类型的二进制位数是 64，float 类型的二进制位数是 32，但是 float 类型可表示范围却远远大于 long 类型。更不用提一样是 32 位的 int 了，float 到底啥家庭啊？谜底就在内存结构中。</p><h2 id="浮点类型数值的内存结构"><a href="#浮点类型数值的内存结构" class="headerlink" title="浮点类型数值的内存结构"></a>浮点类型数值的内存结构</h2><p>与整形类型的内存结构不同，float 在内存中是这样的：</p><p><code>SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM</code></p><ul><li>S：最高位 S 代表符号位</li><li>E：后面 8 位 E 代表指数域，二进制中就是 2 的 n 次方，采用移位存储(127+指数)的二进制方式。</li><li>M：剩下的 23 位 M 代表小数域。规定小数点前的数必须为 1，因此只记录小数点后的数。（从左往右，低位补零）</li></ul><p>以 7.8125 为例，整数十进制转二进制，除 2 取余，逆序排列，求得 7 二进制为 <code>111</code>。小数十进制转二进制，乘 2 取整，顺序排列，求得 0.8125 二进制为：<code>0.1101</code>，组合起来是 <code>111.1101</code>。</p><p>根据规范，小数点前的数只保留 1，因此将 <code>111.1101</code> 小数点左移两位得 <code>1.111101 * 2^2</code>。</p><p>符号位 0，指数位为 2+127=129，即二进制 <code>10000001</code>，小数域为 <code>111101</code>。因此 float 数 7.8125 在内存中存储的格式为：<code>0 10000001 111101</code> 低位补零补齐到 32 位，得：<code>0100 0000 1111 1010 0000 0000 0000 0000</code>。</p><p>可以使用 Java 提供的 API 验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = Float.floatToIntBits(7.8125F); //得到 7.8125F 底层数据（十进制）</span><br><span class="line">Integer.toBinaryString(i); //得到指定 int 值的二进制数</span><br><span class="line">//输出 1000000111110100000000000000000</span><br><span class="line">//补上最高位符号位 0，结果与上面计算的一样。</span><br></pre></td></tr></table></figure><p>通过对浮点类型数值内存结构的了解，我们知道了 float 虽然可用于存储数值的位数没有 long 型多，但是 float 通过使用指数进行降维打击，可表示范围蹭蹭蹭往上涨。</p><p>double 的内存结构同理，只不过 double 二进制位数更多，总共 64 位分别分配给：符号位 1 位，指数位 11 位，小数位 52 位。</p><p>需要注意的是，虽然 float 因为有指数的概念，可表示范围变大了，但是其用于存储小数的位数却只有 23 位。这就意味着当一个整型类型数值的二进制位大于 24 位时，类型转换到 float 就会带来精度丢失了。</p><h2 id="整型转换浮点型的精度丢失问题"><a href="#整型转换浮点型的精度丢失问题" class="headerlink" title="整型转换浮点型的精度丢失问题"></a>整型转换浮点型的精度丢失问题</h2><p>看到上图中的int 转 float、long 转 float 都是虚线表示，代表运算时自动类型转换可能会出现精度丢失的问题。经过上面对浮点型数据内存结构的学习，我们应该不难理解，float 能表示的数的大小靠指数位，但是表示的数的精度需要靠小数位。而 float 的小数位只有 23 位，而 int 是 32 位。</p><p>举个例子：int 值 16777217，二进制数 <code>1 0000 0000 0000 0000 0000 0001</code>，除去最高位符号位后，需要 25 位表示。</p><p>顺带提一下，计算某个数值除了符号位外需要多少位二进制位可以表示，除了挨个去数二进制数外，还可以直接计算 log2 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 16777217;</span><br><span class="line">double num = Math.log(i) / Math.log(2.0);</span><br><span class="line">//num = 24.000000085991324，即需要 25 位二进制位表示</span><br></pre></td></tr></table></figure><p>int 转 float，转换过程是先将 int 的数值由十进制转为二进制，再通过对二进制数左移小数点直到个位为 1，变为：<code>1. 0000 0000 0000 0000 0000 0001 * 2 ^ 24</code>，转换后的数小数点后有 24 位，对 float 来说只能舍弃掉无法表示的位数，只保留 23 位小数位，指数位 24 + 127 = 151，二进制为 <code>10010111</code>，因此转换后的 float 二进制数为 <code>110010111 + 23个0</code>，float 值为 1.6777216E7，已经丢失了精度。</p><p>同理，int 转 double，由于 double 有 52 位小数位，因此足以 hold 住 int 的精度，而 long 需要 64 位表示精度，因此 long 转 double 也可能出现精度丢失。另外需要注意的是，单位秒的时间戳，也需要 31 位来表示，用 int 表示是够的，但是转 float 也一样会丢失精度。</p><p>以上就是对 Java 类型转换精度问题的分析，希望对你有帮助 :P</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本数据类型占用内存大小&quot;&gt;&lt;a href=&quot;#基本数据类型占用内存大小&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型占用内存大小&quot;&gt;&lt;/a&gt;基本数据类型占用内存大小&lt;/h2&gt;&lt;p&gt;最近项目中修复了一个关于类型转换精度丢失的问题，以前对于类型
      
    
    </summary>
    
    
      <category term="Java" scheme="https://yazhidev.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>认识 YUV</title>
    <link href="https://yazhidev.github.io/2020/06/20/%E8%AE%A4%E8%AF%86-YUV/"/>
    <id>https://yazhidev.github.io/2020/06/20/认识-YUV/</id>
    <published>2020-06-20T12:08:53.000Z</published>
    <updated>2022-06-07T22:58:54.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-YUV"><a href="#什么是-YUV" class="headerlink" title="什么是 YUV"></a>什么是 YUV</h2><p>YUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。与RGB类似，但RGB更多的用于渲染时，而YUV则用在数据传输，因为它占用更少的频宽。当然，实时通讯为了降低带宽都会采用H264/H265编码。YUV的含义：Y代表亮度信息（灰度），UV分别代表色彩信息。YUV的常用名称有许多，例如YUV422、YUV420、YUV444等。</p><h2 id="采样格式"><a href="#采样格式" class="headerlink" title="采样格式"></a>采样格式</h2><p>YUV 后面常带着三个数字，其含义代表 YUV 信息在像素点中的分布状况，也就是<strong>采样格式</strong>：</p><ol><li><p>YUV444 代表每个 Y 对应一组 UV，每个像素占3个字节。<br> 存放码流：Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3</p></li><li><p>YUV422 代表每 2 个 Y 对应一组 UV<br> 存放码流：Y0 U0 Y1 V1 Y2 U2 Y3 V3</p></li><li><p>YUV411 代表每 4 个 Y 对应一组 UI<br> 存放码流：Y0 U0 Y1 Y2 V2 Y3</p></li><li><p>YUV420 代表每个像素独有一个 Y，每四个像素共享一个 U，每四个像素共享一个 V</p></li></ol><p>以 YUV420 为例，Y 数据有效字节数为=Height×Width；U数据有效字节数=(Height/2)×(Width/2)；V数据有效字节数=(Height/2)×(Width/2)；</p><p>YUV420 是一类格式的集合，包含 I420、NV21 等不同格式，格式不同，YUV 的排列顺序也不同（Y 的顺序是一样的，UV 不一样）。官方将 YUV 三个平面都称为颜色平面（color plane）。Android 中使用 <code>ImageProxy</code> 的 <code>getPlanes()</code> 方法可得三个平面。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200623_100350_20200622214237817_1530731484.png" alt="i420"></p><p>NV21 是，planes[1] 是 UVU，planes[2] 是 VUV。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200623_100351_20200622214254540_149960528.png" alt="nv21"></p><p>NV21 存储的 UV 数据是有冗余的，取 planes[1] 每一排的奇数字节可得所有 U 数据，取 planes[2] 每一排的偶数字节可得所有 V 数据。</p><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>上面提到的 planes 是平面的，YUV 存储在三个独立的数组中。还有另外一种存储方式：packed（打包的），YUV 是连续交错存储的。</p><p>例如 YUY2 就属于 packed 类型，数据以第一个字节存放 Y0，第二个字节存放 U0，再 Y1、V0、Y1 等等，每四个字节，Y0 和 Y1 共用 U0、V0 分量，依次类推。</p><h2 id="YUV-图像显示"><a href="#YUV-图像显示" class="headerlink" title="YUV 图像显示"></a>YUV 图像显示</h2><p>显示 YUV 图像需要使用 OpenGl 库调用 GPU 资源。或者先将 YUV 图像转换为 RGB 图像。Android 提供了 <code>YuvImage</code> 将 YUV 数据转换成 jpeg 的方法，目前只支持 NV21 和 YUY2。这里编写一段测试代码眼见为实。</p><p><a href="https://github.com/yazhidev/AndroidDemo/blob/yuv/1dev/icon.jpg" target="_blank" rel="noopener">测试图片地址</a></p><p>先使用 ffmpeg 将 jpeg 图片转为 NV21 格式用于测试：</p><p><code>ffmpeg -i icon.jpg -s 960x960 -pix_fmt nv12 nv12.yuv</code></p><p>得到 <a href="https://github.com/yazhidev/AndroidDemo/blob/yuv/1dev/nv21.yuv" target="_blank" rel="noopener">yuv 格式图片</a> 后，存放到手机目录下，然后编写测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">val file = File(Environment.getExternalStorageDirectory().path + <span class="string">"/1dev/nv21.yuv"</span>)</span><br><span class="line"><span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从本地读取 yuv 图片字节数据</span></span><br><span class="line">        val fileInputStream = FileInputStream(file)</span><br><span class="line">        var data = ByteArray(fileInputStream.available())</span><br><span class="line">        fileInputStream.read(data)</span><br><span class="line">        fileInputStream.close()</span><br><span class="line">        <span class="comment">//测试图片分辨率</span></span><br><span class="line">        val width = <span class="number">960</span></span><br><span class="line">        val height = <span class="number">960</span></span><br><span class="line">        <span class="comment">//将 yuv 图片字节数据存放到 YuvImage 中</span></span><br><span class="line">        var  yuvImage = YuvImage(data, ImageFormat.NV21, width, height, <span class="keyword">null</span>)</span><br><span class="line">        val out = ByteArrayOutputStream()</span><br><span class="line">        <span class="comment">//使用 compressToJpeg 将存储的 yuv 数据转化为 RGB 图像</span></span><br><span class="line">        yuvImage.compressToJpeg(Rect(<span class="number">0</span>, <span class="number">0</span>, width, height), <span class="number">50</span>, out)</span><br><span class="line">        val imageBytes = out.toByteArray()</span><br><span class="line">        val bitmap = BitmapFactory.decodeByteArray(imageBytes, <span class="number">0</span>, imageBytes.size)</span><br><span class="line">        iv.setImageBitmap(bitmap)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: FileNotFoundException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得 bitmap 后就可以使用 ImageView 显示了。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200626_200450_20200624233949868_1857835977.png" alt="YUV 转换 RGB 后显示"></p><p>到这里其实还只是 api 层面的使用，后续还应该深入了解 YUV 到 RGB 的转换原理。另外 YUV 视频渲染、OpenGL es 的使用等，后续再学习记录~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-YUV&quot;&gt;&lt;a href=&quot;#什么是-YUV&quot; class=&quot;headerlink&quot; title=&quot;什么是 YUV&quot;&gt;&lt;/a&gt;什么是 YUV&lt;/h2&gt;&lt;p&gt;YUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。与RGB类似，但
      
    
    </summary>
    
    
      <category term="音视频" scheme="https://yazhidev.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Git</title>
    <link href="https://yazhidev.github.io/2020/02/21/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Git/"/>
    <id>https://yazhidev.github.io/2020/02/21/深入浅出-Git/</id>
    <published>2020-02-21T12:03:41.000Z</published>
    <updated>2022-06-07T22:58:54.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><h3 id="你可能遇到过"><a href="#你可能遇到过" class="headerlink" title="你可能遇到过"></a>你可能遇到过</h3><p><img src="http://upload-images.jianshu.io/upload_images/1929170-1df87423ad4cb974.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="版本管理"> </p><p>如果你遇到这个场景，<strong>那你可能需要版本控制</strong>。</p><h3 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h3><blockquote><p>版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了已录下来。每一次文件的改变，文件的版本号都将增加。除了记录版本变更外，版本控制的另一个重要功能是并行开发。<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/3448966" target="_blank" rel="noopener">软件开发</a>往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。并行开发中最常见的不同版本软件的错误(Bug)修正问题也可以通过版本控制中分支与合并的方法有效地解决。</p><p>—— <a href="[https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/3311252?fr=aladdin](https://baike.baidu.com/item/版本控制/3311252?fr=aladdin">版本控制 from 百度百科</a>)</p></blockquote><p>版本控制分为集中式、本地式、分布式。</p><h2 id="Git：分布式版本控制"><a href="#Git：分布式版本控制" class="headerlink" title="Git：分布式版本控制"></a>Git：分布式版本控制</h2><p>git 是一套以<strong>键值存储的文件寻址</strong>系统。</p><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p><img src="https://upload-images.jianshu.io/upload_images/1929170-9d846451dab34c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git"> </p><p>Workspace：工作区</p><p>Index：暂存区</p><p>Repository：仓库</p><p>Remote：远程仓库</p><h3 id="数据存储原理"><a href="#数据存储原理" class="headerlink" title="数据存储原理"></a>数据存储原理</h3><h4 id="SH1A-算法"><a href="#SH1A-算法" class="headerlink" title="SH1A 算法"></a>SH1A 算法</h4><p>哈希算法的一种。对文件内容进行计算，可以得到一个哈希值，形如 <code>5453545dccd33565a585ffe5f53fda3e067b84d8</code>。<br>对于内容不同的对象，会计算得到不同的SHA1哈希值。</p><h4 id="几种类型文件"><a href="#几种类型文件" class="headerlink" title="几种类型文件"></a>几种类型文件</h4><p>Git 目录（.git/objects/）的几种（对象）类型文件：</p><h5 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h5><p>用来存储文件内容，或者说表示一个（<strong>完整的</strong>）文件，而不仅仅只是差异存储。<br>Git 通过使用 zlib 压缩文件，可以有效地压缩<strong>文本文件</strong>的体积。因此 Git 比较适用于对文本文件的管理，对于二进制文件（比如音频、视频）则压缩比不大。<br>每个 blob 对象都会通过 SHA1 算法生成哈希值作为<strong>指针（或者叫索引、Key等）</strong>，指向该文件的压缩。<br>两个一样内容只是名字不同的文件，会共享同一个 blob 对象。因为内容的 SHA1 是一样的。</p><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p>这里说的 index 就是上面说的暂存区的实体存在，其实是一个文件，位于 <code>.git/index</code> ，直接打开会乱码，可以使用命令 <code>git ls-files --stage</code> 查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --stage</span><br><span class="line">----</span><br><span class="line">100644 92390d97e4159df5c7ef31baf03c8a3378c93395 0       a.txt</span><br><span class="line">100644 ff532afc325d8a07df0e2e3cb37bbee271d05840 0       dirb/b.txt</span><br></pre></td></tr></table></figure><p>里面记录了所有跟踪文件的 blob 对象的哈希值，以及文件的路径。<br>如果文件内容没有改变，index 里则一直指向旧的哈希值。</p><h5 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h5><p>代表的是目录结构，或者简单理解为代表一个目录。tree 对象也会通过 SHA1 算法生成哈希值作为指针。tree 对象中包含一条或多条 blob 的指针。<br>目录结构如果是一样的，会共享同一个 tree 对象。</p><h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5><p>commit 存储一次提交的信息，包括 tree、blob，父节点（的 commit id），以及提交的作者是谁等信息。<br>commit 的 ID 值就是对对象内容进行 SHA1 算法得到的哈希值。</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-2b25237e262ab9f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git数据存储"> </p><h3 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h3><p>git add，生成 blob 文件，同时 index 文件中记录。<br>git commit 时，根据 index 文件中记录的内容，生成 tree 对象和 commit 对象。</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>体现在目录的 <code>./git/refs/heads/</code> 中，这里包含master和一些其他分支文件。每个分支文件保存的是一个 <code>commitID</code>。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>其实就是保存了 <code>commitID</code></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>了解了原理后，再回过头来看一些常用的 Git 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git pull</span><br><span class="line">git push</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1929170-d14cf3c1b0d2f22a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git 工作流程"> </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>分享个小故事。大家应该都知道 Linux ——世界上最知名的开源操作系统，Android 系统就是基于 Linux 内核开发。它由 Linus Torvalds 在 1991 年发明，并最终经由开源社区的无数个开发者共同开发，至今仍然是最充满生命力的操作系统之一。</p><p>2005 年，Linux 开发团队一直使用的商业版本控制系统 BitKeeper 宣布不再免费授权社区使用，Linus 在各种交涉无果后，<strong>花了两周时间</strong>自己用 C 写了一个分布式版本控制系统并且开源了，一个月之内整个 Linux 系统的源码就交由 Git 管理了。至此之后 Git 迅速成为最流行的版本控制系统之一。2008 年，Github 网站上线，为开源项目免费提供 Git 存储，总多知名项目纷纷迁移至 Github，同时也造福了无数的个人开发者。</p><h3 id="开源万岁！"><a href="#开源万岁！" class="headerlink" title="开源万岁！"></a><strong>开源万岁！</strong></h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/tonyq/p/7596131.html" target="_blank" rel="noopener">Git 是如何存储文件的</a><br><a href="https://www.cnblogs.com/blog-cxj2017522/p/6902545.html" target="_blank" rel="noopener">Git底层原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h2&gt;&lt;h3 id=&quot;你可能遇到过&quot;&gt;&lt;a href=&quot;#你可能遇到过&quot; class=&quot;headerlink&quot; title=&quot;你可能遇到过&quot;&gt;&lt;/a&gt;你
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机编码原理</title>
    <link href="https://yazhidev.github.io/2019/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/"/>
    <id>https://yazhidev.github.io/2019/07/21/计算机编码原理/</id>
    <published>2019-07-21T13:10:01.000Z</published>
    <updated>2022-06-07T22:58:54.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="码表"><a href="#码表" class="headerlink" title="码表"></a>码表</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>计算机保存的是二进制代码，使用码表使每个二进制代码代替十进制数。这张表中规定了字符和二进制的映射关系。计算机存储字符时将字符查询码表，然后存储对应的二进制。计算机取出字符时将二进制查询码表，然后转换成对应的字符显示。</p><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>美国码表，码表中只有英文大小写字母、数字、美式标点符号等。每个字符占用1个字节，所有字符映射的二进制都为正数，因此有128个字符映射关系。</p><h3 id="GBK-GB18030"><a href="#GBK-GB18030" class="headerlink" title="GBK/GB18030"></a>GBK/GB18030</h3><p>GBK 编码是使用双字节来表示的，即不论中、英文字符均使用双字节来表示，为了区分中文，将其最高位都设定成1。GBK包含全部中文字符，是国家编码，通用性比UTF8差，不过UTF8占用的数据库比GBK大。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode 是一个很大的集合，是十六进制的，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。</p><p>Unicide 是一个符号集，规定了符号的二进制代码，却没有规定如何存储二进制代码。那么如何区别 unicode 和 ascii 呢？计算机怎么知道三个字节表示一个符号，而不是三个符号？于是就衍生了 UTF-8。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8 是 unicode 的一种实现方式之一。它是一种可变长度字符集,每个字符编码最多四个字节。</p><p>UTF-8的编码规则很简单，只有二条： </p><ol><li><p>对于单字节的符号，字节的第一位（字节的最高位）设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p></li><li><p>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p></li></ol><table><thead><tr><th>Unicode符号范围 (十六进制)</th><th>UTF-8编码方式 （二进制） </th></tr></thead><tbody><tr><td>0000 0000-0000 007F</td><td>0xxxxxxx </td></tr><tr><td>0000 0080-0000 07FF</td><td>110xxxxx 10xxxxxx </td></tr><tr><td>0000 0800-0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx </td></tr><tr><td>0001 0000-0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx </td></tr></tbody></table><p>因此对于英语字母，使用 utf-8 与 ascii 是一样的。</p><p>UTF-8 存储的字符，除了第一个字节外，其余字节的头两个比特都是以”10”开始，使文字处理器能够较快地找出每个字符的开始位置。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>例如“严”，unicode 字符是 <code>4E25（100111000100101）</code>，<code>4e25</code> 在第三行范围，因此需要三个字节，将二进制码以此替换掉上面的 x，得到最终的 utf-8 编码为：<code>11100100 10111000 10100101</code>。转换成十六进制就是<code>E4B8A5</code></p><p>虽然 utf-8 具有良好的国际通用性，但是 utf-8 中的中文使用三个字节来编码，比 gbk 多占用了 50% 的存储空间。下面来介绍 gbk 编码方式。</p><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>是基于 64 个可打印的字符来表示二进制的数据的一种方法，用于解决中文、日文等文字无法被服务器或网关有效处理。</p><p>64 个字符：A~Z、a~z、0~9、+、/，还会使用 = 做填充字符</p><h3 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h3><ol><li>三个字节分一组，每个字节 8 位，总共 24 位</li><li>将 24 位每 6 位分一组，共分为四组（如果不足6位则补0，如果 6 位全是空的，则使用 = 号代替）</li><li>每组前面添加 2 个 0，变为 8 位二进制位，共四个字节</li><li>使用每个字节的值作索引，获得对应的值</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/wo541075754/article/details/81734770" target="_blank" rel="noopener">一篇文章彻底弄懂Base64编码原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;码表&quot;&gt;&lt;a href=&quot;#码表&quot; class=&quot;headerlink&quot; title=&quot;码表&quot;&gt;&lt;/a&gt;码表&lt;/h2&gt;&lt;h3 id=&quot;理解&quot;&gt;&lt;a href=&quot;#理解&quot; class=&quot;headerlink&quot; title=&quot;理解&quot;&gt;&lt;/a&gt;理解&lt;/h3&gt;&lt;p&gt;计算机
      
    
    </summary>
    
    
      <category term="计算机原理" scheme="https://yazhidev.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin 核心编程》读书笔记</title>
    <link href="https://yazhidev.github.io/2019/07/17/%E3%80%8AKotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://yazhidev.github.io/2019/07/17/《Kotlin-核心编程》读书笔记/</id>
    <published>2019-07-17T14:04:57.000Z</published>
    <updated>2022-06-07T22:58:54.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="密封类-sealed"><a href="#密封类-sealed" class="headerlink" title="密封类 sealed"></a>密封类 sealed</h3><p>密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。</p><h3 id="第五章-类型系统"><a href="#第五章-类型系统" class="headerlink" title="第五章 类型系统"></a>第五章 类型系统</h3><p><code>as</code> 不安全的类型转换，转换失败会抛类型转换失败异常。使用 <code>as？</code> 转换失败返回 null。</p><p>Int 等同于 int</p><p>Int? 等同于 Integer</p><h4 id="协变与不变"><a href="#协变与不变" class="headerlink" title="协变与不变"></a>协变与不变</h4><p>java 中数组是协变的，意思就是任意 A 是 B 的父类，则 A[] 也是 B[] 的父类。</p><p>List 是不变的，只知道自己是一个 Lit，无法获取泛型参数的类型。Kotlin 中数值支持泛型，当然也不再协变。Any 是所有类的父类，但是你不能将任意一个对象数组赋值给 Array<any>。</any></p><p>Kotlin 中 List 是协变的。因为 Kotlin 中 List 的定义是 <code>publick interface List&lt;out E&gt; : Collection&lt;E&gt; {}</code>，out 关键字，说明泛型类和泛型方法是协变的。为了保证类型安全，kotlin 中的 List 是无法添加元素的。</p><h4 id="获取泛型类型"><a href="#获取泛型类型" class="headerlink" title="获取泛型类型"></a>获取泛型类型</h4><ol><li><p>通过匿名内部类</p><p> 泛型虽然是类型擦除的，但是类型信息是放在对应 class 的常量池中的。匿名内部类在初始化的时候会绑定父类或父接口的相应信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val list = object: ArrayLisr&lt;String&gt;()</span><br><span class="line">print(list.javaClass.genericSuperclass)</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>使用内联函数</p><p> kotlin 内联函数在编译的时候编译期会将相应的字节码插入调用的地方，也就是说，参数类型也会被插入字节码中。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在kotlin中一个内联函数（inline）可以被具体化（reified），这意味着我们可以得到使用泛型类型的Class</span><br><span class="line">inline fun &lt;reified T&gt; getType() &#123;</span><br><span class="line">    return T::class.java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>需要注意的是，Java 并不支持指定一个函数是否内联，所以 reified 来实例化的内联函数不能在 Java 中调用，因为它永远是需要内联的。</code></pre><h4 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h4><p><out t>  -&gt; Java 中的 &lt;? extends T&gt;</out></p><p><in t>  -&gt; Java 中的 &lt;? super T&gt;</in></p><h2 id="第-6-章-Lambda-和集合"><a href="#第-6-章-Lambda-和集合" class="headerlink" title="第 6 章 Lambda 和集合"></a>第 6 章 Lambda 和集合</h2><h3 id="序列-sequence"><a href="#序列-sequence" class="headerlink" title="序列 sequence"></a>序列 sequence</h3><p>序列是惰性求值（延时求值）的，普通集合进行链式操作是（例如 filter、map），每一步都会先产生新的集合，而序列则是将所有操作都应用在一个元素上，当第一个元素执行完 filter、map 后，第二个元素再继续执行 filter、map。</p><p>与 Java8 的流（Stream）不同，流是一次性的，只能遍历一次。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>inline 修饰的函数，会被内联进调用它的地方。直接在字节码中生成相应的函数体实现</p><h4 id="实现非局部返回"><a href="#实现非局部返回" class="headerlink" title="实现非局部返回"></a>实现非局部返回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun localReturn() &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fun foo() &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    localReturn()</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//打印出12</span><br></pre></td></tr></table></figure><p>因为函数体中的 return 只会在该函数的局部生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun foo(returning: () -&gt; Unit) &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    returning()</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//报错：Lambda 中不允许存在 return</span><br></pre></td></tr></table></figure><p>这时可以使用内联函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun foo(returning: () -&gt; Unit) &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    returning()</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用标签实现 Lambda 非局部返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    foo &#123;return@foo&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第七章-多态和扩展"><a href="#第七章-多态和扩展" class="headerlink" title="第七章 多态和扩展"></a>第七章 多态和扩展</h2><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>operator 关键字叫上 Kotlin 规定的函数名：plus（加法），minus（减法），times（乘法），div（除法），mod（取余）等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data class Area(val valus: Double)</span><br><span class="line"></span><br><span class="line">operator fun Area.plus(that: Area): Area &#123;</span><br><span class="line">    return Area(this.value + that.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    print(Area(1.0) + Area(2.0))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展函数实现机制"><a href="#扩展函数实现机制" class="headerlink" title="扩展函数实现机制"></a>扩展函数实现机制</h3><p>可以将扩展函数理解为静态方法。</p><p>使用扩展函数添加属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val Mutablelist&lt;Int&gt;.sumIsEven: Boolean</span><br><span class="line">    get() = this.sum() % 2 == 0</span><br></pre></td></tr></table></figure><h3 id="静态与动态调度"><a href="#静态与动态调度" class="headerlink" title="静态与动态调度"></a>静态与动态调度</h3><p>调用重载方法时，调用变为静态并且取决于编译时类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(Base base) &#123;&#125;</span><br><span class="line"></span><br><span class="line">void foo(Extanded base) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Base base = new Extended()</span><br><span class="line">foo(base) //调用的是 Base 参数类型的方法</span><br></pre></td></tr></table></figure><h2 id="第九章-设计模式"><a href="#第九章-设计模式" class="headerlink" title="第九章 设计模式"></a>第九章 设计模式</h2><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><ol><li>使用类委托减少样板代码</li></ol><p>使用 by 关键字，将装饰类的所有方法委托给被装饰对象，然后只需要复写需要装饰的方法即可。</p><ol start="2"><li>使用扩展函数代替装饰者</li></ol><h2 id="第十章-函数式编程"><a href="#第十章-函数式编程" class="headerlink" title="第十章 函数式编程"></a>第十章 函数式编程</h2><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>也称正则序，当用到时才求值</p><h2 id="第十一章-异步和并发"><a href="#第十一章-异步和并发" class="headerlink" title="第十一章 异步和并发"></a>第十一章 异步和并发</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步指的是一个行为，当执行的时候，在代码层面需要我们主动去等待结果，直到结果返回。</p><p>多线程执行时看上去是同步执行，但是线程执行是通过 CPU 调度，CPU 在每个线程间快速切换，同一个时间片内只能执行一个线程。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是一个无优先级的子程序调度组件，允许子程序。线程包含于进程，协程包含于线程。只要内存只够， 一个线程中可以有任意多个协程，但某一个时刻只能有一个协程在运行，多个协程共享该线程分配到的计算机资源。</p><h4 id="launch-和-runBlocking"><a href="#launch-和-runBlocking" class="headerlink" title="launch 和 runBlocking"></a>launch 和 runBlocking</h4><p>runBloking 是最高级的协程，也就是主协程。launch 创建的线程能够在 runBlocking 中运行，反过来不行。runBlocking 会阻塞当前执行的线程。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val job = launch &#123;</span><br><span class="line">    search()</span><br><span class="line">&#125;</span><br><span class="line">job.join()</span><br></pre></td></tr></table></figure><p>join 后程序会一直等待，直到启动的协程结束。这里的等待是非阻塞式的等待，不会将当前线程挂起。</p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>会创建一个子协程，会和其他子协程一样并行工作。async 会返回一个 Deferred 对象。Deferred 值是一个非阻塞可取消的 future，是一个带有结果的 job。</p><p>future 的意思是，将来会返回一个结果，利用 await 方法可以等待这个值的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第四章&quot;&gt;&lt;a href=&quot;#第四章&quot; class=&quot;headerlink&quot; title=&quot;第四章&quot;&gt;&lt;/a&gt;第四章&lt;/h2&gt;&lt;h3 id=&quot;密封类-sealed&quot;&gt;&lt;a href=&quot;#密封类-sealed&quot; class=&quot;headerlink&quot; title=&quot;密
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://yazhidev.github.io/tags/Kotlin/"/>
    
      <category term="读书笔记" scheme="https://yazhidev.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>理解 WindowManagerService</title>
    <link href="https://yazhidev.github.io/2019/04/15/%E7%90%86%E8%A7%A3%20WindowManagerService%20/"/>
    <id>https://yazhidev.github.io/2019/04/15/理解 WindowManagerService /</id>
    <published>2019-04-15T00:20:00.000Z</published>
    <updated>2022-06-07T22:58:54.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>是一个抽象类，唯一的实现类是 PhoneWindow</p><p>分类：</p><ol><li><p>父 Window</p></li><li><p>子 Window，不能单独存在，需要依附在父 window 上，例如 dialog</p></li><li><p>系统 Window，例如 toast</p></li></ol><h3 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h3><p>在 Activity attach 时构造了 PhoneWindow 的实例对象。</p><h3 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h3><p>是一个接口，用于操作 Window，继承了 ViewManager。实现类是 WindowManagerImpl</p><p>ViewManager 的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params);</span><br><span class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params);</span><br><span class="line">public void removeView(View view);</span><br></pre></td></tr></table></figure><p>可以看到三个操作方法都是针对 View 的，View 是 Window 的实体类</p><h3 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h3><p>没有直接操作 View，而是交个了 mGlobal（WindowManagerGlobal）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h3><p>保存了所有的 ViewRootImpl，在 addView 时会创建 ViewRootImpl 实例，并将要 add 的 View 设置给 ViewRootImpl（见源码 1.1）</p><p>View 的绘制过程是由 ViewRootImpl 来完成的。在新建一个 Activity 时，这个要 add 的 View 就是 DecorView。</p><h3 id="IWindowSession"><a href="#IWindowSession" class="headerlink" title="IWindowSession"></a>IWindowSession</h3><p>(AIDL)窗口令牌，描述了一个显示行为，并且WMS要求每一个窗口必须隶属于某一个显示令牌。</p><h3 id="WindowState"><a href="#WindowState" class="headerlink" title="WindowState"></a>WindowState</h3><p>当向WMS添加一个窗口时，WMS会为其创建一个WindowState。</p><h3 id="WindowManagerService（WMS）"><a href="#WindowManagerService（WMS）" class="headerlink" title="WindowManagerService（WMS）"></a>WindowManagerService（WMS）</h3><p>WMS为所有窗口分配Surface，掌管Surface的显示顺序（Z-order）以及位置尺寸，控制窗口动画，并且还是输入系统的一重要的中转站。</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-32447838580d50e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Window 体系图"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//WindowManagerGlobal </span><br><span class="line"></span><br><span class="line">private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"></span><br><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">            Display display, Window parentWindow) &#123;</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">mRoots.add(root);</span><br><span class="line">root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yhaolpz/article/details/68936932" target="_blank" rel="noopener">Android 带你彻底理解 Window 和 WindowManager</a></p><p><a href="https://blog.csdn.net/wf_fln/article/details/78593080" target="_blank" rel="noopener">深入理解WindowManagerService</a></p><p><a href="https://blog.csdn.net/afu10086/article/details/80138154" target="_blank" rel="noopener">WindowManagerService 分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h2&gt;&lt;h3 id=&quot;Window&quot;&gt;&lt;a href=&quot;#Window&quot; class=&quot;headerlink&quot; title=&quot;Windo
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread、IntentService 理解</title>
    <link href="https://yazhidev.github.io/2019/04/02/HandlerThread%E3%80%81IntentService%E7%90%86%E8%A7%A3/"/>
    <id>https://yazhidev.github.io/2019/04/02/HandlerThread、IntentService理解/</id>
    <published>2019-04-02T00:20:16.000Z</published>
    <updated>2022-06-07T22:58:54.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread 继承 Thread，HandlerThread 本质上就是一个普通 Thread，只不过内部建立了 Looper，因此拥有自己的消息队列。不适合频繁处理耗时操作，因为消息是串行处理的，某个人任务执行时间过长，会导致后续的任务被延迟处理</p><p>通过调用 Thread 的 start 方法开始运行<br>结束消息轮询也是通过操作 Looper 实现的，退出 Looper 后，线程没有可执行代码，则会自动结束</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>在 run 方法内初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepare();</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">Process.setThreadPriority(mPriority);</span><br><span class="line">onLooperPrepared();</span><br><span class="line">Looper.loop(); //开启轮询，因此除非主动退出，否则线程不会结束</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean quit() &#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    if (looper != null) &#123;</span><br><span class="line">        looper.quit();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个 quitSafely 方法。二者的区别是调用了 MessageQueue 的 <code>void quit(boolean safe)</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// MessageQueue</span><br><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">···</span><br><span class="line">if (safe) &#123;</span><br><span class="line">        removeAllFutureMessagesLocked();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        removeAllMessagesLocked();</span><br><span class="line">    &#125;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// removeAllMessagesLocked 方法，将队列里的所有消息不经检查直接回收</span><br><span class="line">private void removeAllMessagesLocked() &#123;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//removeAllFutureMessagesLocked 会将延时消息移除，非延迟消息会派发</span><br><span class="line">private void removeAllFutureMessagesLocked() &#123;</span><br><span class="line">    final long now = SystemClock.uptimeMillis();</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    if (p != null) &#123;</span><br><span class="line">        if (p.when &gt; now) &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Message n;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                n = p.next;</span><br><span class="line">                if (n == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (n.when &gt; now) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                p = n;</span><br><span class="line">                n = p.next;</span><br><span class="line">                p.recycleUnchecked();</span><br><span class="line">            &#125; while (n != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>四大组件是在主线程的，不可执行耗时操作。<br>IntentService 是个抽象类，需要实现抽象方法 onHandleIntent（可在该方法内执行耗时操作）。IntentService 会拥有消息队列（内部使用了 HandlerThread 的 Looper），且会在回调 onHandleIntent 后自动 stopSelf，销毁 Service。</p><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">super.onCreate();</span><br><span class="line">    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); //创建 HandlerThread 实例，并开启线程（Looper 轮询）</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ServiceHandler 收到消息后回调 onHandleIntent，执行用户的操作，执行完后销毁自身</span><br><span class="line">private final class ServiceHandler extends Handler &#123;</span><br><span class="line">    public ServiceHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开启 Service 后就发送个消息</span><br><span class="line">@Override</span><br><span class="line">public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HandlerThread&quot;&gt;&lt;a href=&quot;#HandlerThread&quot; class=&quot;headerlink&quot; title=&quot;HandlerThread&quot;&gt;&lt;/a&gt;HandlerThread&lt;/h2&gt;&lt;p&gt;HandlerThread 继承 Thread，Ha
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型</title>
    <link href="https://yazhidev.github.io/2019/03/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://yazhidev.github.io/2019/03/28/Java-内存模型/</id>
    <published>2019-03-27T23:46:13.000Z</published>
    <updated>2022-06-07T22:58:54.438Z</updated>
    
    <content type="html"><![CDATA[<p>Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。</p><p>经典问题：</p><p>20 个线程，每个线程都对同一个 int 做自增操作 100 次，最后的结果 i 一定小余 2000。</p><p>Java中的运算操作，例如自增或自减，若没有进行额外的同步操作，在多线程环境下就是线程不安全的。num++解析为num=num+1，明显，这个操作不具备原子性，多线程并发共享这个变量时必然会出现问题。</p><p>原因：</p><p>普通变量的值在线程间传递都需要通过主内存来完成。例如，线程 A 修改了一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。 </p><p>Java中的原子操作包括： </p><ul><li>除long和double之外的基本类型的赋值操作（long和double占用的字节数都是8，在32位操作系统上对64位的数据的读写要分两步完成，虽然 volatile 只保证可见性，但 java 内存模型保证声明为 volatile 的long和double变量的get和set操作是原子的。）</li><li>所有引用reference的赋值操作 </li><li>java.concurrent.Atomic.* 包中所有类的一切操作。 </li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>一个线程对一个变量进行更改操作 其他线程获取会获得最新的值</p><p>sleep 方法并没有加锁，为什么能够保证可见性。sleep是阻塞线程并不释放锁，让出cpu调度。让出cpu调度后下次执行会刷新工作内存</p><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>在单线程中不影响最终结果，jvm 会对指令做优化排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在线程A中执行:</span><br><span class="line"></span><br><span class="line">context = loadContext(); （1）</span><br><span class="line">contextReady = true; （2）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在线程B中执行:</span><br><span class="line"></span><br><span class="line">if(contextReady) &#123;</span><br><span class="line">   context.xxx </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1，2 的顺序可能因为指令重排做了调换。先执行2，再执行1。</p><p>因此在多线程中可能导致线程 B 中， context 还没有初始化，但 contextReady 已经是 true，就报空指针。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>1.阻止屏障两侧的指令重排序；<br>2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li><p>内存屏障策略：</p><p>  在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</p><p>  在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p></li></ul><p>因此 volatile 可以做到：</p><ol><li><p>线程的可见性</p><p> volatile 变量在各个线程的工作内存中不存在一致性问题。因为每次赋值后，都会通过内存屏障更新主存中的值。</p></li><li><p>禁止指令重排</p><p> 因为每次读写前后都会插入内存屏障，而内存屏障前后的指令不可被重排。</p></li></ol><p>但是需要注意的是 volatile 只保证可见性，并不保证原子性。为了实现上述 i++ 的原子性运算，需要用到实现线程安全的两个保障手段：阻塞同步和非阻塞同步都是。</p><ul><li><p>阻塞同步</p><p>  即加锁。但是会带来线程阻塞和唤醒的性能开销</p></li><li><p>非阻塞同步</p><p>  对于阻塞同步而言主要解决了阻塞同步中线程阻塞和唤醒带来的性能问题。在并发环境下，某个线程对共享变量先进行操作，如果没有其他线程争用共享数据那操作就成功；如果存在数据的争用冲突，那就才去补偿措施，比如不断的重试机制，直到成功为止，因为这种乐观的并发策略不需要把线程挂起，也就把这种同步操作称为非阻塞同步（操作和冲突检测具备原子性）。Java 中实现 CAS 乐观锁的方式是使用 AtomicInteger。</p></li></ul><h2 id="CAS（Compare-And-Swap-比较并交换）"><a href="#CAS（Compare-And-Swap-比较并交换）" class="headerlink" title="CAS（Compare-And-Swap 比较并交换）"></a>CAS（Compare-And-Swap 比较并交换）</h2><p>CAS 操作包含三个操作数：内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p><p>Java 的 CAS 会使用 cpu 上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作。但 CAS 也存在一些问题：</p><ol><li><p>ABA 问题</p><p> 如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p></li><li><p>循环时间长开销大</p></li></ol><ol start="3"><li><p>只能保证一个共享变量的原子操作</p><p> AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p></li></ol><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>依赖于 Unsafe 提供的一些底层能力，实现了 CAS 的乐观锁。如果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// AtomicInteger</span><br><span class="line">private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">private static final long VALUE;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        VALUE = U.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); //用于返回类定义的某个属性在主存中设定的偏移量</span><br><span class="line">    &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile int value; //使用 volatile 保证可见性</span><br><span class="line"></span><br><span class="line">public AtomicInteger(int initialValue) &#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//原子性的加法运算，依赖 Unsafe 类</span><br><span class="line">public final int addAndGet(int delta) &#123;</span><br><span class="line">    return U.getAndAddInt(this, VALUE, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Unsafe</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2); //通过对象引用地址和 value 值的偏移量，获取 value 的值</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// natUnsafe.cc 底层实现</span><br><span class="line"></span><br><span class="line">jboolean</span><br><span class="line">sun::misc::Unsafe::compareAndSwapInt (jobject obj, jlong offset,</span><br><span class="line">      jint expect, jint update)</span><br><span class="line">&#123;</span><br><span class="line">  jint *addr = (jint *)((char *)obj + offset);</span><br><span class="line">  return compareAndSwap (addr, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline bool</span><br><span class="line">compareAndSwap (volatile jint *addr, jint old, jint new_val)</span><br><span class="line">&#123;</span><br><span class="line">  jboolean result = false;</span><br><span class="line">  spinlock lock;</span><br><span class="line">  if ((result = (*addr == old))) //如果值不相等就什么也不做，返回 false</span><br><span class="line">    *addr = new_val;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。&lt;/p&gt;
&lt;p&gt;经典问题：&lt;/p&gt;
&lt;p&gt;20 个线程，每个线程都对同一个 int 做自增操作 100 次，最后的结果 i 一定小余 2000。&lt;/p&gt;
&lt;p&gt;Java中的运算操作，例如
      
    
    </summary>
    
    
      <category term="Java" scheme="https://yazhidev.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析 Binder 机制</title>
    <link href="https://yazhidev.github.io/2019/03/15/%E6%B5%85%E6%9E%90-Binder-%E6%9C%BA%E5%88%B6/"/>
    <id>https://yazhidev.github.io/2019/03/15/浅析-Binder-机制/</id>
    <published>2019-03-15T00:37:24.000Z</published>
    <updated>2022-06-07T22:58:54.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ol><li><p>进程隔离</p><p> 进程隔离，不同进程之间，不共享内存。而操作系统是多进程的，因此需要 IPC。</p></li><li><p>进程空间划分</p><p> Kernel 是操作系统的核心，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。因此把 Kernel 和上层的应用程序隔离，分为内核空间和用户空间。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1929170-e63a92df044802ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程隔离"></p><p>Android 利用了 Linux 的动态可加载内核模块机制，使 Binder 驱动运行在内核空间，负责各个用户进程通信。</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-f42db494f98df733.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder 机制"></p><h3 id="Binder-通信模型：C-S-模型"><a href="#Binder-通信模型：C-S-模型" class="headerlink" title="Binder 通信模型：C/S 模型"></a>Binder 通信模型：C/S 模型</h3><p>通信过程：</p><ol><li>Server 向 ServiceManager 也是通过发送 Binder 消息注册。ServiceManager 是比较特殊的服务，所有应用都能直接使用，因为ServiceManager对于Client端来说Handle句柄是固定的，都是0，所以ServiceManager服务并不需要查询，可以直接使用。</li><li>client 通过 ServiceManager 获得一个 server 的 Binder 实体的代理，对 server 进行调用。代理接口中定义的方法与 server 中定义的方法时一一对应的。</li><li>client 调用某个代理接口中的方法时，代理接口的方法会将 client 传递的参数打包成 Parcel 对象。client 线程挂起。</li><li>代理接口将 Parcel 发送给内核中的 binder 驱动。驱动通过一系列调用，将请求派发给 server 的 Binder 本地对象的 onTransact 方法。</li><li>onTransact 方法解包 Parcel 对象，处理并将结果返回给 binder 驱动，驱动唤醒 client 线程，并将结果返回。</li></ol><p>Android APP进程都是由Zygote进程孵化出来的。常见场景：点击桌面icon启动APP，或者startActivity启动一个新进程里面的Activity，最终都会由AMS去调用Process.start()方法去向Zygote进程发送请求，让Zygote去fork一个新进程，Zygote收到请求后会调用Zygote.forkAndSpecialize()来fork出新进程,之后会通过RuntimeInit.nativeZygoteInit来初始化Andriod APP运行需要的一些环境，而binder线程就是在这个时候新建启动的。</p><p>IPC 是一个概念，Binder 是一种 IPC 的具体实现；AIDL 是 Binder 机制向外提供的接口，目的就是为了方便对 Binder 的使用；</p><p>Android 系统匿名共享内存 Ashmem，其作用之一即通过 Binder 进程间通信机制来实现进程间的内存共享。 </p><p>Client 进程只不过是持有了 Server端的代理；代理对象协助驱动完成了跨进程通信。</p><p>对 Server 来说，Binder 就是 Binder 本地对象，对 Client 来说, Binder 是 Binder 本地对象的代理。在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册。</p><p>我们所持有的Binder引用(即服务端的类引用)并不是实际真实的远程Binder对象，我们的引用在Binder驱动里还要做一次映射。客户端要调用远程对象函数时，只需把数据写入到Parcel，在调用所持有的Binder引用的transact()函数，transact函数执行过程中会把参数、标识符（标记远程对象及其函数）等数据放入到Client的共享内存，Binder驱动从Client的共享内存中读取数据，根据这些数据找到对应的远程进程的共享内存，把数据拷贝到远程进程的共享内存中，并通知远程进程执行onTransact()函数。远程进程Binder对象执行完成后，将结果写入自己的共享内存中，Binder驱动再将远程进程的共享内存数据拷贝到客户端的共享内存，并唤醒客户端线程。</p><p>整个的调用过程是一个同步过程，在server处理的时候，client会block住。因此client调用过程不应在主线程。</p><p>区别于传统的 IPC 的两次拷贝， Binder 机制使用内存映射。</p><p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。<br>只需要一次拷贝（用户内核到服务内核的拷贝）内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>Client 连接 Server 时，需要创建一个 ServiceConnection 作为入参，ServiceConnection 的回调方法 onServiceConnected 中会通过 asInterface(IBinder binder) 拿到 IBinder 对象，如果 Client 和 Server 在同一个进出，binder 就是 Binder 本地对象，否则是一个代理对象。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5acccf845188255c3201100f#heading-23" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a></p><p><a href="https://blog.csdn.net/augfun/article/details/82343249" target="_blank" rel="noopener">简单理解Binder机制的原理</a></p><p><a href="https://blog.csdn.net/china0851/article/details/87945740" target="_blank" rel="noopener">https://blog.csdn.net/china0851/article/details/87945740</a></p><p><a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">Binder系列5—注册服务(addService)</a></p><p><a href="https://juejin.im/post/58c90816a22b9d006413f624" target="_blank" rel="noopener">听说你Binder机制学的不错，来解决下这几个问题（一）</a></p><p><a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;几个概念&quot;&gt;&lt;a href=&quot;#几个概念&quot; class=&quot;headerlink&quot; title=&quot;几个概念&quot;&gt;&lt;/a&gt;几个概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进程隔离&lt;/p&gt;
&lt;p&gt; 进程隔离，不同进程之间，不共享内存。而操作系统是多进程的，因此需要 IPC。&lt;/
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 焦点分发机制梳理</title>
    <link href="https://yazhidev.github.io/2019/03/13/Android-%E7%84%A6%E7%82%B9%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%A2%B3%E7%90%86/"/>
    <id>https://yazhidev.github.io/2019/03/13/Android-焦点分发机制梳理/</id>
    <published>2019-03-13T11:45:06.000Z</published>
    <updated>2022-06-07T22:58:54.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><p>连接 DecorView， Window</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-c5ffeb5b3fc4096d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>DecorView -&gt; Activity -&gt; PhoneWindow -&gt; DecorView 的来回绕一圈。</p><p>既然触摸事件已经到了 Activity.dispatchTouchEvent() 中了，为什么不直接分发给 DecorView ，而是要通过PhoneWindow 来间接发送呢？因为 Activity 不知道有 DecorView 这种奇怪的东西存在啊！不知道！但是，Activity 持有 PhoneWindow ，而 PhoneWindow 当然知道自己的窗口里有些什么了，所以能够把事件派发给DecorView 。你看，在 Android 中，Activity 并不知道自己的 Window 中有些什么，这样耦合性就很低了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Activity</span><br><span class="line"></span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    ... </span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        //又把事件传到了Window中！</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return onTouchEvent(ev); </span><br><span class="line">    //这就是为什么最后事件没有被消费的话，Activity会去处理的原因。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InputStage-策略"><a href="#InputStage-策略" class="headerlink" title="InputStage 策略"></a>InputStage 策略</h2><p>在 RootViewImpl 中的函数通道是各种策略（InputStage）的组合，各策略负责的任务不同，如SyntheticInputStage、ViewPostImeInputStage、NativePostImeInputStage 等等，这些策略以链表结构结构起来，当一个策略者没有消费事件时，就传递个下一个策略者。其中触摸和按键事件由 ViewPostImeInputStage 处理。</p><p>ViewPostImeInputStage 是 ViewRootImpl 的内部类，</p><h2 id="分发-KeyEvent"><a href="#分发-KeyEvent" class="headerlink" title="分发 KeyEvent"></a>分发 KeyEvent</h2><ol><li><p>ViewPostImeInputStage</p><p>-&gt; onProcess (KeyEvent)</p><p>-&gt; processKeyEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">private int processKeyEvent(QueuedInputEvent q) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Deliver the key to the view hierarchy.</span><br><span class="line">    // mView 即 DecorView</span><br><span class="line">    if (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">        return FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // Handle automatic focus changes.</span><br><span class="line">   if (performFocusNavigation(event)) &#123;</span><br><span class="line">        return FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean performFocusNavigation(KeyEvent event) &#123;</span><br><span class="line">    int direction = 0;</span><br><span class="line">    switch (event.getKeyCode()) &#123;</span><br><span class="line">        case KeyEvent.KEYCODE_DPAD_LEFT:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case KeyEvent.KEYCODE_DPAD_RIGHT:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_RIGHT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case KeyEvent.KEYCODE_DPAD_UP:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_UP;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case KeyEvent.KEYCODE_DPAD_DOWN:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_DOWN;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case KeyEvent.KEYCODE_TAB:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_FORWARD;</span><br><span class="line">            &#125; else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">                direction = View.FOCUS_BACKWARD;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (direction != 0) &#123;</span><br><span class="line">        View focused = mView.findFocus();</span><br><span class="line">        if (focused != null) &#123;</span><br><span class="line">            View v = focused.focusSearch(direction);</span><br><span class="line">            if (v != null &amp;&amp; v != focused) &#123;</span><br><span class="line">                // do the math the get the interesting rect</span><br><span class="line">                // of previous focused into the coord system of</span><br><span class="line">                // newly focused view</span><br><span class="line">                focused.getFocusedRect(mTempRect);</span><br><span class="line">                if (mView instanceof ViewGroup) &#123;</span><br><span class="line">                    ((ViewGroup) mView).offsetDescendantRectToMyCoords(</span><br><span class="line">                            focused, mTempRect);</span><br><span class="line">                    ((ViewGroup) mView).offsetRectIntoDescendantCoords(</span><br><span class="line">                            v, mTempRect);</span><br><span class="line">                &#125;</span><br><span class="line">                if (v.requestFocus(direction, mTempRect)) &#123;</span><br><span class="line">                    playSoundEffect(SoundEffectConstants</span><br><span class="line">                            .getContantForFocusDirection(direction));</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Give the focused view a last chance to handle the dpad key.</span><br><span class="line">            if (mView.dispatchUnhandledMove(focused, direction)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mView.restoreDefaultFocus()) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DecorView</p><p>-&gt; dispatchKeyEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">    // Let the focused view and/or our descendants get the key first</span><br><span class="line">    return super.dispatchKeyEvent(event) || executeKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ViewGroup</p><p>-&gt; dispatchKeyEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if ((mPrivateFlags &amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS))</span><br><span class="line">            == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) &#123;</span><br><span class="line">        if (super.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (mFocused != null &amp;&amp; (mFocused.mPrivateFlags &amp; PFLAG_HAS_BOUNDS)</span><br><span class="line">            == PFLAG_HAS_BOUNDS) &#123;</span><br><span class="line">        if (mFocused.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类（View）处理了（return true），则不往下传。或者 mFocused 不为空，先 mFocused 分发，如果 mFocused 没有处理（返回 true），则 DecorView 最终返回 false，交由 ViewRoomImpl 继续处理。</p></li><li><p>View</p><p>-&gt; dispatchKeyEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ListenerInfo li = mListenerInfo;</span><br><span class="line">    if (li != null &amp;&amp; li.mOnKeyListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出，要拦截焦点分发，可以：</p><ul><li>设置 OnKeyListener 监听</li><li>重写 dispatchKeyEvent 方法并返回 true</li></ul></li><li><p>mView 分发焦点之后没有被处理，会先根据 KeyCode 为 direction 赋值，用于后续的寻找焦点。<code>View focused = mView.findFocus()</code> 会一层一层往下直到返回当前持有焦点的 View，如果 DecorView 的子 view 持有焦点（focused），则调用 focused 的 focusSearch 方法寻找下一个焦点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//ViewGroup</span><br><span class="line">@Override</span><br><span class="line">public View focusSearch(View focused, int direction) &#123;</span><br><span class="line">    if (isRootNamespace()) &#123;</span><br><span class="line">        // root namespace means we should consider ourselves the top of the</span><br><span class="line">        // tree for focus searching; otherwise we could be focus searching</span><br><span class="line">        // into other tabs.  see LocalActivityManager and TabHost for more info.</span><br><span class="line">        return FocusFinder.getInstance().findNextFocus(this, focused, direction);</span><br><span class="line">    &#125; else if (mParent != null) &#123;</span><br><span class="line">        return mParent.focusSearch(focused, direction);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//View</span><br><span class="line">public View focusSearch(@FocusRealDirection int direction) &#123;</span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        return mParent.focusSearch(this, direction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 focusSearch 方法最终调用 <code>FocusFinder.getInstance().findNextFocus(this, focused, direction)</code> 来寻找下一个获取焦点的 View。FocusFinder 会优先通过 View 在 XML 布局设置的下一个焦点的 ID 来查找焦点。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/b7cef3b3e703" target="_blank" rel="noopener">点击事件 InputStage</a></p><p><a href="https://juejin.im/entry/58f0212161ff4b0058e1b25f" target="_blank" rel="noopener">Android 焦点事件分发与传递机制</a></p><p><a href="https://www.jianshu.com/p/a633727ccb29" target="_blank" rel="noopener">焦点 inputStage 相关</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ViewRootImpl&quot;&gt;&lt;a href=&quot;#ViewRootImpl&quot; class=&quot;headerlink&quot; title=&quot;ViewRootImpl&quot;&gt;&lt;/a&gt;ViewRootImpl&lt;/h2&gt;&lt;p&gt;连接 DecorView， Window&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动模式</title>
    <link href="https://yazhidev.github.io/2019/03/13/Android-%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yazhidev.github.io/2019/03/13/Android-启动模式/</id>
    <published>2019-03-13T09:58:33.000Z</published>
    <updated>2022-06-07T22:58:54.435Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关的概念"><a href="#相关的概念" class="headerlink" title="相关的概念"></a>相关的概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/1929170-4fe897deaa6cf32b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关系图"></p><ol><li><p>ActivityStack</p><p> 应用程序在一个单例的 ActivityStack 中，一个 ActivityStack 可能包含了多个 task</p></li><li><p>TaskRecord</p><ol><li>一个进程（程序）有一个默认的task affinity，默认为包名</li><li>Activity 会进入启动它的 Activity 所在的 Task 栈中</li><li>app 的切换实质上就是 task 栈的切换</li></ol></li><li><p>ActivityRecord</p><p> 包含了一个Activity的所有信息，例如所在 task、所在进程的信息 ProcessRecord 等</p></li><li><p>ProcessRecord</p><p> 当前运行的进程信息</p></li></ol><h3 id="四种启动模式"><a href="#四种启动模式" class="headerlink" title="四种启动模式"></a>四种启动模式</h3><ol><li><p>standard</p><ol><li>Activity 会重新创建一个新的实例，不论原有实例是否存在。</li></ol></li><li><p>singleTop</p><p> 栈顶复用，要创建的 Activity 已经处于栈顶时，此时会直接复用栈顶的 Activity，不调用 onCreate、onStart，回调 onNewIntent</p><p> 与使用 Intent.FLAG_ACTIVITY_SINGLE_TOP 等价</p><p> 场景：消息推送界面。防止重复推送，多次打开某个页面</p></li><li><p>singleTask </p><p> 要创建的 Activity 已经处于栈中时，此时不会创建新的 Activity，而是将存在栈中的 Activity 上面的其他 Activity 所有销毁，使它成为栈顶</p><p> 与使用 Intent.FLAG_ACTIVITY_CLEAR_TOP 等价</p><p> 场景：主页</p></li><li><p>singleInstance</p><p> 会复用已有的 activity，且栈中只有一个 activity</p><p> 场景：呼叫来电界面</p></li></ol><h3 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h3><h4 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h4><p>FLAG_ACTIVITY_NEW_TASK 会先判断 activity 的 taskAffinity 指定的 task 是否已存在，如果已存在则不会新建 task，不存在则新建 task。如果配合 FLAG_ACTIVITY_MULTIPLE_TASK 一起使用，则不搜索是否已有 task，都会新建新的 task。</p><p>在 Service 中或使用 applicationContext 启动 Activity 必须要有该 flag。</p><h4 id="FLAG-ACTIVITY-MULTIPLE-TASK"><a href="#FLAG-ACTIVITY-MULTIPLE-TASK" class="headerlink" title="FLAG_ACTIVITY_MULTIPLE_TASK"></a>FLAG_ACTIVITY_MULTIPLE_TASK</h4><p>(FLAG_ACTIVITY_MULTIPLE_TASK)[<a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_MULTIPLE_TASK]" target="_blank" rel="noopener">https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_MULTIPLE_TASK]</a></p><p>This flag is used to create a new task and launch an activity into it. This flag is always paired with either FLAG_ACTIVITY_NEW_DOCUMENT or FLAG_ACTIVITY_NEW_TASK. In both cases these flags alone would search through existing tasks for ones matching this Intent. Only if no such task is found would a new task be created. When paired with FLAG_ACTIVITY_MULTIPLE_TASK both of these behaviors are modified to skip the search for a matching task and unconditionally start a new task. </p><p>举个栗子：</p><p>KotlinActivity 中只是用 FLAG_ACTIVITY_NEW_TASK 启动 activity，两个 activity 会在同一个 task 中。如果使用 FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK 启动 Main2Activity。两个 activity 会在不同的 task 中，但是 taskAffinity 是一样的，没指定默认是包名。</p><p>在 Service 中启动结果是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">newTask+mutable 后，task 是什么样</span><br><span class="line"></span><br><span class="line">Task id #771</span><br><span class="line">TaskRecord&#123;750276f #771 A=com.andy.demo U=0 sz=1&#125;</span><br><span class="line">Intent &#123; flg=0x18000000 cmp=com.andy.demo/.Main2Activity &#125;</span><br><span class="line">Hist #0: ActivityRecord&#123;c6870ec u0 com.andy.demo/.Main2Activity t771&#125;</span><br><span class="line">Intent &#123; flg=0x18000000 cmp=com.andy.demo/.Main2Activity &#125;</span><br><span class="line">ProcessRecord&#123;c9f9567 32573:com.andy.demo/u0a251&#125;</span><br><span class="line"></span><br><span class="line">Task id #770</span><br><span class="line">TaskRecord&#123;4222f14 #770 A=com.andy.demo U=0 sz=1&#125;</span><br><span class="line">Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.andy.demo/.KotlinActivity &#125;</span><br><span class="line">Hist #0: ActivityRecord&#123;447e0c4 u0 com.andy.demo/.KotlinActivity t770&#125;</span><br><span class="line">Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.andy.demo/.KotlinActivity &#125;</span><br><span class="line">ProcessRecord&#123;c9f9567 32573:com.andy.demo/u0a251&#125;</span><br></pre></td></tr></table></figure><h3 id="附-adb-命令"><a href="#附-adb-命令" class="headerlink" title="附 adb 命令"></a>附 adb 命令</h3><p><code>adb shell dumpsys activity activities</code> 获取运行的 activity</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相关的概念&quot;&gt;&lt;a href=&quot;#相关的概念&quot; class=&quot;headerlink&quot; title=&quot;相关的概念&quot;&gt;&lt;/a&gt;相关的概念&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java 类加载机制</title>
    <link href="https://yazhidev.github.io/2019/03/02/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://yazhidev.github.io/2019/03/02/Java-类加载机制/</id>
    <published>2019-03-02T12:39:55.000Z</published>
    <updated>2022-06-07T22:58:54.438Z</updated>
    
    <content type="html"><![CDATA[<p>类的生命周期</p><p><img src="http://upload-images.jianshu.io/upload_images/1929170-3b72184710adf2be.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类生命周期"></p><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p>分为五个部分：加载，验证，准备，解析，初始化</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类变量分配内存并设置类变量初始值</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用。（虚拟机将运行时常量池中那些仅代表其他信息的符号引用（例如字节码中的 #1，#2 等）解析为直接指向所需信息所在地址的指针。）</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。</client></client></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节码（.class 文件）。类加载器负责读取 Java 字节码，并转换成 java.lang.Class 类的一个实例。</p><p>关于类加载器需要了解：</p><h3 id="类加载器的命名空间"><a href="#类加载器的命名空间" class="headerlink" title="类加载器的命名空间"></a>类加载器的命名空间</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。也就是说，你现在要比较两个类是否相等，只有在这两个类是同一个类加载器加载的前提下才有意义。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>JVM中有三种系统提供的类加载器：启动类加载器，扩展类加载器、应用程序类加载器。某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><p>该机制最大的好处就是让 Java 类同其类加载器一起具备了一种带优先级的层次关系。这句话可能不好理解，我们举个例子。比如我们要加载顶层的 Java 类——java.lang.Object 类，无论我们用哪个类加载器去加载 Object 类，这个加载请求最终都会委托给 Bootstrap ClassLoader，这样就保证了所有加载器加载的 Object 类都是同一个类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类的生命周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1929170-3b72184710adf2be.jpg?imageMogr2/auto-orient/strip%7CimageVi
      
    
    </summary>
    
    
      <category term="Java" scheme="https://yazhidev.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从字节码层面理解泛型</title>
    <link href="https://yazhidev.github.io/2019/02/12/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B/"/>
    <id>https://yazhidev.github.io/2019/02/12/从字节码层面理解泛型/</id>
    <published>2019-02-12T13:09:19.000Z</published>
    <updated>2022-06-07T22:58:54.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//编译成 class 文件</span><br><span class="line">javac Test.java </span><br><span class="line"></span><br><span class="line">//反汇编 class 文件</span><br><span class="line">javap -V Test.class</span><br></pre></td></tr></table></figure><p>Android Studio 编译的 class<br>文件位于 <code>build/intermediates/clases/debug/包名</code> 下</p><h2 id="IDEA-插件"><a href="#IDEA-插件" class="headerlink" title="IDEA 插件"></a>IDEA 插件</h2><ul><li><p>jclasslib Bytecode viewer</p></li><li><p>ASM Bytecode Viewer</p></li></ul><p>这两款插件都可以在 Android Studio Plugins 里直接下载安装</p><h2 id="字节码的组成"><a href="#字节码的组成" class="headerlink" title="字节码的组成"></a>字节码的组成</h2><p>方法调用在JVM中转换成的是字节码执行，字节码指令执行的数据结构就是栈帧。</p><p>栈帧的数据结构主要分为四个部分：局部变量表、操作数栈、动态链接以及方法返回地址（包括正常调用和异常调用的完成结果）。</p><h3 id="局部变量表（local-variables）"><a href="#局部变量表（local-variables）" class="headerlink" title="局部变量表（local variables）"></a>局部变量表（local variables）</h3><p>当方法被调用时，参数会传递到从0开始的连续的局部变量表的索引位置上。local variables的最大长度是在编译期间决定的。一个局部变量表的占用了32位的存储空间（一个存储单位称之为slot，槽），所以可以存储一个boolean、byte、char、short、float、int、refrence和returnAdress数据，long和double需要2个连续的局部变量表来保存，通过较小位置的索引来获取。如果被调用的是实例方法，那么第0个位置存储“this”关键字代表当前实例对象的引用。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈同局部变量表一样，也是编译期间就能决定了其存储空间（最大的单位长度）。</p><p>操作数栈是在JVM字节码执行一些指令（第二部分会介绍一些指令集）时创建的，主要是把局部变量表中的变量压入操作数栈，在操作数栈中进行字节码指令的操作，再将变量出操作数栈，结果入操作数栈。</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧指向运行时常量池中该栈帧所属的方法的引用，也就是字节码的发放调用的引用。动态链接就是将符号引用所表示的方法，转换成方法的直接引用。加载阶段或第一次使用时转化为直接引用的（将变量的访问转化为访问这些变量的存储结构所在的运行时内存位置）就叫做静态解析。JVM的动态链接还支持运行期转化为直接引用。也可以叫做Late Binding,晚期绑定。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法正常退出会把返回值压入调用者的栈帧的操作数栈，PC计数器的值就会调整到方法调用指令后面的一条指令。这样使得当前的栈帧能够和调用者连接起来，并且让调用者的栈帧的操作数栈继续往下执行。</p><p>方法的异常调用完成，主要是JVM抛出的异常，如果异常没有被捕获住，或者遇到athrow字节码指令显示抛出，那么就没有返回值给调用者。</p><p>Java 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    private int myNum = 20;</span><br><span class="line"></span><br><span class="line">    public void func() &#123;</span><br><span class="line">        myNum = 50;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的 class 源文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cafe babe 0000 0033 0015 0a00 0400 1109</span><br><span class="line">0003 0012 0700 1307 0014 0100 056d 794e</span><br><span class="line">756d 0100 0149 0100 063c 696e 6974 3e01</span><br><span class="line">0003 2829 5601 0004 436f 6465 0100 0f4c</span><br><span class="line">696e 654e 756d 6265 7254 6162 6c65 0100</span><br><span class="line">124c 6f63 616c 5661 7269 6162 6c65 5461</span><br><span class="line">626c 6501 0004 7468 6973 0100 1a4c 636f</span><br><span class="line">6d2f 7961 7a68 6964 6576 2f64 656d 6f2f</span><br><span class="line">4d79 5465 7374 3b01 0004 6675 6e63 0100</span><br><span class="line">0a53 6f75 7263 6546 696c 6501 000b 4d79</span><br><span class="line">5465 7374 2e6a 6176 610c 0007 0008 0c00</span><br><span class="line">0500 0601 0018 636f 6d2f 7961 7a68 6964</span><br><span class="line">6576 2f64 656d 6f2f 4d79 5465 7374 0100</span><br><span class="line">106a 6176 612f 6c61 6e67 2f4f 626a 6563</span><br><span class="line">7400 2100 0300 0400 0000 0100 0200 0500</span><br><span class="line">0600 0000 0200 0100 0700 0800 0100 0900</span><br><span class="line">0000 3900 0200 0100 0000 0b2a b700 012a</span><br><span class="line">1014 b500 02b1 0000 0002 000a 0000 000a</span><br><span class="line">0002 0000 0007 0004 0008 000b 0000 000c</span><br><span class="line">0001 0000 000b 000c 000d 0000 0001 000e</span><br><span class="line">0008 0001 0009 0000 0035 0002 0001 0000</span><br><span class="line">0007 2a10 32b5 0002 b100 0000 0200 0a00</span><br><span class="line">0000 0a00 0200 0000 0b00 0600 0c00 0b00</span><br><span class="line">0000 0c00 0100 0000 0700 0c00 0d00 0000</span><br><span class="line">0100 0f00 0000 0200 10</span><br></pre></td></tr></table></figure></p><p>javap 反汇编后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/zengyazhi/Documents/zyzdev/AndroidDemo/app/build/intermediates/classes/debug/com/yazhidev/demo/MyTest.class</span><br><span class="line">  Last modified 2018-12-28; size 393 bytes</span><br><span class="line">  MD5 checksum 2872209fbe3efb46c70b23bf85be75fd</span><br><span class="line">  Compiled from &quot;MyTest.java&quot;</span><br><span class="line">public class com.yazhidev.demo.MyTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 51</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#17         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#18         // com/yazhidev/demo/MyTest.myNum:I</span><br><span class="line">   #3 = Class              #19            // com/yazhidev/demo/MyTest</span><br><span class="line">   #4 = Class              #20            // java/lang/Object</span><br><span class="line">   #5 = Utf8               myNum</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/yazhidev/demo/MyTest;</span><br><span class="line">  #14 = Utf8               func</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               MyTest.java</span><br><span class="line">  #17 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #18 = NameAndType        #5:#6          // myNum:I</span><br><span class="line">  #19 = Utf8               com/yazhidev/demo/MyTest</span><br><span class="line">  #20 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.yazhidev.demo.MyTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: bipush        20</span><br><span class="line">         7: putfield      #2                  // Field myNum:I</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">        line 8: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      11     0  this   Lcom/yazhidev/demo/MyTest;</span><br><span class="line"></span><br><span class="line">  public void func();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: bipush        50</span><br><span class="line">         3: putfield      #2                  // Field myNum:I</span><br><span class="line">         6: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">        line 12: 6</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  this   Lcom/yazhidev/demo/MyTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MyTest.java&quot;</span><br></pre></td></tr></table></figure><h2 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h2><p>opcode（指令） = 操作码 + 操作数</p><p>例如 <code>bipush 10</code> 这是一条指令，是由操作码 <code>bipush</code> 后跟一个操作数 <code>10</code> 组成，该指令的作用是将整型数 <code>10</code> 压到操作数栈中。</p><ul><li><p>aload_0（指令码：0x2a）</p><p>  从局部变量数组中加载一个对象引用到操作数栈的栈顶，最后的数字对应的是局部变量数组中的位置，只能是0，1，2，3。（第一个局部变量是this引用）</p></li><li><p>invokespecial（0xb7）</p><p>  只能调用三类方法：<init>方法；私有方法；super.method()。因为这三类方法的调用对象在编译时就可以确定</init></p></li><li><p>invokevirtual（0xb6）</p><p>  是一种动态分派的调用指令</p></li><li><p>bipush（0x10）</p><p>  用来把一个字节作为整型压到操作数栈中</p></li><li><p>putfield（0xb5）</p><p>  后面跟一个操作数（该操作数引用的是运行时常量池里的一个字段，在这里这个字段是 myNum），将栈顶的值赋给这个。赋给这个字段的值，以及包含这个字段的对象引用，在执行这条指令的时候，都会从操作数栈顶上 pop 出来</p></li><li><p>ldc（0x12）</p><p>  常量池中的常量值入栈</p></li><li><p>CHECKCAST（0xc0）</p><p>  类型强转</p></li></ul><p>部分字节码指令集可见：</p><p><a href="http://www.blogjava.net/DLevin/archive/2011/09/13/358497.html" target="_blank" rel="noopener">《Java二进制指令代码解析》</a></p><p><a href="https://segmentfault.com/a/1190000008722128" target="_blank" rel="noopener">《JVM 虚拟机字节码指令表》</a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>回到上面 MyTest 的构造函数里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">4: aload_0</span><br><span class="line">5: bipush        20</span><br><span class="line">7: putfield      #2                  // Field myNum:I</span><br><span class="line">10: return</span><br></pre></td></tr></table></figure><p>ASM Bytecode viewer 显示的字节码为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// class version 51.0 (51)</span><br><span class="line">// access flags 0x21</span><br><span class="line">public class com/yazhidev/demo/MyTest &#123;</span><br><span class="line"></span><br><span class="line">  // compiled from: MyTest.java</span><br><span class="line"></span><br><span class="line">  // access flags 0x2</span><br><span class="line">  private I myNum</span><br><span class="line"></span><br><span class="line">  // access flags 0x1</span><br><span class="line">  public &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 7 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER 8 L1</span><br><span class="line">    ALOAD 0</span><br><span class="line">    BIPUSH 20</span><br><span class="line">    PUTFIELD com/yazhidev/demo/MyTest.myNum : I</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/MyTest; L0 L2 0</span><br><span class="line">    MAXSTACK = 2</span><br><span class="line">    MAXLOCALS = 1</span><br><span class="line"></span><br><span class="line">  // access flags 0x1</span><br><span class="line">  public func()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 11 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    BIPUSH 50</span><br><span class="line">    PUTFIELD com/yazhidev/demo/MyTest.myNum : I</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER 12 L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/MyTest; L0 L2 0</span><br><span class="line">    MAXSTACK = 2</span><br><span class="line">    MAXLOCALS = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="从字节码看泛型"><a href="#从字节码看泛型" class="headerlink" title="从字节码看泛型"></a>从字节码看泛型</h2><p>Java 的泛型是完全在编译器中实现的，由编译器执行类型检查和类型推断，然后生成普通的非泛型的字节码，虚拟机完全不感知泛型的存在。编译器使用泛型类型信息保证类型安全，然后在生成字节码之前将其清除。</p><p>Java 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Generic&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从生成的字节码中可以看到，泛型 T 已经被擦除了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Ljava/lang/Object; data</span><br><span class="line"></span><br><span class="line">public getData()Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">public setData(Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><h3 id="类型擦除与多态冲突的问题"><a href="#类型擦除与多态冲突的问题" class="headerlink" title="类型擦除与多态冲突的问题"></a>类型擦除与多态冲突的问题</h3><p>子类 B，指定了泛型类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class B extends Generic&lt;Number&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Number n;</span><br><span class="line"></span><br><span class="line">    public Number get() &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(Number n) &#123;</span><br><span class="line">        this.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类 C，未指定泛型类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class C extends Generic &#123;</span><br><span class="line"></span><br><span class="line">    private Number n;</span><br><span class="line"></span><br><span class="line">    public Number get() &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(Number n) &#123;</span><br><span class="line">        this.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在写 B 类时，指定了泛型类型为 <code>Number</code>，对于 B 类的方法 <code>get()Number</code> 和 <code>set(Number)</code>，我们的本意应该是对父类的 <code>get()T</code> 和 <code>set(T)</code> 方法进行重写。但上面我们知道了，父类的 <code>get()T</code> 和 <code>set(T)</code> 在字节码中实际上是 <code>get()Object</code> 和 <code>set(Object)</code>，与类 B 的方法 <code>set(Number)</code> 方法参数不一样，理论上应该算重载而不是重写。为了解决这一冲突，JVM 采用了一种特殊的方法：桥接。</p><p>我们先看 B 类的字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public get()Ljava/lang/Number;</span><br><span class="line">public set(Ljava/lang/Number;)V</span><br><span class="line"></span><br><span class="line">// access flags 0x1041</span><br><span class="line">public synthetic bridge set(Ljava/lang/Object;)V</span><br><span class="line">    L0</span><br><span class="line">    LINENUMBER 7 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    ALOAD 1</span><br><span class="line">    CHECKCAST java/lang/Number</span><br><span class="line">    INVOKEVIRTUAL com/yazhidev/demo/B.set (Ljava/lang/Number;)V</span><br><span class="line">    RETURN</span><br><span class="line">    L1</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/B; L0 L1 0</span><br><span class="line">    MAXSTACK = 2</span><br><span class="line">    MAXLOCALS = 2</span><br><span class="line"></span><br><span class="line">// access flags 0x1041</span><br><span class="line">public synthetic bridge get()Ljava/lang/Object;</span><br><span class="line">    L0</span><br><span class="line">    LINENUMBER 7 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    INVOKEVIRTUAL com/yazhidev/demo/B.get ()Ljava/lang/Number;</span><br><span class="line">    ARETURN</span><br><span class="line">    L1</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/B; L0 L1 0</span><br><span class="line">    MAXSTACK = 1</span><br><span class="line">    MAXLOCALS = 1</span><br></pre></td></tr></table></figure><p>可以发现编译器自动生成了 <code>set(Object)</code> 和 <code>get()Object</code> 两个桥接方法来重写父类方法，同时这两个桥接方法实际上调用了对应的 <code>set(Number)</code> 方法和 <code>get()Number</code> 方法。虚拟机通过使用桥接方法，来解决了类型擦除和多态的冲突。对于开发者来说，对于指定了泛型类型为 <code>Number</code> 的 B 类来说，其 <code>set(Number)</code> 方法就是对父类方法 <code>set(T)</code> 的重写，同理 <code>get()Number</code> 也是对父类方法 <code>get()T</code> 的重写。</p><p>但 C 类则有些不同，C 类未指定泛型类型，所以父类中的方法为 <code>get()Object</code> 和 <code>set(Object)</code>，C 类中的 <code>set(Number)</code> 与父类 <code>set(Object)</code> 方法参数不同，理所当然是重载，我们都知道，只有返回值不同不满足重载条件，所以对 C 类的 <code>get()Number</code> 方法来说，应该算是对父类方法 <code>get()T</code> 的重写。</p><p>我们来看 C 类的字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public get()Ljava/lang/String;</span><br><span class="line">public set(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">// access flags 0x1041</span><br><span class="line">public synthetic bridge get()Ljava/lang/Object;</span><br><span class="line">    L0</span><br><span class="line">    LINENUMBER 7 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    INVOKEVIRTUAL com/yazhidev/demo/C.get ()Ljava/lang/String;</span><br><span class="line">    ARETURN</span><br><span class="line">    L1</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/C; L0 L1 0</span><br><span class="line">    MAXSTACK = 1</span><br><span class="line">    MAXLOCALS = 1</span><br></pre></td></tr></table></figure><p>可以发现编译期自动生成了 <code>get()Object</code>  桥接方法来重写父类方法。但我们发现字节码里却同时存在了两个只有返回值类型不同的同名方法，这是为什么呢？</p><p>这里就需要提到方法特征签名，只有特征签名不同的方法才可以共存。</p><ul><li><p>Java 层方法签名 = 方法名 + 参数类型 + 参数顺序</p><p>  所以在 Java 语言里，重载一个方法需要两个同名方法的参数类型不同，或者参数顺序不同，只有返回值类型不同是无法通过编译的。</p></li><li><p>JVM 层方法签名 = 方法名 + 参数类型 + 参数顺序 + 返回值类型 + 可能抛出的异常</p><p>  所以在 class 文件里，是可以存在两个只有返回值类型不同的同名方法。也就是上面的 <code>get()Object</code> 和 <code>get()Number</code></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jianleixing.iteye.com/blog/2017732" target="_blank" rel="noopener">《描述符与特征签名的区别》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;命令行&quot;&gt;&lt;a href=&quot;#命令行&quot; class=&quot;headerlink&quot; title=&quot;命令行&quot;&gt;&lt;/a&gt;命令行&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="Java" scheme="https://yazhidev.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《C++ 程序设计》读书笔记</title>
    <link href="https://yazhidev.github.io/2018/12/16/%E3%80%8AC-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://yazhidev.github.io/2018/12/16/《C-程序设计》读书笔记/</id>
    <published>2018-12-16T02:20:38.000Z</published>
    <updated>2022-06-07T22:58:54.441Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文联合编辑：小辣辣。向她致以最崇高的敬（爱）意 ❤</p></blockquote><hr><h2 id="第一章-C-的初步认识"><a href="#第一章-C-的初步认识" class="headerlink" title="第一章 C++的初步认识"></a>第一章 C++的初步认识</h2><p>在程序进行编译时，先对所有的预处理命令进行处理，将头文件的具体内容代替 <code>#include</code> 指令，然后再对该程序单元进行整体编译。</p><p>对函数做声明，它的作用是通知 C++ 编译系统。</p><h2 id="第二章-数据的存储、表示形式和基本运算"><a href="#第二章-数据的存储、表示形式和基本运算" class="headerlink" title="第二章 数据的存储、表示形式和基本运算"></a>第二章 数据的存储、表示形式和基本运算</h2><p>C++ 没有规定每一种数据所占的字节数，只规定 int 型数据所占的字节数不大于 long 型，不小于 short 型。</p><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PRICE 30</span><br></pre></td></tr></table></figure><p>符号常量虽有名字，但它不是变量。在进行编译预处理时，所有的 PRICE 都被置换为字符 30，在正式进行编译时已经没有 PRICE 这个标识符了。但 C++ 程序员一般更喜欢用 const 定义常变量。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p><code>/</code> 除法运算符<br>结果是整数，如果有一个是负数，则舍入方向是不固定的。多数编译系统采取向零取整的方法</p></li><li><p><code>%</code> 模运算符<br>两侧均应为整型数据，如 7%4 的值为 3</p></li></ul><p>+，–，*，/ 运算中的两个数中有一个数为 float 型数据，则运算结果是 double 型，因为 C++ 在运算时对所有 float 型数据都按 double 型数据处理。</p><p>进行运算时，不同类型的数据都要先转换成同一类型，然后进行运算。</p><h3 id="自增（减）运算符"><a href="#自增（减）运算符" class="headerlink" title="自增（减）运算符"></a>自增（减）运算符</h3><p>也用于指针变量，使指针指向下一个地址。</p><h3 id="赋值运算符和赋值表达式"><a href="#赋值运算符和赋值表达式" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h3><h4 id="赋值过程中的类型转换"><a href="#赋值过程中的类型转换" class="headerlink" title="赋值过程中的类型转换"></a>赋值过程中的类型转换</h4><p>将浮点型数据赋值给整型变量时，舍弃其小数部分。</p><p>不同类型的整型数据间的赋值归根到底就是一条：按存储单元中的存储形式直接传送。</p><h2 id="程序初步设计"><a href="#程序初步设计" class="headerlink" title="程序初步设计"></a>程序初步设计</h2><h3 id="关系运算和逻辑运算"><a href="#关系运算和逻辑运算" class="headerlink" title="关系运算和逻辑运算"></a>关系运算和逻辑运算</h3><p>运算符优先级：</p><p>算数运算符 ＞ 关系运算符 ＞赋值运算符</p><p>在 C 和 C++ 中都用数据 1 代表真，0 代表假。编译系统在处理逻辑型数据时，将 false 处理为 0，将 true 处理为 0。逻辑变量在内存中占 1 个字节，用来存放 0 或 1。</p><h3 id="用-for-语句构成循环"><a href="#用-for-语句构成循环" class="headerlink" title="用 for 语句构成循环"></a>用 for 语句构成循环</h3><p>for（表达式1；表达式2；表达式3）语句</p><p>表达式 1 可以省略，但其后得分号不可省略。</p><p>如果表达式 2 省略，即不判断循环条件，循环无休止地进行下去。</p><h2 id="第四章-利用函数实现指定的功能"><a href="#第四章-利用函数实现指定的功能" class="headerlink" title="第四章 利用函数实现指定的功能"></a>第四章 利用函数实现指定的功能</h2><h3 id="函数参数和函数的值"><a href="#函数参数和函数的值" class="headerlink" title="函数参数和函数的值"></a>函数参数和函数的值</h3><p>在调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放，实参单元仍保留并维持原值。因此，在执行一个被调用函数时，形参的值如果发生改变，并不会改变主调用函数中实参的值。</p><h3 id="对被调用函数的声明和函数原型"><a href="#对被调用函数的声明和函数原型" class="headerlink" title="对被调用函数的声明和函数原型"></a>对被调用函数的声明和函数原型</h3><p>在函数声明中可以不写形参名，只写形参类型</p><h3 id="内置函数（内联函数）"><a href="#内置函数（内联函数）" class="headerlink" title="内置函数（内联函数）"></a>内置函数（内联函数）</h3><p>转去被调用函数前，要记下当时执行的指令的地址，还要记下当时有关的信息，以便在函数调用后继续执行，如果有的函数需要频繁使用，则所用时间会很长，从而降低执行效率。可以使用内置函数将所调用的函数的代码直接嵌入到主调函数中，而不是将流程转出去。使用关键字 inline。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt; typename T &gt; //类似 Java 的泛型</span><br></pre></td></tr></table></figure><h3 id="有默认参数的函数"><a href="#有默认参数的函数" class="headerlink" title="有默认参数的函数"></a>有默认参数的函数</h3><p>注意点：如果函数的定义在函数调用之前，则应在函数定义中给出默认值。如果函数的定义在函数调用之后，则在函数调用之前需要有函数声明，此时必须许多函数声明中给出默认值，函数定义时可以不给出默认值。</p><h3 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h3><ul><li><p>auto（默认）</p><p>  自动变量，动态局部变量，函数调用结束后释放</p></li><li><p>static</p><p>  静态局部变量在静态存储区内分配存储单元，在程序整个运行期间都不释放。<br>  加上 static 声明，则该变量只能用于本文件</p></li><li><p>register</p><p>  寄存器变量，如果有一些变量使用频繁，则为存取变量的值要花不少时间，为提高效率，C++ 允许将局部变量的值放在 cpu 的寄存器中</p></li><li><p>extern</p><p>  全局变量（外部变量），作用域从变量的定义开始，到本程序文件的末尾<br>  注意 extern 是用作变量声明，而不是变量定义。它只是对一个已定义的外部变量做声明，以扩展其作用域。</p></li></ul><h3 id="内部函数和外部函数"><a href="#内部函数和外部函数" class="headerlink" title="内部函数和外部函数"></a>内部函数和外部函数</h3><h4 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h4><p>如果在函数的首部的最左端冠以关键字 <code>extern</code>，则表示此函数是外部函数，可供其他文件调用。</p><h2 id="第五章-利用数组处理批量数据"><a href="#第五章-利用数组处理批量数据" class="headerlink" title="第五章 利用数组处理批量数据"></a>第五章 利用数组处理批量数据</h2><h3 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h3><ul><li>可以只给一部分元素赋值（后面的元素默认为 0）</li><li>对全部数组元素赋初值时，可以不指定数组长度</li></ul><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><ul><li>可以对部分元素赋值</li></ul><h3 id="用数组作函数参数"><a href="#用数组作函数参数" class="headerlink" title="用数组作函数参数"></a>用数组作函数参数</h3><p>数组名作实参和形参，传递的是数组的起始地址。</p><p>数组名代表数组首元素的地址。</p><p>用数组名作实参，如果改变了形参数组元素的值将同时改变实参数组元素的值。</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><h4 id="定义和初始化字符数组"><a href="#定义和初始化字符数组" class="headerlink" title="定义和初始化字符数组"></a>定义和初始化字符数组</h4><p>如果提供的初值个数大于数组长度，则按语法错误处理。如果小于数组长度，则只将字符赋值给数组中前面的元素，其余的元素自动定义为空字符 <code>\0</code></p><h4 id="字符数组的赋值和引用"><a href="#字符数组的赋值和引用" class="headerlink" title="字符数组的赋值和引用"></a>字符数组的赋值和引用</h4><p>只能对字符数组的元素赋值，而不能用赋值语句对整个数组赋值。</p><h4 id="结束标志"><a href="#结束标志" class="headerlink" title="结束标志"></a>结束标志</h4><p>遇到字符 <code>\0</code> 就表示字符串到此结束。对于一个字符串常量，系统会自动在所在字符的后面加一个 <code>\0</code> 作为结束符，然后再把它存在字符数组中。</p><p>可以用字符串常量来初始化字符数组。</p><h4 id="字符数组的输入和输出"><a href="#字符数组的输入和输出" class="headerlink" title="字符数组的输入和输出"></a>字符数组的输入和输出</h4><ul><li>输出得字符不包含结束符 <code>\0</code></li></ul><h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>比较函数 strcmp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcmp（str1，str2）</span><br></pre></td></tr></table></figure><p>对两个字符串自左至右逐个字符相比(按 ASCII 值大小比较)</p><p>两个字符串比较，不能用以下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(str1 ＞ str2) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面写法表示将两个数组的地址进行比较。</p><h4 id="字符串变量的定义和引用"><a href="#字符串变量的定义和引用" class="headerlink" title="字符串变量的定义和引用"></a>字符串变量的定义和引用</h4><p>和其他类型变量一样，字符串变量必须先定义后使用。</p><h2 id="第六章-善于使用指针和引用"><a href="#第六章-善于使用指针和引用" class="headerlink" title="第六章 善于使用指针和引用"></a>第六章 善于使用指针和引用</h2><p><code>i_pointer</code> 是一个指针变量，<code>* i_pointer</code> 表示 i_pointer 所指向的变量。<br><code>*</code> 不是指针变量名的一部分，在变量名前加一个 <code>*</code> 表示该变量是指针变量。</p><p>不能用一个整数给指针变量赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * pointer = 2000;</span><br></pre></td></tr></table></figure><p>编译系统并不把 2000 认为是地址，而认为是整数。可以将一个已定义的变量的地址作为指针变量的初值。</p><p>一个指针只能指向同一个类型的变量。</p><h3 id="引用指针变量"><a href="#引用指针变量" class="headerlink" title="引用指针变量"></a>引用指针变量</h3><p><code>&amp;</code> ： 取地址运算符</p><p><code>&amp;a</code> 为变量 a 的地址， <code>*p</code> 为指针变量 p 所指向的存储单元</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * pointer = &amp; a //定义指针变量</span><br></pre></td></tr></table></figure><p>pointer：指针变量</p><p><code>* pointer</code> 等效于 a（对指针变量 pointer 做 <code>*</code> 运算，指向 pointer 指向的存储单元，即 a）</p><p><code>&amp;</code> 和 <code>*</code> 两个运算符的优先级别相同，但按自右而左方向结合。例如已知 <code>pointer = &amp;a</code>，<code>&amp; * pointer</code>的含义是：先进行 <code>*pointer</code> 的运算，它就是变量 a，再执行 <code>&amp;</code> 运算，因此 <code>&amp; * pointer</code> 与 <code>&amp; a</code> 相同，即变量 a 的地址。</p><h3 id="用指针作函数参数"><a href="#用指针作函数参数" class="headerlink" title="用指针作函数参数"></a>用指针作函数参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    void swap(int * p1, int * p2)</span><br><span class="line">    int * pointer_1, * pointer_2, a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    pointer_1 = &amp;a;</span><br><span class="line">    pointer_2 = &amp;b;</span><br><span class="line">    swap(pointer_1, pointer_2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int * p1, int * p2) &#123; //定义指针变量 p1, p2，即 swap 的形参须是指针</span><br><span class="line">    int temp;</span><br><span class="line">    temp = * p1; // * p1：对指针变量做 * 运算，指向值</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能试图通过改变形参指针变量的值而使实参指针变量的值改变。实参和形参之间的数据传递是单向的“值传递”的方式，指针变量作函数参数也要遵循这一规则，调用函数时不会改变实参指针变量的值，但可以改变实参指针变量指向变量的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) </span><br><span class="line">&#123;</span><br><span class="line">    void myswap(int * p1, int * p2);</span><br><span class="line">    int * point1, * point2, a, b;</span><br><span class="line">    a = 10, b = 20;</span><br><span class="line">    point1 = &amp;a;</span><br><span class="line">    point2 = &amp;b;</span><br><span class="line">    cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    if(a &lt; b) myswap(point1, point2);</span><br><span class="line">    cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    if(a &lt; b) realswap(point1, point2);</span><br><span class="line">    cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指针变量也是值传递，形参修改并不影响实参 point1 指针</span><br><span class="line">void myswap(int * p1, int * p2) &#123;</span><br><span class="line">    int * temp;</span><br><span class="line">    temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void realswap(int * p1, int * p2) &#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = * p1;</span><br><span class="line">    * p1 = * p2; //* p1，直接修改 p1 指向的值（a）的值</span><br><span class="line">    * p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出 </span><br><span class="line">a10b20</span><br><span class="line">a10b20</span><br><span class="line">a20b10</span><br><span class="line"></span><br><span class="line">//分析</span><br><span class="line">point1 = &amp; a</span><br><span class="line">* point1 即 point1 所指向的变量</span><br></pre></td></tr></table></figure><h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><h4 id="指向数组元素的指针"><a href="#指向数组元素的指针" class="headerlink" title="指向数组元素的指针"></a>指向数组元素的指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[10]; //定义一个数组，有 10 个元素</span><br><span class="line">int *p;</span><br><span class="line">p = &amp;a[0] //将元素 a[0] 的地址赋给指针变量 p，使 p 指向 a[0]</span><br></pre></td></tr></table></figure><p>在 C++ 中，数组名代表数组中的第 1 个元素（即序号为 0 的元素）的<strong>地址</strong>，因此以下语句等价：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[0];</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure><p>数组名 a 不代表整个数组，<code>p=a</code> 的作用是把 a 数组的首元素的地址赋给指针变量 p。</p><p>如果指针变量 p 已指向数组中的一个元素，则 p + 1 指向同一个数组中的下一个元素。</p><p>如果 p 的初值为 &amp;a[0]，那么 <code>p + i</code> 和 <code>a + i</code> 就是 a[i] 的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(p+5)</span><br><span class="line">*(a+5)</span><br><span class="line">a[5]</span><br></pre></td></tr></table></figure><p>这三种表示方法等价。</p><p>可以看出，数组名后面的括号 []，实际上是变址运算符，指向数组元素的指针变量也可以带下标，如 <code>p[i]</code> 与 <code>*(p+i)</code> 等价。</p><p>效率比较：</p><ol><li><p>下标法：a[i]</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针法：*(a + i)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*(a + i)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用指针变量指向数组元素</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int i;</span><br><span class="line">for(p = a; p &lt; (a + 10); p++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>1 和 2 的执行效率相同，C++ 编译系统是将 a[i] 转换为 *(a + 1) 处理的，对每个 a[i] 都分别计算地址 a + i x d，然后访问该元素。3 比 1 和 2 快，用指针变量直接指向元素，不必每次都重新计算地址。</p><p>在使用指针变量指向数组元素是，应切实保证指向数组中有效的元素。</p><p>C++ 编译系统将形参数组名一律作为指针变量来处理。</p><h3 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a>函数与指针</h3><p>只须将函数名 max 赋给 p，不能写成 p ＝ max(a,b)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * a(int x, int y);</span><br></pre></td></tr></table></figure><p>a 是函数名，调用它以后m能得到一个指向整型数据的指针（地址）。</p><h3 id="指针数组和指向指针的指针"><a href="#指针数组和指向指针的指针" class="headerlink" title="指针数组和指向指针的指针"></a>指针数组和指向指针的指针</h3><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * p[4]</span><br></pre></td></tr></table></figure><p>由于 [] 比 * 优先级高，因此 p 先与 [4] 结合，形成 p[4] 形式，这显然是数组形式。不要写成 int 这是指向一维数组的指针变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* (name + i ++)</span><br></pre></td></tr></table></figure><p>表示先求 * 的值，即 name 它是一个地址。将它赋给 p，然后 i 加 1，最后输出以 p 地址开始的字符串。</p><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>由于 name[i] 的值是地址(即指针)，因此 name + i 就是指向指针型数据的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 指针变量（比如变量 a 的地址）</span><br><span class="line">char * p </span><br><span class="line"></span><br><span class="line">// 存储 a 的地址的指针的地址</span><br><span class="line">char *(* p) </span><br><span class="line"></span><br><span class="line">* p = &apos;C++&apos;</span><br><span class="line">** p 指向 ‘C++’ 的第一个字符元素的内容</span><br></pre></td></tr></table></figure><h3 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h3><p>用指向常量的指针变量只是限制了通过指针变量改变它指向的对象的值。</p><ul><li><p>const 类型名 * p （指向常量的指针变量）</p><p>  p 的指向可变，但 p 指向的对象的值不可变。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 12;</span><br><span class="line">int b = 15;</span><br><span class="line">const int * p = &amp; a;</span><br><span class="line"></span><br><span class="line">p = &amp;b; //合法，p 的指向可变</span><br><span class="line">* p = 20; //非法，p 指向的对象的值不可变</span><br><span class="line">a = 15; //合法，a 不是 const 常量</span><br></pre></td></tr></table></figure></li></ul><pre><code>如果想绝对保证 a 的值始终不变，应当把 a 定义为常变量。</code></pre><ul><li><p>int * const p （常指针变量）</p><p>  指针变量的指向不可变，但指向变量的值可变</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 12;</span><br><span class="line">int b = 15;</span><br><span class="line">int * const p = &amp; a;</span><br><span class="line"></span><br><span class="line">p = &amp;b; //非法，p 的指向不可变</span><br><span class="line">* p = 20; //合法，p 指向变量的值可变</span><br></pre></td></tr></table></figure></li><li><p>const int a</p><p>  a 的值不可变</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int a = 12;</span><br><span class="line"></span><br><span class="line">a = 20; //非法</span><br></pre></td></tr></table></figure></li></ul><h3 id="void-指针类型"><a href="#void-指针类型" class="headerlink" title="void 指针类型"></a>void 指针类型</h3><p>该空间尚未使用，其中没有数据，谈不上指向什么类型的数据，故返回一个 <code>void *</code> 类型的指针，表示它不指向确定的具有类型的数据。</p><h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>指针变量可以有空值，即该指针变量不指向任何变量，它可以这样表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// iostream 头文件中已定义了符号常量 NULL 代表整数 0</span><br><span class="line">p = NULL;</span><br></pre></td></tr></table></figure><p>如果两个指针不指向同一个数组，则比较是无意义的。如果一定要对不同类型的指针变量赋值，可以用到强制类型转换。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在数据类型名后面出现的 &amp; 是引用声明符号，在其他场合出现的都是地址符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char &amp;d = c; // 引用的声明符</span><br><span class="line">int * p = &amp; a; //地址符</span><br></pre></td></tr></table></figure><p>在声明一个引用后，不能再使之作为另一变量的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1, a2;</span><br><span class="line">int &amp;b = a1;</span><br><span class="line">int &amp;b = a2; //非法</span><br></pre></td></tr></table></figure><p>引用其实就是一个指针常量，它的指向不可改变。</p><h3 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h3><p>传递变量的地址：形参是指针变量，实参是一个变量的地址。调用函数时，形参（指针变量）得到实参变量的地址，因此指向实参变量单元。</p><p>实参不是地址而是整型变量名，由于形参是引用，系统会自动将实参的地址传递给形参，注意：此时传送的是实参变量的地址而不是实参变量的值。实参是地址，传递的是地址，故仍然是值传递。方式（3）中实参是变量名，而传递的是变量的地址，这才是传址方式。</p><h2 id="第七章-用户自定义数据类型"><a href="#第七章-用户自定义数据类型" class="headerlink" title="第七章 用户自定义数据类型"></a>第七章 用户自定义数据类型</h2><h3 id="引用结构体变量"><a href="#引用结构体变量" class="headerlink" title="引用结构体变量"></a>引用结构体变量</h3><p><code>.</code> 是成员运算符，它在所有运算符中优先级最高，因此可以把 <code>student.num</code> 作为一个整体来看待。</p><h3 id="指向结构体变量的指针"><a href="#指向结构体变量的指针" class="headerlink" title="指向结构体变量的指针"></a>指向结构体变量的指针</h3><p>C 和 C++ 提供了指向结构体变量的运算符 <code>-&gt;</code>,形象的表示“指向”关系。例如，<code>p-&gt;num</code> 表示指针 p 当前指向的结构体变量中的成员 num。</p><p><code>p-&gt;n++</code> 得到p指向的结构体变量中的成 员 n的值，用完该值后使它加 1。</p><p><code>++p-&gt;n</code> 得到 p 指向的结构体变量中的成员 n 的值，并使之加 1，然后再使用它。</p><h4 id="用结构体变量和指向结构体变量的指针构成链表"><a href="#用结构体变量和指向结构体变量的指针构成链表" class="headerlink" title="用结构体变量和指向结构体变量的指针构成链表"></a>用结构体变量和指向结构体变量的指针构成链表</h4><p>用结构体变量和指向结构体变量的指针构成链表，最有一个元素不再指向其他元素，它成为“表尾”，它的地址部分放到一个“NULL”（表示“空地址”），链表到此结束。</p><p>所有节点（结构体变量）都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表成为静态链表。</p><p>动态链表则是指个结点是可以随时插入和删除的，这些节点并没有变量名，只能先找到一个结点上，才能根据它提供的下一个结点的地址找到下一个结点。</p><h3 id="结构体类型数据最为函数参数"><a href="#结构体类型数据最为函数参数" class="headerlink" title="结构体类型数据最为函数参数"></a>结构体类型数据最为函数参数</h3><p>调用函数时形参要单独开辟内存单元，如果结构体变量占的存储空间很大，则在虚实结合时控件和时间的开销都比较大，效率是不高的。</p><h3 id="用-new-和-delete-运算符进行动态分配和撤销存储空间"><a href="#用-new-和-delete-运算符进行动态分配和撤销存储空间" class="headerlink" title="用 new 和 delete 运算符进行动态分配和撤销存储空间"></a>用 new 和 delete 运算符进行动态分配和撤销存储空间</h3><p>new 运算符使用的一般格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new 类型 [初值]</span><br></pre></td></tr></table></figure><p>注意：用 new 分配数组空间时不能指定初始值</p><p>delete 运算符使用的一般格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete 指针变量</span><br><span class="line">或</span><br><span class="line">delete [] 指针变量</span><br></pre></td></tr></table></figure><p>在指针变量前面加一对方括号，表示是对数组空间的操作。</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举元素按常量处理，故称枚举常量，它们不是常量，不能对它们赋值，即枚举元素的值是固定的。</p><h2 id="第八章-类和对象的特性"><a href="#第八章-类和对象的特性" class="headerlink" title="第八章 类和对象的特性"></a>第八章 类和对象的特性</h2><h3 id="声明类类型"><a href="#声明类类型" class="headerlink" title="声明类类型"></a>声明类类型</h3><p>如果在类的定义中既不指定 private，也不指定 public，则系统就默认为是私有的。</p><p>除了 private 和 public之外，还有一种成员访问限定符 protect（受保护的），用protect声明的成员不能被类外访问（这点与私有成员类似），但可以被派生类的成员函数访问。</p><h3 id="成员函数的性质"><a href="#成员函数的性质" class="headerlink" title="成员函数的性质"></a>成员函数的性质</h3><p><code>::</code> 是作用域限定符（field qualifier）或称作用域运算符，用它声明函数是属于哪个子类的。</p><p>函数名前既无类名又无作用域运算符，表示函数不属于任何类，这个函数不是成员函数，而是全局函数。</p><h3 id="内置成员函数"><a href="#内置成员函数" class="headerlink" title="内置成员函数"></a>内置成员函数</h3><p>在类体中定义的成员函数的规模一般都很小，而系统调用函数的过程所花费的时间开销相对是比较大的，为减少时间的开销，如果在类体中定义的成员函数中不包括循环等控制结构，C++ 系统就自动把它们作为内置（inline）函数来处理。</p><h3 id="成员函数的存储方式"><a href="#成员函数的存储方式" class="headerlink" title="成员函数的存储方式"></a>成员函数的存储方式</h3><p>每个对象所占用的存储空间只是该对象的数据成员所占的存储空间，而不包括函数代码所占用的存储空间。</p><h2 id="第九章-怎样使用类和对象"><a href="#第九章-怎样使用类和对象" class="headerlink" title="第九章 怎样使用类和对象"></a>第九章 怎样使用类和对象</h2><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>不能在类生命中对数据成员初始化，因为类并不是一个实体，而是一种抽象类型，并不占存储空间，显然误触容纳数据。</p><h3 id="用构造函数实现数据成员的初始化"><a href="#用构造函数实现数据成员的初始化" class="headerlink" title="用构造函数实现数据成员的初始化"></a>用构造函数实现数据成员的初始化</h3><p>在类外定义构造成员函数，要加上类名和域限定符。</p><p>在建立对象时系统为该对象分配存储单元，此时执行构造函数。</p><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><p>无参构造函数应注意正确书写定义对象的语句</p><p>请记住：构造函数是不能被用户显式调用的</p><h3 id="使用默认参数的构造函数"><a href="#使用默认参数的构造函数" class="headerlink" title="使用默认参数的构造函数"></a>使用默认参数的构造函数</h3><p>由于不需要实参也可以调用构造函数，因此全部参数都指定了一个默认值的构造函数也属于默认的构造函数。</p><p>编译系统无法识别应该调用那个构造函数，出现歧义性</p><p>在一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>如果用户没有定义析构函数，C++ 编译系统会自动生成一个析构函数，但它只是徒有析构函数的名称和形式，实际上什么操作都不进行。</p><h3 id="调用构造函数和析构函数的顺序"><a href="#调用构造函数和析构函数的顺序" class="headerlink" title="调用构造函数和析构函数的顺序"></a>调用构造函数和析构函数的顺序</h3><p>先构造的后析构，后构造的先析构。相当于一个栈，先进后出。</p><h3 id="指向对象成员的指针"><a href="#指向对象成员的指针" class="headerlink" title="指向对象成员的指针"></a>指向对象成员的指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time * pt; //定义 pt 是指向 Time 类对象的指针变量</span><br><span class="line">Time tl; //定义 tl 为 Time 类对象</span><br><span class="line">pt = &amp; tl; //将 tl 的起始地址赋给 pt</span><br><span class="line"></span><br><span class="line">* pt; //pt 所指向的对象，即 tl；</span><br><span class="line">//以下表示是等价的</span><br><span class="line">(* pt).hour; </span><br><span class="line">pt -&gt; hour;</span><br></pre></td></tr></table></figure><p>指针变量的类型必须与赋值号右侧函数的类型相匹配，要求在以下3方面都要匹配：1.函数参数的类型和参数个数；2、函数返回值类型；3.所属的类</p><p>定义指向公用成员函数的指针变量的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据类型名 （类名 :: * 指针变量名）（参数列表）;</span><br><span class="line"></span><br><span class="line">//形如：</span><br><span class="line">void(Time:: *p2)()</span><br></pre></td></tr></table></figure><p>使指针变量指向一个公用成员函数的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指针变量名 = &amp; 类名 :: 成员函数名</span><br><span class="line">//形如</span><br><span class="line">p2 = &amp;Time::get_time;</span><br></pre></td></tr></table></figure><h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><p>常对象必须有初值，在常对象的生命周期中，对象中的所有数据成员的值都不能被修改</p><p>定义常对象的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 const 对象名[(实参表)]；</span><br></pre></td></tr></table></figure><p>也可以把const写在最左边：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const 类名 对象名[(实参表)]；</span><br></pre></td></tr></table></figure><p>与上面的格式是等价的。</p><p>在定义常对象时，必须同时对之初始化，之后不能再改变。</p><h3 id="常对象成员"><a href="#常对象成员" class="headerlink" title="常对象成员"></a>常对象成员</h3><ul><li><p>常成员函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意const的位置在函数名和括号之后</span><br><span class="line">viod get_time() const;</span><br></pre></td></tr></table></figure></li></ul><h3 id="指向对象的常指针"><a href="#指向对象的常指针" class="headerlink" title="指向对象的常指针"></a>指向对象的常指针</h3><p>指向对象的常指针变量的值不能改变，即始终指向同一个对象，但可以改变其所指向的对象的值。</p><p>往往常指针作为函数的形参，目的是不允许在函数执行过程中改变指针变量的值，使其始终指向原来的对象。</p><h3 id="指向常对象的指针变量"><a href="#指向常对象的指针变量" class="headerlink" title="指向常对象的指针变量"></a>指向常对象的指针变量</h3><p>一个对象已经被声明为常变量，只能用指向常变量的指针变量指向它。</p><p>指向常变量的指针变量除了可以指向常变量，还可以指向未被声明为const的变量。此时不能通过此指针变量来改变该变量的值。</p><p>指向常对象的指针最常用于函数的形参，目的是在白虎形参指针所指向的对象，使它在函数执行过程中不被修改。</p><p>以下是非法的：</p><ul><li>形参：指向非 const 型变量的指针；实参 const 变量的地址； </li></ul><p>因为参数传递本质是值传递/地址传递。过程：形参指向实参。因为非 const 型变量指针只能指向非 const 型变量。所以以上是非法的。</p><p>在函数调用时将建立一个新的对象，它是实参对象的拷贝</p><h3 id="对象的动态建立和释放"><a href="#对象的动态建立和释放" class="headerlink" title="对象的动态建立和释放"></a>对象的动态建立和释放</h3><p>用new运算符动态地分配内存后，将返回一个指向新对象的指针。</p><h3 id="对象的赋值"><a href="#对象的赋值" class="headerlink" title="对象的赋值"></a>对象的赋值</h3><p>对象的赋值只对其中数据成员赋值，而不对成员函数赋值。</p><p>不同对象的成员函数时同一个函数代码段，不需要，也无法对它赋值。</p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态数据成员可初始化，但只能在类体外进行初始化。</p><p>公用静态数据成员与全局变量不同，静态数据成员的作用域只限于定义该类的作用域内（如果是在一个函数中定义类，那么其中静态数据成员的作用域就是在此函数内）</p><h3 id="静态数据成员函数"><a href="#静态数据成员函数" class="headerlink" title="静态数据成员函数"></a>静态数据成员函数</h3><p>非静态成员函数有 this 指针，而静态成员函数没有this指针。由此决定了静态成员函数不能访问本类中的非静态成员。</p><p>在 C++ 程序中最好养成这样的习惯：只用静态成员函数引用静态数据成员，而不引用非静态数据成员。</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>在类外定义的且未用类最限定的函数，是非成员函数，不属于任何类。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><ol><li>友元的关系是单向的而不是双向的。</li><li>友元的关系不能传递。</li></ol><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模板名 &lt;实际类型名&gt; 对象名（参数表);</span><br></pre></td></tr></table></figure><h2 id="第十章-运算符重载"><a href="#第十章-运算符重载" class="headerlink" title="第十章 运算符重载"></a>第十章 运算符重载</h2><h3 id="重载运算符的规则"><a href="#重载运算符的规则" class="headerlink" title="重载运算符的规则"></a>重载运算符的规则</h3><p>重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象（或类对象的引用），参数不能全是 C++ 的标准类型</p><h3 id="运算符重载函数作为类成员函数和友元函数"><a href="#运算符重载函数作为类成员函数和友元函数" class="headerlink" title="运算符重载函数作为类成员函数和友元函数"></a>运算符重载函数作为类成员函数和友元函数</h3><p>将双目运算符重载为友元函数时，由于友元函数不是该类的成员函数，因此在函数的形参表中必须有两个参数，不能省略。</p><h3 id="用转换构造函数进行不同类型数据的转换"><a href="#用转换构造函数进行不同类型数据的转换" class="headerlink" title="用转换构造函数进行不同类型数据的转换"></a>用转换构造函数进行不同类型数据的转换</h3><p>通常把有一个参数的构造函数作类型转换，所以，称为转换构造函数。</p><h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>类型转换函数的作用是将一个类的对象转换成另一个类型的数据。形式如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operator 类型名（） </span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在函数名前不能指定函数类型，函数没有参数。类型转换函数只能作为成员函数，因为转换的主体是本类的对象，不能作为友元函数或普通函数。</p><p>如果运算符重载函数为成员函数，它的第一个参数必须是本类的对象。当第一个操作数不是类对象时，不能将运算符函数重载为成员函数，如果将运算符“+” 重载为类的成员函数，交换律不适用。</p><p>类型转换函数与运算符重载不共存。因为可能出现二义性。</p><h2 id="第十一章-继承与派生"><a href="#第十一章-继承与派生" class="headerlink" title="第十一章 继承与派生"></a>第十一章 继承与派生</h2><h3 id="派生类的声明方式"><a href="#派生类的声明方式" class="headerlink" title="派生类的声明方式"></a>派生类的声明方式</h3><p>基类名前有 public 的称为公用继承。如果不写此项，默认为 privite（私有的）</p><h3 id="派生类成员的访问属性"><a href="#派生类成员的访问属性" class="headerlink" title="派生类成员的访问属性"></a>派生类成员的访问属性</h3><p>基类的成员函数只能访问基类的成员，而不能派生类的成员。</p><ul><li><p>公用继承</p><p>  基类的公用成员和保护成员在派生类中保持原有访问属性，私有成员仍为基类私有</p></li><li><p>私有继承</p><p>  基类的公有成员和保护成员在派生类中成了私有成员，私有成员仍为基类私有</p></li><li><p>受保护继承</p><p>  基类的公有成员和保护成员在派生类中成了保护成员，私有成员仍为基类私有</p></li></ul><h3 id="派生类的构造函数和析构函数"><a href="#派生类的构造函数和析构函数" class="headerlink" title="派生类的构造函数和析构函数"></a>派生类的构造函数和析构函数</h3><p>基类的构造函数式不能继承的，对继承过来的基类成员初始化的工作也要由派生类的构造函数承担。解决这个问题的思路是：在执行派生类的构造函数时，调用基类的构造函数。</p><h4 id="简单的派生类构造函数"><a href="#简单的派生类构造函数" class="headerlink" title="简单的派生类构造函数"></a>简单的派生类构造函数</h4><p>在类中对派生类构造函数作声明时，不包括上面给出的一般形式中的基类的构造函数名（参数表）部分</p><h4 id="有子对象的派生类的构造函数"><a href="#有子对象的派生类的构造函数" class="headerlink" title="有子对象的派生类的构造函数"></a>有子对象的派生类的构造函数</h4><p>应当在建立对象时对它的数据成员初始化。</p><p>派生类构造函数的任务应该包括：</p><ol><li>对基类数据成员初始化</li><li>对子对象数据成员初始化</li><li>对派生类数据成员初始化</li></ol><p>定义派生类构造函数的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">派生类构造函数名（总参数表）：基类构造函数名（参数表），子对象名（参数表）</span><br><span class="line">&#123; 派生类中新增数据成员初始化语句 &#125;</span><br></pre></td></tr></table></figure><h3 id="派生类构造函数的特殊形式"><a href="#派生类构造函数的特殊形式" class="headerlink" title="派生类构造函数的特殊形式"></a>派生类构造函数的特殊形式</h3><p>如果在基类中没有定义构造函数，或定义了没有参数的构造函数，那么，在定义派生类构造函数时可以不写基类构造函数。因此此时派生类构造函数没有向基类构造函数传递参数的任务。在调用派生类构造函数时，系统会自动首先调用基类的默认构造函数。</p><h3 id="派生类的析构函数"><a href="#派生类的析构函数" class="headerlink" title="派生类的析构函数"></a>派生类的析构函数</h3><p>在执行派生类的析构函数时，系统会自动调用基类的析构函数和子对象的析构函数。调用的顺序与构造函数相反：先执行派生类自己的析构函数，然后调用子对象的析构函数，最后调用基类的析构函数。</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>形式如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">派生类构造函数名（总参数表）：基类 1 构造函数（参数表），基类 2 构造函数（参数表）, 基类 3 构造函数（参数表）</span><br><span class="line">&#123; 派生类中新增数据成员初始化语句 &#125;</span><br></pre></td></tr></table></figure><p>声明基类的顺序决定了基类构造函数的调用顺序</p><h3 id="多重继承引发的二义性问题"><a href="#多重继承引发的二义性问题" class="headerlink" title="多重继承引发的二义性问题"></a>多重继承引发的二义性问题</h3><p>基类的同名成员在派生类中被屏蔽。成为不可见的。因此如果在定义派生类对象的模块中通过对象名访问同名的成员，则访问的是派生类的成员。请注意：不同的成员函数，只有在函数名和参数个数相同、类型相匹配的情况下才发生同名覆盖。</p><h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><p>虚基类使得在继间接共同基类时只保留一份成员。</p><p>需要注意，为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。</p><p>由于虚基类在派生类中只有一份数据成员，所以这份数据成员的初始化必须由派生类直接给出。</p><p>C++ 编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类对虚基类的构造函数的调用，这就保证了虚基类的数据成员不会被多次初始化。</p><h3 id="基类与派生类的转换"><a href="#基类与派生类的转换" class="headerlink" title="基类与派生类的转换"></a>基类与派生类的转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A al; //定义基类 A 对象 al</span><br><span class="line">B bl; //B 是 A 的派生类</span><br><span class="line">A&amp; r = al; //定义基类 A 对象的引用 r，并引用 al 对其初始化</span><br></pre></td></tr></table></figure><p>这时，r 是 al 的引用（别名），r 和 al 共享同一段存储单元。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&amp; r = bl;</span><br></pre></td></tr></table></figure><p>此时 r 并不是 bl 的别名，也不是与 bl 共享同一段存储单元，它只是 bl 中基类部分的别名，r 与 bl 中基类部分共享同一段存储单元，r 与 bl 具有相同的其实地址。</p><p>即基类的引用类型，指向了派生类的变量。指向的也是派生类中从基类继承的部分。</p><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><p>在一个类中以另一个类的对象作为数据成员的，称为类的组合。</p><h2 id="第十二章-多态性与虚函数"><a href="#第十二章-多态性与虚函数" class="headerlink" title="第十二章 多态性与虚函数"></a>第十二章 多态性与虚函数</h2><p>派生类对象可以替代基类对象向基类对象的引用初始化或赋值。调用的不是在 Circle 中声明的运算符重载函数，而是在 Point 中声明的运算符重载函数，输出的是“点”的信息，而不是“圆”的信息。</p><p>这两个 area 函数不是重载函数，它们不仅函数名相同，而且函数类型和参数个数都相同，两个同名函数不在同一个类中，而是分别在基类和派生类中，属于同名覆盖。</p><h3 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a>虚函数的作用</h3><p>编译系统按照同名覆盖的原则决定调用的对象。</p><p>C++ 的虚函数就是用来解决动态多态的问题的。所谓虚函数，就是在基类声明函数是虚拟的，并不是实际存在的函数，然后在派生类中才正式定义此函数。</p><p>本来，基类指针是用来指向基类对象的，如果用它指向派生类对象，则自动进行指针类型转换，将派生类的对象的指针先转换为基类的指针，这样，基类指针指向的是派生类中的基类部分。</p><p>有时在基类中定义的非虚函数会在派生类中被重新定义，如果用基类指针调用该成员函数，则系统会调用对象中基类部分的成员函数；如果用派生类指针调用该函数，则系统会调用派生类对象中的成员函数，这并不是多态性行为（使用的是不同类型的指针）</p><h3 id="静态关联和动态关联"><a href="#静态关联和动态关联" class="headerlink" title="静态关联和动态关联"></a>静态关联和动态关联</h3><p>确定调用的具体对象的过程称为关联。</p><p>函数重载和通过对象名调用的虚函数，在编译时即可确定其调用的虚函数属于哪一个类，其过程称为静态关联。</p><p>由于是在运行阶段把虚函数和类对象“绑定”在一起的，因此称为动态关联。</p><h3 id="在什么情况下应当声明虚函数"><a href="#在什么情况下应当声明虚函数" class="headerlink" title="在什么情况下应当声明虚函数"></a>在什么情况下应当声明虚函数</h3><p>一个成员函数被声明为虚函数后，在同一类族中的类就不能定义一个非 virtual 的但与该虚函数具有相同的参数。</p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>先调用了派生类的析构函数，再调用了基类的析构函数。当基类的析构函数为虚函数，无论指针指的是同一类族中的哪一个类对象。</p><p>如果将基类的析构函数声明为虚函数时，由该函数所派生的所有派生类的析构函数有都自动成为虚函数，即使派生类的析构函数与基类的析构函数名字不相同。</p><h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual 函数类型 函数名（参数类别） = 0;</span><br></pre></td></tr></table></figure><p>纯虚函数只有函数的名字而不具备函数的功能，不能被调用。它只是通知编译系统：在这里声明一个虚函数，待派生类中定义。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>凡是包含纯虚函数的类的都是抽象类。因为纯虚函数是不能被调用的，包含纯虚函数的类是无法建立对象的。抽象类的作用是作为一个类族的共同基类。</p><p>抽象基类不能也不必要定义对象。</p><h4 id="区别静态关联和动态关联"><a href="#区别静态关联和动态关联" class="headerlink" title="区别静态关联和动态关联"></a>区别静态关联和动态关联</h4><p>在编译阶段就能确定调用的是哪一个类的虚函数，所以属于静态关联。如果是通过基类指针调用虚函数，在编译阶段无法从语句本身确定调用哪一个类的虚函数，只有在运行时，指针指向某一类对象后，才能确定调用的是哪一个类的虚函数，故为动态关联。</p><h2 id="第十三章-输入输出流"><a href="#第十三章-输入输出流" class="headerlink" title="第十三章 输入输出流"></a>第十三章 输入输出流</h2><h3 id="istream-类的其他成员函数"><a href="#istream-类的其他成员函数" class="headerlink" title="istream 类的其他成员函数"></a>istream 类的其他成员函数</h3><p>如果到达文件末尾（遇到文件结束符），eof 函数值为非零值（表示真），否则为 0（假）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文联合编辑：小辣辣。向她致以最崇高的敬（爱）意 ❤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第一章-C-的初步认识&quot;&gt;&lt;a href=&quot;#第一章-C-的初步认识&quot; class=&quot;headerlink&quot; title=&quot;第一章 
      
    
    </summary>
    
    
      <category term="C++" scheme="https://yazhidev.github.io/tags/C/"/>
    
      <category term="读书笔记" scheme="https://yazhidev.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>APK 的前世今生：从 Android 源码到 apk 的编译打包流程</title>
    <link href="https://yazhidev.github.io/2018/11/18/APK-%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%9A%E4%BB%8E-Android-%E6%BA%90%E7%A0%81%E5%88%B0-apk-%E7%9A%84%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <id>https://yazhidev.github.io/2018/11/18/APK-的前世今生：从-Android-源码到-apk-的编译打包流程/</id>
    <published>2018-11-18T05:03:28.000Z</published>
    <updated>2022-06-07T22:58:54.434Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要研究热修复的原理，并自己实现一套简单的热修复框架（音视频的坑刚挖好就又挖另一个坑了2333），已经在看书入门 c++，方便后续查看业内一些知名热修复框架的源码，另外在涉及编译期/运行时修改代码之前，先了解一下 apk 是如何从项目源码被打包生成的，可能对后续的从思路上或实际操作都会所裨益。</p><p>文中涉及到的工具所在目录：<code>Android/sdk/build-tools</code>。下面开始分解并逐步实现对源码的打包。</p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><h3 id="1-生成仅包含资源文件的-apk-包和-R-java-文件"><a href="#1-生成仅包含资源文件的-apk-包和-R-java-文件" class="headerlink" title="1. 生成仅包含资源文件的 apk 包和 R.java 文件"></a>1. 生成仅包含资源文件的 apk 包和 R.java 文件</h3><p>根据资源文件和 AndroidManifest.xml 由工具 AAPT 生成 R.java 文件。Android Gradle Plugin 3.0.0 以后默认使用 AAPT2，详见 <a href="https://developer.android.com/studio/command-line/aapt2" target="_blank" rel="noopener">AAPT2 官方文档</a>。来看一下 AAPT2 的使用：</p><h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><p>编译所有 Android 支持的资源文件。可以通过编译语句将单个资源文件编译成 <code>.flat</code> 后缀的过渡二进制文件</p><p>AAPT 可以编译单个文件，例如编译 strings.xml，会生成 values_strings.arsc.flat 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt2 compile app/src/main/res/values/strings.xml -o test/</span><br></pre></td></tr></table></figure><p>但一个项目不可能只有一个资源文件，通常都是编译 整个 res 资源目录，会生成 zip 压缩包，包含了所有资源文件编译后的 flat 格式文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt2 compile --dir app/src/main/res/ -o package/res.zip</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>–dir：指定输入目录</li><li>-o： 指定输出目录（如果输入源是文件夹，则需要指定编译后的（zip）文件名）</li></ul><h4 id="链接（link）"><a href="#链接（link）" class="headerlink" title="链接（link）"></a>链接（link）</h4><p>将预编译生成的过渡二进制文件合并并打包成单独的 APK 包，R 文件和 ProGuard 规则文件也是在这个时期生成的，生成的 APK 包不包含 DEX 字节码并且是未签名的（后续可使用 D8 编译工具将 Java 字节码编译成 DEX 字节码，使用 apksigner 对 APK 签名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aapt2 link package/res.zip \</span><br><span class="line">-I ~/Library/Android/sdk/platforms/android-27/android.jar \</span><br><span class="line">--java package/ \</span><br><span class="line">--manifest app/src/main/AndroidManifest.xml \</span><br><span class="line">-o package/res.apk</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>-I：必要参数，指定 android.jar 目录，因为 xml 中可能使用到了例如 android:id 等自带的 android 命名空间</li><li>o：指定输出 apk 路径</li><li>–java：指定生成的 R 文件的路径</li><li>–manifest：必要参数，Manifest 文件中包含了 app 的包名和 application id</li></ul><p>执行上述命令后报错：style/Theme.AppCompat.Light.DarkActionBar  not found. </p><p>以及 layout_constraintBottom_toBottomOf （新建的工程默认依赖了 constraint-layout库）等各种 not found。</p><p>报这些错是因为 link 时没有引入第三方库，在 Google 文档里没有找到相关的命令，所以先移除这些依赖，跑通整个流程后再回头看怎么解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// AppTheme 暂时先移除对 Theme.Appcompat 的依赖</span><br><span class="line"> &lt;style name=&quot;AppTheme&quot; parent=&quot;android:Theme.Holo.Light.DarkActionBar&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>再执行一遍命令，可以看到指定的输出目录已经生成了 apk 包和 R 文件：</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-23a3332793c1e3a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="仅包含资源文件的apk与R文件"></p><h3 id="2-处理aidl，生成对应的java文件"><a href="#2-处理aidl，生成对应的java文件" class="headerlink" title="2. 处理aidl，生成对应的java文件"></a>2. 处理aidl，生成对应的java文件</h3><p>因为 demo 没有涉及到 aidl，暂且跳过。</p><h3 id="3-编译-java-文件为-class-文件"><a href="#3-编译-java-文件为-class-文件" class="headerlink" title="3. 编译 .java 文件为 .class 文件"></a>3. 编译 .java 文件为 .class 文件</h3><p>编译项目 src 目录下所有 .java 文件还有之前生成的 R.java 、aidl 生成的 java 文件为相应的的 class 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-8 \</span><br><span class="line">-target 1.8 \</span><br><span class="line">-bootclasspath ~/Library/Android/sdk/platforms/android-27/android.jar \</span><br><span class="line">app/src/main/java/com/yazhidev/demo/*.java package/com/yazhidev/demo/R.java \</span><br><span class="line">-d package/</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>-encoding: 指定编码方式为 uts-8</li><li>-target：指定 Java 版本号</li><li>-bootclasspath：引入 Android.jar 包内的类</li><li>-d：指定编译生成的字节码文件存放的路径</li></ul><h3 id="4-class-文件编译为-dex-文件"><a href="#4-class-文件编译为-dex-文件" class="headerlink" title="4. class 文件编译为 dex 文件"></a>4. class 文件编译为 dex 文件</h3><p>dex 文件是 Android 虚拟机所能识别、解析并运行的文件。Java 源文件被编译为 class 文件后，需要通过 dex 编译器将多个 class 文件整合为一个 dex 文件，从 Android Studio 3.1 开始，已经使用 D8 替代原先的 DX 作为默认的 dex 编译器。D8 的使用很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d8 package/com/yazhidev/demo/*.class \</span><br><span class="line">--classpath ~/Library/Android/sdk/platforms/android-27/android.jar \</span><br><span class="line">--output ./</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>–classpath：指定编译需要引用到的类</li><li>–output：指定编译后生成的 .dex 文件的存放路径</li></ul><h3 id="5-将-dex-文件添加进-apk-包"><a href="#5-将-dex-文件添加进-apk-包" class="headerlink" title="5. 将 dex 文件添加进 apk 包"></a>5. 将 dex 文件添加进 apk 包</h3><p>原本这步是通过 apkbuilder 脚本来做的，现在改成用 aapt 命令来做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt add package/res.apk classes.dex</span><br></pre></td></tr></table></figure><p>需要注意的是 dex 文件前不能加路径，否则会将路径带入 apk 包中。</p><h3 id="6-优化对齐-apk-文件"><a href="#6-优化对齐-apk-文件" class="headerlink" title="6. 优化对齐 apk 文件"></a>6. 优化对齐 apk 文件</h3><p><a href="https://developer.android.com/studio/command-line/apksigner" target="_blank" rel="noopener">apksigner 文档</a>中提到，如果使用 apksigner 对 apk 签名，则需要在签名之前使用 zipalign 优化对齐。</p><p>zipalign 的使用很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zipalign 4 package/res.apk package/app-unsigned-aligned.apk</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">4 代表 32 位对齐，zipalign 可以确保所有未压缩的数据的开头均相对于文件开头部分执行特定的字节对齐，这样可减少应用消耗的 RAM 量。</span><br><span class="line"></span><br><span class="line">### 7. 签名</span><br><span class="line"></span><br><span class="line">签名需要私钥，可以通过 Android Studio 生成，也可通过 JDK bin 目录下的 keytool 工具生成。keytool 以及 apksigner 的使用可参考：[从命令行构建和签署您的应用](https://developer.android.com/studio/publish/app-signing)</span><br><span class="line"></span><br><span class="line">我自己这么就直接使用现有的 key 签名，签名的命令很简单：</span><br></pre></td></tr></table></figure><p>//apk 签名<br>apksigner sign –ks key.jks –out package/app-release.apk package/app-unsigned-aligned.apk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">参数含义：</span><br><span class="line">- --ks：指定私钥文件</span><br><span class="line">- --out：指定签名后的 apk 输出路径</span><br></pre></td></tr></table></figure></p><p>//检查 apk 的签名<br>apksigner verify app.apk<br><code>`</code></p><p>至此，就完成了 Android 源码打包成 apk 的整个流程，当然以上只是最简单的情况，对于第三方库、多 module 等情景下的打包流程都没有涉及。将 apk 安装到手机上，可以正常打开:</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-22e822fa268140b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="丑出天际的首页"></p><p>一打开首页我的内心的拒绝的，这首页可以说是丑出天际。但起码从 0 到 1 了（化身阿 Q 疯狂自我安慰），一番操作算是对 apk 的打包流程有了个笼统的认识，后面要了解一下 app 启动流程，为热修复的学习打基础。（也许后面会回来填坑？）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想要研究热修复的原理，并自己实现一套简单的热修复框架（音视频的坑刚挖好就又挖另一个坑了2333），已经在看书入门 c++，方便后续查看业内一些知名热修复框架的源码，另外在涉及编译期/运行时修改代码之前，先了解一下 apk 是如何从项目源码被打包生成的，可能对后续的从思路
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 音视频开发（一）：PCM 格式音频的播放与采集</title>
    <link href="https://yazhidev.github.io/2018/10/26/Android-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9APCM-%E6%A0%BC%E5%BC%8F%E9%9F%B3%E9%A2%91%E7%9A%84%E6%92%AD%E6%94%BE%E4%B8%8E%E9%87%87%E9%9B%86/"/>
    <id>https://yazhidev.github.io/2018/10/26/Android-音视频开发（一）：PCM-格式音频的播放与采集/</id>
    <published>2018-10-26T11:57:07.000Z</published>
    <updated>2022-06-07T22:58:54.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-PCM-格式"><a href="#什么是-PCM-格式" class="headerlink" title="什么是 PCM 格式"></a>什么是 PCM 格式</h2><p>声音从模拟信号转化为数字信号的技术，经过采样、量化、编码三个过程将模拟信号数字化。</p><ul><li><p>采样</p><p>  顾名思义，对模拟信号采集样本，该过程是从时间上对信号进行数字化，例如每秒采集 44100 次，即采样频率 44.1 khz</p></li><li><p>量化</p><p>  既然是将音频数字化，那就需要使用二进制来表示声音的每一个样本。例如每个样本使用 16 位长度来表示，即音频的位深度为 16 位</p></li><li><p>编码</p><p>  编码就是按照一定的格式记录采样和量化后的数据，比如顺序存储或压缩存储等</p></li></ul><p>编码后经由不同的算法，音频被保存为不同的格式，例如 MP3、AAC 等，而 PCM 就是最为原始的一种格式，PCM 数据是音频的裸数据格式，不经过任何压缩。</p><h2 id="从零到一：使用-AudioTrack-支持-PCM-格式音频的播放"><a href="#从零到一：使用-AudioTrack-支持-PCM-格式音频的播放" class="headerlink" title="从零到一：使用 AudioTrack 支持 PCM 格式音频的播放"></a>从零到一：使用 AudioTrack 支持 PCM 格式音频的播放</h2><p>AudioTrack 只支持播放 PCM 编码格式的音频流，平时使用的 MediaPlayer 支持 MP3、AAC 等多种音频格式，其内部也是将 MP3 格式文件使用 framework 层创建的解码器解码为 PCM 裸数据，再经由 AudioTrack 播放的。封装过的 Mediaplayer 的 API 是简单好用，但许多细节我们却无法掌控，而使用 AudioTrack，除了播放之外，我们还可以对数据源做许多有意思的操作，二者各有优劣之处。</p><p>先通过构造函数来了解 AudioTrack（版本为API26）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public AudioTrack(AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes, int mode, int sessionId) &#123;</span><br><span class="line">    ...                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个参数介绍一下：</p><ul><li><p>AudioAttributes</p><p>  定义音频的类型，包括音乐、通知、闹钟等，调节音量时也会根据不同的类型进行调节</p></li><li><p>AudioFormat</p><p>  定义音频的格式，可配置声道数（单通道、多通道）、编码格式（每个采样数据位深度，8bit、16bit等）、采样率</p></li><li><p>bufferSizeInBytes</p><p>  AudioTrack 内部的音频缓冲区的大小，该缓冲区的值不能低于一帧“音频帧”（Frame）的大小，即：采样率 x 位深 x 采样时间 x 通道数，采样时间一般取 2.5ms~120ms 之间，AudioTrack 类提供了 <code>getMinBufferSize()</code> 方法来计算该值</p></li><li><p>mode</p><p>  AudioTrack 的两种播放模式，MODE_STATIC 和 MODE_STREAM，前者直接将数据加载进内存，后者是按照一定的间隔不断地写入数据</p></li></ul><p>API26 下原有的两个构造函数已经被标为废弃，建议使用 Builder 来构造 AudioTrack 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private fun createAudioTrack(): AudioTrack &#123;</span><br><span class="line">    val format = AudioFormat.Builder()</span><br><span class="line">            .setChannelMask(AudioFormat.CHANNEL_OUT_STEREO)</span><br><span class="line">            .setSampleRate(44100)</span><br><span class="line">            .setEncoding(AudioFormat.ENCODING_PCM_16BIT)</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    return AudioTrack.Builder()</span><br><span class="line">            .setAudioFormat(format)</span><br><span class="line">            .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上介绍 AudioTrack 时常见的如何构造 <code>bufferSizeInBytes</code>也不用关心了，Builder 类会替我们默认生成。</p><p>构造出对象后，在调用 <code>play()</code> 函数开启播放后，只要开启一个线程不断地从源文件中读取数据并调用 AudioTrack 的 <code>write()</code> 函数向手机端音频输出设备传输数据，即可播放 PCM 音频。</p><h3 id="使用-ffmpeg-将-MP3-转为-PCM"><a href="#使用-ffmpeg-将-MP3-转为-PCM" class="headerlink" title="使用 ffmpeg 将 MP3 转为 PCM"></a>使用 ffmpeg 将 MP3 转为 PCM</h3><p>Mac 下安装 ffmpeg：<code>brew install ffmpeg</code></p><p>使用 ffmpeg 将 mp3 转换为 pcm：<code>ffmpeg -i xxx.mp3 -f s16le -ar 44100 -ac 2 -acodec pcm_s16le xxx.pcm</code></p><ul><li>-i 制定输入文件</li><li>-f 指定输出编码格式为16byte小端格式</li><li>-ar 指定输出采样率</li><li>-ac 指定输出通道数</li><li>acodec 指定解码格式</li><li>xxx.pcm 为输出文件</li></ul><p>这里也提供一下我使用的 PCM 文件：<a href="https://drive.google.com/open?id=1XOAXpwZSa1htRRePjxbt2J6PEY_XJKLg" target="_blank" rel="noopener">hurt-johnny cash.pcm 44.1khz 双通道 16位深</a></p><h2 id="PCM-录制：AudioRecord"><a href="#PCM-录制：AudioRecord" class="headerlink" title="PCM 录制：AudioRecord"></a>PCM 录制：AudioRecord</h2><p>MediaRecorder 录制集成了编码、压缩等功能，AudioRecord 录制的是 PCM 格式的音频文件。</p><p>同样的，先从构造函数来认识 AudioRecord：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public AudioRecord(AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes, int sessionId) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接触过 AudioTrack，对 AudioRecord 一定不会感到陌生，其构造函数参数与 AudioTrack 几乎如出一辙，这里就不多说了。</p><p>AudioRecord 的 API 与 AudioTrack 也是遥相呼应的，在调用函数 <code>startRecording()</code> 开启录制后，只要开启一个后台线程不断地调用 <code>read()</code> 函数从手机端的音频输入设备（麦克风等）读取音频数据，并写入本地文件，即可实现音频的录制。</p><h2 id="扩展支持的音频格式：-WAV"><a href="#扩展支持的音频格式：-WAV" class="headerlink" title="扩展支持的音频格式： WAV"></a>扩展支持的音频格式： WAV</h2><p>最开始提到过音频会被编码成不同的格式，而常见的压缩编码格式 WAV 格式可能是与 PCM 数据最为接近的一种格式。WAV 编码不会进行压缩操作，它只在 PCM 数据格式前加上 44 字节（并不一定严格是 44 字节）来描述音频的基本信息，例如采样率、声道数、数据格式等。来看看 WAV 文件头的格式：</p><h3 id="WAV-文件头格式"><a href="#WAV-文件头格式" class="headerlink" title="WAV 文件头格式"></a>WAV 文件头格式</h3><table><thead><tr><th>长度（字节）</th><th>内容</th></tr></thead><tbody><tr><td>4</td><td>“RIFF” 字符串</td></tr><tr><td>4</td><td>从下个地址开始到文件尾的总字节数（音频 data 数据长度 + 44 -8）</td></tr><tr><td>4</td><td>“WAVE”  </td></tr><tr><td>4</td><td>“fmt “（最后有一个空格）</td></tr><tr><td>4</td><td>过渡字节（一般为00000010H），若为00000012H则说明数据头携带附加信息（见“附加信息”）</td></tr><tr><td>2</td><td>格式种类，1 表示为PCM形式的声音数据  </td></tr><tr><td>2</td><td>通道数，单声道为1，双声道为2  </td></tr><tr><td>4</td><td>采样率</td></tr><tr><td>4</td><td>波形音频数据传送速率，其值为通道数×每秒数据位数×每样本的数据位数／8。播放软件利用此值可以估计缓冲区的大小。  </td></tr><tr><td>2</td><td>每个采样需要的字节数，其值为通道数×位深度／8。播放软件需要一次处理多个该值大小的字节数据，以便将其值用于缓冲区的调整。  </td></tr><tr><td>2</td><td>位深度</td></tr><tr><td>4</td><td>“data”</td></tr><tr><td>4</td><td>DATA数据长度</td></tr></tbody></table><p>了解了 WAV 文件头的格式，我们可以尝试自己写一个解析 WAV 文件头的方法，结合上文的 AudioTrack 播放 PCM 的内容来看，只要获取到音频的采样率、位深度与声道数就可以播放该音频。自然也就可以播放内容是 PCM 格式的 WAV 文件。</p><p>在此之前需要一个 WAV 文件用作测试，可以使用 ffmpeg 将之前转换的 PCM 格式音频转码成 WAV 格式。</p><h3 id="使用-ffmpeg-将-PCM-转为-WAV"><a href="#使用-ffmpeg-将-PCM-转为-WAV" class="headerlink" title="使用 ffmpeg 将 PCM 转为 WAV"></a>使用 ffmpeg 将 PCM 转为 WAV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i xxx.pcm -f s16le -ar 44100 -ac 2 xxx.wav</span><br></pre></td></tr></table></figure><p>也分享一下我使用的 WAV 文件：<a href="https://drive.google.com/open?id=1WrWaLti1ug6feNXlLOs7-jqgif-WO6p0" target="_blank" rel="noopener">hurt-johnny cash.wav     44.1khz 双通道 16位深</a></p><h3 id="解析-WAV-文件头"><a href="#解析-WAV-文件头" class="headerlink" title="解析 WAV 文件头"></a>解析 WAV 文件头</h3><p>根据上面提到的 WAV 文件头格式，定义一个类用于存放文件头数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class WaveHeader &#123;</span><br><span class="line">    private String riff; // &quot;RIFF&quot;</span><br><span class="line">    private int totalLength; //音频 data 数据长度 + 44 -8</span><br><span class="line">    private String wave; // &quot;WAVE&quot;</span><br><span class="line">    private String fmt; // &quot;fmt &quot;</span><br><span class="line">    private int transition; //过渡字节，一般为0x00000010</span><br><span class="line">    private short type; // PCM：1</span><br><span class="line">    private short channelMask; // 单声道：1，双声道：2</span><br><span class="line">    private int sampleRate; //采样率</span><br><span class="line">    private int rate;  // 波形音频数据传送速率，其值为通道数×每秒数据位数×每样本的数据位数／8</span><br><span class="line">    private short sampleLength; // 每个采样需要的字节数，其值为通道数×位深度／8</span><br><span class="line">    private short deepness; //位深度</span><br><span class="line">    private String data; // &quot;data&quot;</span><br><span class="line">    private int dataLength; //data数据长度</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好文件头后，我们使用 <code>BufferedInputStream</code> 从本地文件输入流中挨个字节读取数据即可。</p><h4 id="byte-字节转字符串"><a href="#byte-字节转字符串" class="headerlink" title="byte 字节转字符串"></a>byte 字节转字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static String readString(InputStream inputStream, int length) &#123;</span><br><span class="line">    byte[] bytes = new byte[length];</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        return new String(bytes);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="byte-字节转-short、int"><a href="#byte-字节转-short、int" class="headerlink" title="byte 字节转 short、int"></a>byte 字节转 short、int</h4><p>需要注意的是 WAV 头中的字节数组是经过反转的，例如表示单通道的字节数组为{1, 0}，其中 1 为低位字节，即原始的字节为 [0, 1]，转换为二进制为 <code>0000 0000 0000 0001</code>，即十进制的 1，代表单通道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//从输入流中读取 2 个字节并转换为 short</span><br><span class="line">private static short readShort(InputStream inputStream) &#123;</span><br><span class="line">    byte[] bytes = new byte[2];</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        //&#123;1, 0&#125;</span><br><span class="line">        return (short) ((bytes[0] &amp; 0xff) | ((bytes[1] &amp; 0xff) &lt;&lt; 8));</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//从输入流中读取 4 个字节并转换为 int</span><br><span class="line">private static int readInt(InputStream inputStream) &#123;</span><br><span class="line">    byte[] bytes = new byte[4];</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        return (int) ((bytes[0] &amp; 0xff) | ((bytes[1] &amp; 0xff) &lt;&lt; 8) | ((bytes[2] &amp; 0xff) &lt;&lt; 16) | ((bytes[3] &amp; 0xff) &lt;&lt; 24));</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，字节转换为整型数据类型（short、int 等）时，需要先与 <code>0xff</code> 做与（<code>&amp;</code>）操作，这是为什么呢？</p><h4 id="类型转换时-byte-amp-0xff-的原因"><a href="#类型转换时-byte-amp-0xff-的原因" class="headerlink" title="类型转换时 byte &amp; 0xff 的原因"></a>类型转换时 byte &amp; 0xff 的原因</h4><p>要究其原因，首先需要搞清楚计算机中的原码、反码和补码，这个在之前的文章<a href="https://www.jianshu.com/p/ae735d849017" target="_blank" rel="noopener">《Bitmap 图像灰度变换原理浅析》</a>中计算 int 数据类型的值范围时也提到过。下面举个栗子来验证一下，类型转换前 <code>&amp; 0xff</code> 到底有什么用：</p><p>假定有一个 byte 数组：[0, 0, -1, 0]，想求得这 4 个字节代表的 int 值得大小，重点看第三个字节，其值为 -1，byte 占一个字节 8 位，易得：</p><ul><li>原码：<code>1000 0001</code></li><li>反码：<code>1111 1110</code></li><li>补码：<code>1111 1111</code></li></ul><p>显而易见，这个 byte 数组代表的 int 值的二进制值为：</p><p><code>0000 0000 0000 0000 1000 0001 0000 0000</code></p><p>只要对 -1 左移 8 位即可。so easy！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte a = -1;</span><br><span class="line">int b = a &lt;&lt; 8; //结果是 -256</span><br></pre></td></tr></table></figure><p>值为负数就说明以上转换必然是错的。因为我们想要的结果是 <code>0000 0000 0000 0000 1000 0001 0000 0000</code>，该二进制最高位符号位为 0，结果必然是一个正数。</p><p>我们知道计算机在运算时使用的是补码，则 （byte）-1 &lt;&lt; 8 运算时，计算机会对 -1 的补码 <code>1111 1111</code> 做位移操作，结果为 <code>1111 1111 0000 0000</code>，其原码为 <code>1000 0001 0000 0000</code>，先记作 <strong>16位原码A</strong>，当该值赋值给 int 类型的变量时，int 类型占 4 个字节 32 位，则需要对原因的 16 位值做位扩展，负数在位扩展时会对多出的高位补 1（正数补 0），则扩展后的值为 <code>1111 1111 1111 1111 1111 1111 0000 0000</code>，转为原码为 <code>1000 0000 0000 0000 0000 0001 0000 0000</code>，记作 <strong>32位原码B</strong>，与上面的 16 位原码做比较可以发现，二者最高位都是 1，低位的值也相同，两个二进制的值在十进制上是一致的，这就是负数补码高位补 1 的原因：为了保持十进制的一致性。不难理解这样做的原因，否则 short 类型强制为 int 类型后值就发生变化了，这明显是不可接受的。</p><p>回到我们的需求，我们这里并不需要保持十进制的一致性，所以要先与 0xff 做与运算，因为 0xff 是十六进制 32 位，二进制值为 32 个 1，<code>-1 &amp; 0xff</code> 时，8 位与 32 位运算时，8 位的需要先在高位补 0 补齐到 32 位才会做运算，所以<br><code>-1 &amp; 0xff</code> 的结果为补码：<code>1111 1111</code> 前面带 24 个 0，最高位为正数，再对结果做位移操作，得到的二进制值补码为：<code>0000 0000 0000 0000 1111 1111 0000 0000</code>，因为是正数，原码与补码相同，该二进制值为 65280。可以验证下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte a = -1;</span><br><span class="line">int c = (a &amp; 0xff) &lt;&lt; 8; //结果是 65280</span><br></pre></td></tr></table></figure><p>概括一下就是：</p><ul><li><p>类型转换时补码位扩展（例如 2 个字节转 4 个字节，即 short 转 int）的规则：正数高位补 0，负数高位补1，以此保持十进制的一致性</p></li><li><p>运算时，补码高位统一补 0</p></li></ul><p>这里也附上将 byte 转二进制（补码）的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static String binary(byte bytes, int radix)&#123;</span><br><span class="line">    byte[] bytes1 = new byte[1];</span><br><span class="line">    bytes1[0] = bytes;</span><br><span class="line">    return new BigInteger(1, bytes1).toString(radix);// 这里的1代表正数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序读取，构造-WavHeader"><a href="#顺序读取，构造-WavHeader" class="headerlink" title="顺序读取，构造 WavHeader"></a>顺序读取，构造 WavHeader</h3><p>接着只要使用 InputStream 从目标音频中顺序读取各个参数的值并构造 WavHeader 即可，因为 Header 成员变量众多，所以考虑用建造者模式来构建 Header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WaveHeader.Builder builder = new WaveHeader.Builder()</span><br><span class="line">    .setRiff(readString(dis, 4))</span><br><span class="line">    .setTotalLength(readInt(dis))</span><br><span class="line">    .setWave(readString(dis, 4))</span><br><span class="line">    .setFmt(readString(dis, 4))</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>另外上面提到过，并非所以 WAV 文件头都是标准的 44 个字节，例如我上面提供的 ffmpeg 转码后的 WAV 文件，其文件头的长度就是 78 个字节。对于文件头长度不一致的问题，我的解决方法是从 37 个字节开始，2 个 2 个字节地读取，直到读取到“da”和“ta”，之后再往后读取 4 个字节的 int 值作为 data 数据长度。读取到 header 后，后面播放的就不用说了，复用上面播放 PCM 的代码即可。</p><p>需要说明的是我只是从网上随机下载了几个 wav 格式音频测试了下是可以正常播放的，并没有经过广泛验证和对常见的 WAV 文件头格式的考证，所以可能还存在兼容问题。</p><p>经过这些以上的学习以及众多资料的查阅，对 Android 端音频开发有了一些小小的认识。后面还会学习一下使用 LAME 将 PCM 转码为 MP3，并实现一些真正意义上的音频播放器的基础功能等。再后面会学习一些视频方面的知识，包括 MediaExtractor、MediaMuxer 解析、封装 MP4 文件、OpenGL ES 渲染图像、MediaCodec 对音视频的硬编、硬解等，并使用一些流行的开源项目例如 ffmpeg 实现一些炫酷的视频处理功能，希望可以在 Android 音视频开发这一块能有所深入，学习过程中的一些收获和困惑也会坚持记录下来。</p><p>此路迢迢，与君共勉。</p><p>以上源码见 <a href="https://github.com/yazhi1992/AndroidMedia/blob/master/app/src/main/java/com/yazhidev/androidmedia/record/RecordActivity.kt" target="_blank" rel="noopener">Github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-PCM-格式&quot;&gt;&lt;a href=&quot;#什么是-PCM-格式&quot; class=&quot;headerlink&quot; title=&quot;什么是 PCM 格式&quot;&gt;&lt;/a&gt;什么是 PCM 格式&lt;/h2&gt;&lt;p&gt;声音从模拟信号转化为数字信号的技术，经过采样、量化、编码三个过程将模拟信号数
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
      <category term="音视频" scheme="https://yazhidev.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解 Java 虚拟机》读书笔记</title>
    <link href="https://yazhidev.github.io/2018/10/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://yazhidev.github.io/2018/10/19/《深入理解-Java-虚拟机》读书笔记/</id>
    <published>2018-10-19T11:06:23.000Z</published>
    <updated>2022-06-07T22:58:54.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-Java-内存区域与内存溢出溢出"><a href="#第二章-Java-内存区域与内存溢出溢出" class="headerlink" title="第二章 Java 内存区域与内存溢出溢出"></a>第二章 Java 内存区域与内存溢出溢出</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。<br>每条线程都有独立的程序计数器，各条线程之间计数器互不影响，独立存储。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建的一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中的入栈到出栈的过程。</p><p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，本地方法栈则为虚拟机使用到的 Native 方法服务。</p><h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>Java 堆是被所有线程共享的一块内存区域，此内存区域的唯一目的就是存放对象实例。</p><p>如果堆中没有内存完成实例分配，且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区的一部分，存放编译器生成的各种字面量和符号引用。运行期间也可能将新的常量放入池中。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方法，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java 堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针指向的位置。有两种方案：</p><ul><li>多线程同步分配</li><li>每个线程分配缓冲区，当缓冲区完成时才需要同步锁定，分配新的缓冲区</li></ul><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p><p>执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意义进行初始化。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>reference 类型再 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置。目前主流的访问方式有使用句柄和直接指针两种</p><ul><li>使用句柄访问，句柄中包含了对象实例数据与类型数据各自具体的地址信息。</li><li>使用直接指针访问，那么 Java 堆对象中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</li></ul><h2 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，主要原因是它很难解决对象之间循环引用的问题。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。</p><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><h4 id="强-软-弱-虚"><a href="#强-软-弱-虚" class="headerlink" title="强 软 弱 虚"></a>强 软 弱 虚</h4><ul><li>强引用</li><li>软引用<br>  在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。</li><li>弱引用<br>  只能生存到下一次垃圾收集发生之前。</li><li>虚引用<br>  也成为幽灵引用，是最弱的一种引用关系。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>要真正宣告一个对象死亡，至少要经历两次标记过程。如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，条件是此对象是否有必要执行 finalize() 方法（对象没有覆盖 finalize() 或者 finalize() 已经被虚拟机调用过，这两种情况视为没有必要执行）。（注：任何一个对象的 finalize() 方法都只会被系统自动调用一次）</p><p>如果这个对象被判定为有必要执行 finalize() 方法，则对象会被放置在一个叫做 F-Quene 的队列之中，在稍后有一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。（执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，以防对象在 finalize() 方法中执行缓慢，或发生死循环）</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>它主要有两个不足：一个效率问题，标记和清除两个过程效率都不高。另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发一次垃圾收集动作。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题，复制算法出现了。它将可用内存按容量划分为大小相等的两块（新生代中大多数人对象时朝生夕死的，所以并不需要按照1：1的比例来划分内存空间），每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制收集算法在对象存活率较高时就有进行较多的复杂操作，效率将会变低。根据老年代的特点，就有了标记-整理算法。过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存货的对象都向一端移动，然后直接清理掉端边界以为的内存。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><h4 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h4><h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>可达性分析对执行时间的敏感还体现在 GC 停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行（即不可以出现引用分析过程中对象引用关系还在不断变化的情况，Sun 将这件事情称为 “Stop The World”）。目前主流 Java 虚拟机都是准确是 GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的，在类加载完成的时候，就把对象内什么偏移量上是什么类型的数据计算处理，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用的。但是没有为每条指令都生成 OopMap，只在特定位置记录这些信息，这些位置称为安全点（SafePoint）。方法调用、循环跳转、异常跳转等，所有具有这些功能的指令才会产生 SafePoint。</p><p>对于 SafePoint，另一个要考虑的问题是如何在 GC 发生时让所有线程都跑到安全点再停顿下来，有两种方案：抢断式中断和主动式中断。</p><p>主动式中断的思想是设置一个标志位，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 GC。</p><p>新生代 GC，指发生在新生代的垃圾收集动作。因为 Java 对象大多都具备朝生夕灭的特性，所以该 GC 非常频繁，一般回收速度也比较快。</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象，指需要大量连续内存空间的 Java 对象。可配置大对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>虚拟机采用分代收集的思想来管理内存。为了内存回收时必须能识别哪些对象放在新生代，哪些放在老年代，为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在 Eden 出生并经过第一次新生代 GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1.对象在 Survivor 区中每“熬过”一次新生代 GC，年龄就加 1 岁，当年龄增加到一定程度，将会被晋升到老年代中。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生新生代 GC 前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，并由结果判断是都进行一次 Full GC。</p><p>一共有多少对象会存活下来在实际完成内存回收之前是无法明确知道的，所有只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值。但这种手段仍然是一种动态概率的收到，依然会导致担保失败，那就会在失败后重新发起一次 Full GC。</p><h2 id="第五章-调优案例分析与实战"><a href="#第五章-调优案例分析与实战" class="headerlink" title="第五章 调优案例分析与实战"></a>第五章 调优案例分析与实战</h2><h3 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h3><p>访问文档时要把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象。</p><p>控制 Full GC 频率的关键是看应用中大多数对象能否符合“朝生夕灭”的原则，这样才能保障老年代空间的稳定。</p><p>相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK 大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。</p><p>32 位 Windows 平台中每个进程只能使用 2 GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到 1.5 GB。</p><h3 id="集群间同步导致的内存溢出"><a href="#集群间同步导致的内存溢出" class="headerlink" title="集群间同步导致的内存溢出"></a>集群间同步导致的内存溢出</h3><p>更重要的缺陷是这一类被集群共享的数据要使用集群缓存来同步的话，可以允许读操作频繁，但不应当有过于频繁的写操作，那样会带来很大的网络同步的开销</p><h3 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h3><p>32 位 Windows 平台的限制是 2GB，其中划了 1.6 GB 给 Java 堆，而 Direct Memory 内存并不算 1.6 GB 的堆之内，因为它最大也只能在剩余的 0.4 GB 空间中分出一部分。Direct Memory 却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后 Full<br>GC，然后“顺便地”帮它清理掉内存的废弃对象。</p><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><h3 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h3><p>各种不同平台的虚拟机玉所有平台的统一使用的程序存储格式——字节码是构成平台无关性的基石。</p><h4 id="Class-类文件的结构"><a href="#Class-类文件的结构" class="headerlink" title="Class 类文件的结构"></a>Class 类文件的结构</h4><p>Class 文件格式采用一种类似 C 语言结构体的伪结构来存储数据，其只有两种数据类型：无符号数和表。</p><p>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</p><p>由于常量池中的常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据代表常量池计数值，这个容量计数是从 1 而不是 0 开始。目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为 0 来表示。</p><p>在 Class 文件中不会保存各个方法、字段的最终内存布局信息。</p><p>常量池中每一项常量都是一个表。</p><p>u2 类型能表达的最大值是 65535。所以 Java 程序中如果定义了超过 64 kb 英文字符的变量或方法名，将会无法编译。</p><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里。</p><p>要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。特征签名是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此 Java 语言里无法仅仅依靠返回值得不同来对一个方法进行重载（但是在 Class 文件格式中，特征签名的范围更大点，只要描述符不是完全一致的两个方法也可以共存，也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，也可以合法共存在同一个 Class 文件中）</p><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>对应的指令为 return，含义是返回此方法，并且返回值为 void，这条指令执行后，当前方法结束。</p><p>在任何实例方法里，都可以通过 this 关键字访问到方法所属的对象，因此在实例方法的局部变量表中至少会有一个指向当前对象实例的局部变量。</p><h5 id="ConstantValue-属性"><a href="#ConstantValue-属性" class="headerlink" title="ConstantValue 属性"></a>ConstantValue 属性</h5><p>对于非 static 类型的变量的赋值是在实例构造器<init> 方法中进行的，而对于类变量，则有两种方式可选:在类构造器<cinit>方法中或使用 ConstantValue 属性。</cinit></init></p><h5 id="Signature-属性"><a href="#Signature-属性" class="headerlink" title="Signature 属性"></a>Signature 属性</h5><p>该属性会记录泛型类型，因为 Java 的泛型采用类型擦除实现的伪泛型。这个属性就是为了弥补运行期做反射时无法获得泛型信息这个缺陷而增设的。</p><h4 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h4><p>由于 Java 虚拟机的操作码长度只有一个字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力。</p><h2 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h2><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p><p>整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。</p><p>对于初始化阶段，虚拟机规范则是严格规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）。</p><p>对于静态字段，只有直接定义这个字段的类才会被初始化，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p>编译阶段通过常量传播优化，会将常量的值存储到类的常量池中。对常量的引用实际都被转化为类对自身常量池带引用。</p><p>接口与类真正有所区别的地方是:当一个类在初始化时，要求其父类全部都已初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候才会初始化。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>相对于类加载过程的其他阶段，一个非数组类的加载阶段是可控性最强的，开发人员可以通过自定义的类加载器去控制字节流的获取方式（即重写一个类加载器的 loadClass() 方法）。</p><p>对于数组类而言，情况有所不同，数组类本事不通过类加载器创建。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证大致会完成下面 4 个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><p>第一阶段的注意目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合一个 Java 类型信息的要求。</p><p>第二阶段主要目的是对元数据信息进行语义校验。</p><p>第三阶段主要目的是确认语义是合法的、符合逻辑的。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，变量所使用的内存都将在方法区中进行分配。需要强调一下，首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p><p>变量在准备阶段的初始值是 0，把值赋值的 putstatic 指令是程序被编译后，存放与类构造器 <cinit> 方法中，在初始化阶段才会进行。</cinit></p><p>会存的特殊情况如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段就会赋值。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>符号引用：以一组符号来描述所引用的目标。</p><p>直接引用：直接指向目标的指针、偏移量或是一个能间接定位到目标的句柄。</p><p>对一个符号引用进行多次解析请求是很常见的，虚拟机会对第一次解析的结果进行缓存，从而避免解析动作重复进行。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。<br>准备阶段，变量已经赋过一次系统要求的初始值，在初始化阶段，则根据程序的主观计划去初始化类变量和其他资源。初始化阶段是执行类构造器 <cinit><br>() 方法的过程。</cinit></p><p><cinit>() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现顺序所决定的，静态语句块中只能访问到定义在静态语句块从之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。</cinit></p><p><cinit>() 方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 <cinit>() 方法执行之前，父类的 <cnint>() 方法已经执行完毕。</cnint></cinit></cinit></p><p><cinit>() 方法对于类或接口来说并不是必须得的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<cinit>()方法。</cinit></cinit></p><p>虚拟机会保证一个类的 <cinit>() 方法在多线程中被正确地使用，只会有一个线程去执行这个类的 <cinit>() 方法。</cinit></cinit></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类与加载器"><a href="#类与加载器" class="headerlink" title="类与加载器"></a>类与加载器</h4><p>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。即使是来源于同一个 Class 文件，如果加载它们的类加载器不同，那这两个类必定不相等。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>如果应用程序中没有自定义过自己的类加载器，一般情况下就是使用系统类加载器。</p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</p><p>双亲委派模型得工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。</p><p>无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各个类加载器环境中都是一个类。</p><h2 id="第九章-类加载器及执行子系统的案例与实战"><a href="#第九章-类加载器及执行子系统的案例与实战" class="headerlink" title="第九章 类加载器及执行子系统的案例与实战"></a>第九章 类加载器及执行子系统的案例与实战</h2><h3 id="OSGI：灵魂的类加载器架构"><a href="#OSGI：灵魂的类加载器架构" class="headerlink" title="OSGI：灵魂的类加载器架构"></a>OSGI：灵魂的类加载器架构</h3><p>一个 Bundle 可以声明它所依赖的 Java Package（通过 Import 描述），也可以声明它允许导出发布的 Java Package（通过 Export 描述），且会严格控制访问范围，如果一个类存在于 Bundle 的类库中但是没有被 Export，那么这个 Bundle 的类加载器能找到这个类，但不会提供给其他 Bundle 使用。</p><h3 id="字节码生成技术与动态代理的实现"><a href="#字节码生成技术与动态代理的实现" class="headerlink" title="字节码生成技术与动态代理的实现"></a>字节码生成技术与动态代理的实现</h3><p>优势在于实现了可以在原始类和接口还未知时，就确定了代理类的代理行为。</p><h2 id="第十章-早期（编译期）优化"><a href="#第十章-早期（编译期）优化" class="headerlink" title="第十章 早期（编译期）优化"></a>第十章 早期（编译期）优化</h2><p>字节码生成是 Javac 编译过程的最后一个阶段。</p><h3 id="Java-的语法糖的味道"><a href="#Java-的语法糖的味道" class="headerlink" title="Java 的语法糖的味道"></a>Java 的语法糖的味道</h3><h4 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h4><p>Java 的泛型只在程序源码中存在，编译后的字节码文件中，已经替换为原来的原生类型（Raw Type），并且相应的地方插入了强制转型代码，因此对于运行期的 Java 语言来说，ArrayList<int> 与 ArrayList<string> 是同一个类。因为参数编译之后都被擦除了，擦除动作导致这两种方法的特征签名变得一模一样。</string></int></p><p>方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名之中，所以返回值不参与重载选择。</p><p>擦除法所谓的擦除，仅仅是对方法的 Code 属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。</p><h4 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h4><p>变长参数编译后使用数组实现。</p><p>遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历得类实现 Iterable 接口的原因。</p><p>包装类的“==”运算在不遇到算数运算的情况下不会自动拆箱。</p><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>根据布尔值常量的真假，编译器将会把分支中：是成立的代码块消除掉，这一工作将在编译器解除语法糖阶段完成。</p><h2 id="第十一章-晚期（运行期）优化"><a href="#第十一章-晚期（运行期）优化" class="headerlink" title="第十一章 晚期（运行期）优化"></a>第十一章 晚期（运行期）优化</h2><p>方法内联的重要性要高于其他优化措施，它的主要目的有两个，一是去除方法调用的成本（如建立栈帧等），二是为其他优化建立良好的基础，方法内联膨胀后可以便于在更大范围上采取后续的优化手段，从而获得更好的优化效果。</p><h3 id="公共分子表达式消除"><a href="#公共分子表达式消除" class="headerlink" title="公共分子表达式消除"></a>公共分子表达式消除</h3><p>如果一个表达式 E 已经计算过了，并且从先前的计算的现在 E 中所有变量的值都没有发生变化，那么 E 的这次就成为了公共分子表达式。</p><h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>Java 语言中访问数组元素 foo[i] 的时候系统将会自动进行上下界的范围检查。</p><p>但数组边界检查是不是必须一次不漏地检查呢？常见的情况是数组访问发生在循环之中，如果循环变量的取值范围永远在区间 [0, foo.length] 之内，那么整个循环中就可以把数组的上下界检查消除。</p><h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联的优化行为看起来很简单，不过是把目标方法的代码“复制”到发起调用的方法区之中，避免发生真实的方法调用而已。但实际上远远没有那么简单，因为多态，编译器无法确定运行版本。</p><p>编译器在进行内联时，如果是非虚方法，那么直接进行内联就可以了。如果遇到虚方法，则会查询此方法是否有多个目标版本可以选择，如果查询结果只有一个版本，也可以进行内联。后续的执行过程中，如果一直没有加载到会令这个方法的接受者的继承关系发生变化的类，则这个内联代码就可以一直使用下去。否则就需要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。</p><p>如果查询结果有多个版本的目标方法可供选择，则使用内联缓存来完成方法内联。其大致原理是：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接受者的版本信息，并且每次进行方法调用时都比较接受者版本，如果都是一样的，那这个内联还可以一直用下去，如果不一致，才会取消内联，查找虚方法进行方法分派。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。</p><h2 id="第十二章-Java-内存模型与线程"><a href="#第十二章-Java-内存模型与线程" class="headerlink" title="第十二章 Java 内存模型与线程"></a>第十二章 Java 内存模型与线程</h2><h3 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h3><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p><p>但它引入了一个新的问题：缓存一致性。</p><p>内存模型，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</p><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成。</p><p>程序运行时主要访问读写的是工作内存。</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>Java 内存模型定义了一下 8 种操作，虚拟机实现时必须保证每一种操作都是原子的、不可再分的：</p><ul><li>lock（锁定）</li><li>unlock（解锁）</li><li>read（读取）</li><li>load（载入）</li><li>use（使用）</li><li>assign（赋值）</li><li>store（存储）</li><li>write（写入）</li></ul><h4 id="对于-volatile-型变量的特殊规则"><a href="#对于-volatile-型变量的特殊规则" class="headerlink" title="对于 volatile 型变量的特殊规则"></a>对于 volatile 型变量的特殊规则</h4><p>当一个变量定义为 volatile 之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新指对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递都需要通过主内存来完成。例如，线程 A 修改了一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。</p><p>volatile 变量在各个线程的工作内存中不存在一致性问题，但是 Java 里的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。</p><p>volatile 只能保证可见性，除了以下两种情况下仍然要通过加锁来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量，的值。</li><li>变量不需要和其他得状态变量共同参与不变约束。</li></ul><p>使用 volatile 的第二个语义是禁止指令重排。</p><p>关键变化在于有 volatile 修饰的变量，赋值后多执行了一个“lock addl $0x0”，这个操作相当于一个内存屏障。这种操作相当于对 cache 中的变量做了一次前面介绍 Java 内存模型中所说的 store 和write 操作，通过这样一个空操作，可让 volatile 变量的修改对其他 cpu 立即可见。</p><h4 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h4><p>Java 内存模型是围绕着并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。</p><p>原子性：由 Java 内存模型来直接保证的原型性变化包括 read、load、assign、use、store 和 write，我们大致认为基本数据类型的访问读写是具备原子性的。</p><p>如果应用场景需要更大范围的原子性操作，Java 内存模型还提供了 lock 和 unlock 操作，这两个指令反映到 Java 代码中就是同步块——synchronize 关键字，因此 synchronize 块之间的操作也具备原子性。</p><p>可见性：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</p><p>有序性：Java 内存模型的有序性可以总结为：如果在本线程内观察，所有操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指线程内表现为串行。后半句是指指令重排现象和工作内存与主内存的同步延迟想象。</p><h2 id="第十三章-线程安全与锁优化"><a href="#第十三章-线程安全与锁优化" class="headerlink" title="第十三章 线程安全与锁优化"></a>第十三章 线程安全与锁优化</h2><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li>互斥同步</li></ul><p>synchronize 关键字经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。</p><p>synchronize 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。Java 线程是映射到操作系统的原生线程之上的，如果阻塞或唤醒一个线程，都需要从用户态转换到核心态中，需要耗费很多处理器时间。除了 synchronize 之外，还可以使用 reentrantLock 重入锁来实现同步。</p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，非公平锁则是靠抢占的。</p><h3 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h3><p>如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也是线程安全的。</p><h3 id="自旋锁与自适应锁"><a href="#自旋锁与自适应锁" class="headerlink" title="自旋锁与自适应锁"></a>自旋锁与自适应锁</h3><p>共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这就是所谓的自旋锁。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机监测到有这样一段零碎的操作都对同一对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁可以提高带有同步但无竞争的程序性能。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第二章-Java-内存区域与内存溢出溢出&quot;&gt;&lt;a href=&quot;#第二章-Java-内存区域与内存溢出溢出&quot; class=&quot;headerlink&quot; title=&quot;第二章 Java 内存区域与内存溢出溢出&quot;&gt;&lt;/a&gt;第二章 Java 内存区域与内存溢出溢出&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://yazhidev.github.io/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://yazhidev.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>点名小辣辣，带你入门 JMeter (｡･∀･)ﾉﾞ</title>
    <link href="https://yazhidev.github.io/2018/10/12/%E7%82%B9%E5%90%8D%E5%B0%8F%E8%BE%A3%E8%BE%A3%EF%BC%8C%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-JMeter-%EF%BD%A1%EF%BD%A5%E2%88%80%EF%BD%A5-%EF%BE%89%EF%BE%9E/"/>
    <id>https://yazhidev.github.io/2018/10/12/点名小辣辣，带你入门-JMeter-｡･∀･-ﾉﾞ/</id>
    <published>2018-10-12T08:21:15.000Z</published>
    <updated>2022-06-07T22:58:54.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-JMeter"><a href="#什么是-JMeter" class="headerlink" title="什么是 JMeter"></a>什么是 JMeter</h2><p>Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测 试但后来扩展到其他测试领域。 它可以用于测试静态和动态资源例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、 数据库， FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来在不同压力类别下测试它们的 强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>因为 JMeter 是基于 Java 开发的，所以首先要用 Java 环境。Java 的环境配置这里就不展开了。</p><p><a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">JMeter 官网地址</a> </p><p><a href="http://mirrors.shu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.0.tgz" target="_blank" rel="noopener">下载 JMeter 5.0 (Requires Java 8 or 9.)  / Binaries /<br>apache-jmeter-5.0.tgz</a></p><p>下载完成后解压，进入 bin 目录，运行命令 <code>sh jmeter</code> 即可打开图形页面。</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-d58ed596881303e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jmeter"></p><p>顺便提一下，从上面的命令可以看出，jmeter 文件本质上是一个 shell 脚本，我们使用文本编辑器打开可以看到，其最后执行了 <code>&quot;$JAVA_HOME/bin/java&quot; $ARGS $JVM_ARGS $JMETER_OPTS -jar &quot;$PRGDIR/ApacheJMeter.jar&quot; &quot;$@&quot;</code>，所以该脚本的作用只是一个预置的配置文件，真正打开的是 ApacheJMeter.jar 这个 jar 包。</p><p>接下来通过一个简单的测试项目来进一步了解一下 JMeter。</p><p>首先不深入到具体的细节，先宏观了解一下 JMeter 里定义任务的结构。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/1929170-c8cc02b934b17fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作目录"></p><h4 id="TestPlan"><a href="#TestPlan" class="headerlink" title="TestPlan"></a>TestPlan</h4><p>最外层的 Test Plan（测试计划），右键可以看到可添加的配置：</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-03317dadcf7d7307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试计划"></p><p>可以看到 TestPlan 里包含了 ThreadGroup（线程组）、Config（用户自定义的配置）。<br>另外还可以添加例如 Listener（测试结果报告等），以及我还没接触过的，但是从名字上看可能是轮询/计时器、以及对测试任务的前置后置处理等等，这些也是其他几种目录都可以添加的功能。</p><h4 id="ThreadGroup"><a href="#ThreadGroup" class="headerlink" title="ThreadGroup"></a>ThreadGroup</h4><p><img src="https://upload-images.jianshu.io/upload_images/1929170-0380785ef660e88d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程组"></p><p>线程组里可以添加 Sampler（我将其理解为具体的测试用例，比如下面会介绍到的 HTTP 测试，就是添加 HTTP request Sampler）。一个线程组可以包含多个测试用例，并且可以自定义（同时运行的）线程数量、运行间隔等，这些配置也是压力/疲劳测试必不可少的组成部分。</p><h4 id="Sampler"><a href="#Sampler" class="headerlink" title="Sampler"></a>Sampler</h4><p><img src="https://upload-images.jianshu.io/upload_images/1929170-6d649a14deb25a26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sampler"></p><p>具体的用例里则可以添加断言，来获取期望测试结果等。</p><p>接下来在具体的业务中上手试一下 JMeter 吧~</p><h2 id="HTTP-接口测试"><a href="#HTTP-接口测试" class="headerlink" title="HTTP 接口测试"></a>HTTP 接口测试</h2><h3 id="线程组配置"><a href="#线程组配置" class="headerlink" title="线程组配置"></a>线程组配置</h3><ol><li><p>添加一个线程组<br> 右键 TestPlan，如下添加线程组</p><p> <img src="https://upload-images.jianshu.io/upload_images/1929170-486819a703f97b87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加线程组"></p><p> <img src="https://upload-images.jianshu.io/upload_images/1929170-efd53a8ee0a6d4be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程组配置"></p><p> 简单解释一下各个参数：</p><ul><li>Number of Thread<br>  线程（用户）的数量</li><li>ramp-up period(in second)<br>  使用多长的时间启动所有线程（比如 10 个线程，这里填了 10 秒，即每秒启动一个线程），默认为 0，即立即启动所以线程</li><li>Loop count<br>  循环次数（勾选 Forever 即为无限循环）</li></ul></li></ol><ol start="2"><li><p>在线程组中添加一个用例（http 请求）</p><p> <img src="https://upload-images.jianshu.io/upload_images/1929170-cd8756c0cc66e9a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="http 请求"></p><p> 配置 http 接口</p><p> <img src="https://upload-images.jianshu.io/upload_images/1929170-f1644b015bd1656e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="http 配置"></p></li></ol><ol start="3"><li><p>添加结果报告</p><p> <code>Result Tree</code>  中可以看到每次运行的请求、响应的数据等。<br> <code>Summary Report</code> 可以查看运行结果报告，包括平均响应时间（Avarage）、最快响应时间（Min）、最大响应时间（Max）、错误率、吞吐量（Throughput）等等</p><p> <img src="https://upload-images.jianshu.io/upload_images/1929170-96ca3e0362d9220d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result tree"></p><p> <img src="https://upload-images.jianshu.io/upload_images/1929170-4f50aa39e861d5fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="summary report"></p><p> <img src="https://upload-images.jianshu.io/upload_images/1929170-00852895481412d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="report"></p></li></ol><p>以上配置后，点击工具栏的绿色运行按钮，可以在结果报告中看到用例的执行结果了。</p><p>以上的配置，请求中携带的参数是我们预先配置好的，但是一般登录接口中携带的参数，例如用户名、密码等不可能是固定的。那么如何配置多个用户的参数，然后在运行测试时自动填入呢？</p><h3 id="多用户配置"><a href="#多用户配置" class="headerlink" title="多用户配置"></a>多用户配置</h3><p>首先创建一个用户列表的文本，内容如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15659828000,123456</span><br><span class="line">15654545454,123456</span><br></pre></td></tr></table></figure><p>每行都代表了一位用户，用户名、密码以英文逗号分隔。然后在 JMeter 中生成函数读取该文本的内容。点击如下图圈中的图标打开函数助手：</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-2b070ca808e0d60e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CSV Reader"></p><p><code>Choose a function</code> 选择 –CSVRead，第一行 <code>CSV file to get values from | *alias</code> 后面填入用户账号列表的文件地址，第二行 <code>Column number of CSV file | next | *alias</code>  后面先填 0（即获取每行的第一个参数，即用户名），然后点击下方的按钮 <code>Generate &amp; copy to clipboard</code>，就会看到按钮左侧生成了一串形如 <code>${__CSVRead(/Users/zengyazhi/Downloads/apache-jmeter-5.0/backups/users.txt,0)}</code> 的函数（并且已自动复制到剪贴板），下方也显示出了该函数所取到的值。接下来只要在 http 接口配置的地方填入该函数即可。</p><p><strong>需要注意的是</strong>：该函数看起来很好理解，无非就是去读取某个文件里的第几个值，我在测试的时候只生成了一次，后续密码的那栏我直接将 0 改成 1，结果却读不到对应的值。所以记得有几个值就要使用函数助手生成几次。</p><p>另外还有人提到了使用 <code>badboy</code> 来配置多用户。</p><blockquote><p>使用 badboy 录制 Jmeter 脚本，badboy 录制的脚本比 Jmeter 自己运行的 Http 请求要有更多的参数，比如图形验证码、服务器名称或 IP 会自动加载，无需手写。另外自动加载 Http Cookie 管理器、用户定义的变量、HTTP信息头管理器，以及 Http 请求。</p></blockquote><p>除此之外，Badboy 还可以模拟浏览器操作，记录操作脚本，再配合 JMeter 做压测等等，这里就不展开了。</p><p>更多介绍见官网文档 <a href="http://www.badboy.com.au/" target="_blank" rel="noopener">Badboy software</a></p><h3 id="全局变量配置"><a href="#全局变量配置" class="headerlink" title="全局变量配置"></a>全局变量配置</h3><p>Http 接口一般都存在环境的区别，例如线下环境、生产环境等，如果直接把对应的 host 直接填在上述的 http 配置中，当需要切换环境时岂不是要改到怀疑人生？所以配置全局变量是必不可少的。</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-eaea3ff816d63fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全局变量"></p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-693e00626eff8770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config"></p><p>也很简单，添加对应的 key-value 即可。例如定义了 host = “dev.test.cn”，在配置 http 接口时，域名一栏填入 ${host} 就可以了。</p><p>以上只是简单上手试用下 JMeter，更多功能可能要在对应的业务中才会接触到。</p><p>差不多就是这样啦。nana 你在看吗？ ღ( ´･ᴗ･` )比心~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-JMeter&quot;&gt;&lt;a href=&quot;#什么是-JMeter&quot; class=&quot;headerlink&quot; title=&quot;什么是 JMeter&quot;&gt;&lt;/a&gt;什么是 JMeter&lt;/h2&gt;&lt;p&gt;Apache JMeter是Apache组织开发的基于Java的压力测试工具
      
    
    </summary>
    
    
      <category term="JMeter" scheme="https://yazhidev.github.io/tags/JMeter/"/>
    
      <category term="软件测试" scheme="https://yazhidev.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap 图像灰度变换原理浅析</title>
    <link href="https://yazhidev.github.io/2018/09/02/Bitmap%20%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <id>https://yazhidev.github.io/2018/09/02/Bitmap 图像灰度变换原理浅析/</id>
    <published>2018-09-01T16:39:13.000Z</published>
    <updated>2022-06-07T22:58:54.436Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章<a href="[https://yazhidev.github.io/2018/09/01/%E6%8B%A5%E6%8A%B1-C-C-Android-JNI-%E7%9A%84%E4%BD%BF%E7%94%A8/](https://yazhidev.github.io/2018/09/01/拥抱-C-C-Android-JNI-的使用/">《拥抱 C/C++ : Android JNI 的使用》</a>)里提到调用 native 方法直接修改 bitmap 像素缓冲区，从而实现将彩色图片显示为灰度图片的方法。这篇文章将介绍该操作的实现原理。</p><p>开始先不讲关于 Bitmap 的相关细节，先从计算机底层存储与运算原理讲起。总所周知，计算机只识别 0 和 1，无论是八进制、十进制、十六进制，在底层都会被转换为二进制。有几个单位与概念要提及一下：</p><h2 id="计量单位"><a href="#计量单位" class="headerlink" title="计量单位"></a>计量单位</h2><h3 id="bit（位）"><a href="#bit（位）" class="headerlink" title="bit（位）"></a>bit（位）</h3><p>计算机表示信息的最小单位，也是最小的存储单位，只有两种状态：0 和 1。即二进制位。</p><p>平时常见的 32 位处理器就是一次最多能处理 32 位的数据，也就是 4 个 byte（字节）。同理，64 位处理器一次最多能处理 64 位的数据，即 8 个字节。</p><h3 id="byte（字节）"><a href="#byte（字节）" class="headerlink" title="byte（字节）"></a>byte（字节）</h3><ul><li>1 KB = 1024 Byte</li><li>1 MB = 1024 KB</li><li>1 GB = 1024 MB</li></ul><p>通常一个字节由 8 个二进制位（bit）组成。</p><p>一个十六进制数需要由 4 个二进制组成，即一个字节可以标识 2 个十六进制数。</p><h3 id="基本数据类型的长度"><a href="#基本数据类型的长度" class="headerlink" title="基本数据类型的长度"></a>基本数据类型的长度</h3><p>对 C/C++ 而言，不同的操作平台分配给基本数据类型的长度（字节）是不一样的，比如 <code>char*</code> 指针变量在 32 位编译器里是 4 个字节（32 位的寻址空间是 2^32, 即 32 个 bit，也就是 4 个字节。64 位编译器同理），在 64 位编译器里是 8 个字节。</p><p>而 Java 是跨平台语言，JVM 里的基础数据类型的字节长度是一致的。各基本数据类型长度如下：</p><blockquote><p>int：4 个字节<br>short：2 个字节。<br>long：8 个字节。<br>byte：1 个字节。<br>float：4 个字节。<br>double：8 个字节。<br>char：2 个字节。<br>boolean：boolean 属于布尔类型，在存储的时候不使用字节，仅使用 1 位来存储，范围仅为 0 和 1，其字面量为 true 和 false。</p></blockquote><h3 id="基本数据类型的取值范围"><a href="#基本数据类型的取值范围" class="headerlink" title="基本数据类型的取值范围"></a>基本数据类型的取值范围</h3><p>以最常见的 int 为例，Java 中 int 是 4 个字节，那 int 的取值范围是多少呢？熟悉 api 的同学都知道，<code>Integer</code> 类里定义了 <code>MAX_VALUE = 0x7fffffff</code>，那就来推算一下 Java 定义的这个值对不对（大雾</p><p>int 占 4 个字节 32 位，因此就是 8 位数的十六进制。因为 int 值有正负之分，所以最高位表示符号，0 代表正数，1 代表负数。显而易见，int 能表示的最大值的二进制为 0111 1111 1111 1111 1111 1111 1111 1111 ，最高位 0，后面跟 31 个 1。换算成十六进制就是 0x7FFFFFFF，该值与 Jdk 中定义的相同，可见 Jdk 还是很严谨的（2333），Java 大法好！同理，最小值的二进制为 1111 1111 1111 1111 1111 1111 1111，换算成十六进制就是 0xFFFFFFFF，再对照一下 Jdk 中定义的最小值 <code>MIN_VALUE = 0x80000000</code>。纳尼？Jdk 有 bug！（2333）</p><p>想都不用想，肯定是我自己有 bug，那为什么推算出的和 Jdk 中定义的不符呢。其实是二进制表示方法不对而已。二进制除了上述可直观计算得出的逢二进一的原码外，另外还有几种表示方法。</p><h3 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h3><p>原码很直观易懂，但也有其缺点，就比如最高位为符号位为这个槽点，就诞生了 0000 ~ 0000，1000 ~ 000，分别代表 +0 和 -0。至于数学里有没有 +0 和 -0，二者参与运算是怎么个计算法，我读书少我也不清楚。但这说明了一个问题，使用原码存储和运算会存在二义性。计算机在运算时使用的并非原码而是补码。补码和反码的计算公式如下：</p><ul><li><p>正数<br>  原码、反码、补码都相同</p></li><li><p>负数<br>  反码：原码保留符号位，其他位取反<br>  补码：反码+1</p></li><li><p>补码转原码<br>如果符号位为1，其余各位取反，然后再整个数加1。</p></li></ul><p>上面提到的 +0 （0000 ~ 0000），其补码也为 000 ~ 0000，而 -0（1000 ~ 0000），其反码为 1111 ~ 1111，补码为反码 + 1 ，为 0000 ~ 0000，可见补码消除了关于 0 的二义性，使用补码并不会存在两个 0。</p><p>回到上面推算的 int 值得最小值 1111 ~ 1111，其反码为 1000 ~ 0000，补码为 1000 ~ 0001，转换为十六进制为 0x80000001。而这与 Jdk 规定的最小值 <code>MIN_VALUE = 0x80000000</code> 并不相同，说明还遗漏了什么。再回看补码，除了消除二义性，还有个好处是可以把减法当做加法。都知道 01111 ~ 1111 代表正数的最大值，最高位只代表符号，那么将其由 0 变 1，用 1111 ~ 1111 来代表负数的最大值从某种角度上也说得通，<code>补码（1111 ~ 1111）</code> =  <code>十进制（-1）</code>，将 <code>补码（1111 ~ 1111）</code> 往前迭代 1 位（做 + 1 的运算），舍弃溢出位，得到 <code>补码（0000 ~ 0000）</code> =  <code>十进制（0）</code>，符合 -1 + 1 = 0 的运算结果。将 <code>补码（1111 ~ 1111）</code> 往后迭代 1 位，得到 <code>补码（1111 ~ 1110）</code>  =  <code>原码（1000~ 0010）</code> =  <code>十进制（-2）</code>，符合 -1 - 1 = -2 的运算结果。则同理，将负数最大值 <code>补码（1111 ~ 1111）</code> 一直往后迭代，直到无法再小，则最小值应为 <code>补码（1000 ~ 000）</code> = <code>原码（1000 ~ 000）</code> = <code>十进制（-0）</code> = <code>十六进制（0x80000000）</code>。也就是原码空出来的那个代表 -0 的数，被计算机用来表示 int 的最小值。</p><h2 id="Bitmap-像素"><a href="#Bitmap-像素" class="headerlink" title="Bitmap 像素"></a>Bitmap 像素</h2><p>提及 Bitmap ，先介绍一下 Android 中<code>Bitmap</code> 类中定义的枚举类 <code>Config</code> 里的几个值，也是比较多见的 Android 中的 Biamap 显示参数。</p><h3 id="Bitmap-参数"><a href="#Bitmap-参数" class="headerlink" title="Bitmap 参数"></a>Bitmap 参数</h3><ul><li><p>ARGB_4444<br>  四个通道 A（透明度）、R（红色）、G（绿色）、B（蓝色）各占 4 位，总共 16 位，即每个像素占用 2 个字节。</p></li><li><p>ARGB_8888<br>  四个通道各占 8 位，总共 32 位，每个像素占用 4 个字节。因为 RGB 通道精度更高，所以颜色显示更丰富，同时占用内存也更大。</p></li><li><p>RGB_565<br>  没有透明度信息，RGB 通道各占用 5 位、6 位、5 位，总共 16 位，每个像素占用 2 个字节。</p></li></ul><p>知道了每个像素占用的字节长度，就可以计算一张图片显示时所占用的内存大小，以 ARGB_8888 为例，一张像素为 16 <em> 16 的图片占用的内存为：16 </em> 16 * 4 = 1024 byte，即 1 KB。</p><p>轻松愉快又简单！可梦想很美好，显示很骨感。在 Android 中，在不压缩计算的情况下（例如显示 assets 目录下的图片），内存大小就是上面计算所得，但因为 Android 中的图片一般存放在不同的资源目录:</p><blockquote><p>资源目录对应的 dpi<br>mdpi -&gt; 120 dpi<br>mdpi -&gt; 160 dpi<br>hdpi -&gt; 240 dpi<br>xdpi -&gt; 320 dpi<br>xxdpi -&gt; 480 dpi<br>xxxdpi -&gt; 640 dpi </p></blockquote><p>Android 中显示不同的资源目录图片时，会对图片做缩放处理，缩放比例为 <code>设备dpi / 资源目录对应 dpi</code>，以 小米8SE 为例，设备屏幕密度为 440 dpi，该设备显示存放在 xxdpi（480dpi）目录中的像素为 300 <em> 300 的图片时，实际显示图片的宽和高将换算为 `440 / 480 </em> 300 ` （结果<strong>四舍五入</strong>），计算得到图片在手机显示的宽高为 275，再根据计算所得实际的图片宽高计算所占内存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">275 * 275 * 4 = 302500（byte）</span><br></pre></td></tr></table></figure><p>可以调用 <code>Bitmap</code> 类自带的方法 <code>getByteCount()</code> 方法验证一下。</p><p>顺带提一下，Android 中 Bitmap 的占用内存大小与显示图片的容器（例如 Android 上的 ImageView）尺寸无关。</p><h3 id="Bitmap-像素的定义"><a href="#Bitmap-像素的定义" class="headerlink" title="Bitmap 像素的定义"></a>Bitmap 像素的定义</h3><p>介绍完 Bitmap 内存占用大小后，回到 Bitmap 本身来。Bitmap 将图像定义为由像素组成，以 ARGB_8888 为例，上面提到过，A/R/G/B 各占 8 位，各由两个十六进制数表示，依次排列，比如常见的色值 #FF234567，即各通道值为：透明度 alpha 0xFF，红色 red 0x23，绿色 green 0x45，蓝色 blue 0x67。</p><p>因此一张分辨率 100 <em> 100 的彩色图片，无非就是 100 </em> 100 个像素，每个像素显示对应的颜色，所有像素组合在一起便成了彩色的图片。所以只要拿到了 Bitmap，想要如何修改图像的显示，只要对各个像素显示的颜色做相应的处理就好了。</p><p>彩色转换为灰色的计算方式暂且不提。要改变图像的显示，首要任务是获取到各像素点的颜色。</p><p>Android 中可以调用 <code>Bitmap</code> 类自带的方法获取到具体某个点的像素颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int color = bitmap.getPixel(200, 300);</span><br></pre></td></tr></table></figure><p>那么问题来了，如何才能从一个 int 值中获取各个通道（RGB）的颜色呢？</p><h3 id="从像素中提取各通道色值"><a href="#从像素中提取各通道色值" class="headerlink" title="从像素中提取各通道色值"></a>从像素中提取各通道色值</h3><p>老司机们可能秒懂，这个简单，<code>Color</code> 类自带的方法就可以做到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int redColor = Color.red(color);</span><br></pre></td></tr></table></figure><p>再看一下该方法的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@IntRange(from = 0, to = 255)</span><br><span class="line">public static int red(int color) &#123;</span><br><span class="line">    return (color &gt;&gt; 16) &amp; 0xFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实计算方法也很简单，用到了位运算，那就顺带回顾一下位运算。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>从最低位到最高位一一对齐，每一位都做运算（也是对补码做运算），各运算符含义如下：</p><ul><li><code>&amp;</code> 与<br>都是 1，则结果为1。否则为 0。</li><li><code>|</code> 或<br>都是 0，则结果为0。否则为 1。</li><li><code>~</code> 取反<br>对数的每一位取反。</li><li><code>^</code> 异或<br>数值相同，则结果为 0，不为 1。</li><li><code>&gt;&gt;</code>右移<br>从 0 位起整体向右移动，空出的高位正数补 0，负数补1。</li><li><code>&gt;&gt;&gt;</code> 无符号右移<br>从 0 位起（连符号位）整体向右移动，空出的高位一律补 0。<br>对于正数而言，&gt;&gt;和&gt;&gt;&gt;没区别。</li><li><code>&lt;&lt;</code> 左移<br>整体向左移动，右边的空位一律补 0。</li></ul><p>现在再来回看上面提到的取色方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Color</span><br><span class="line">public static int red(int color) &#123;</span><br><span class="line">    return (color &gt;&gt; 16) &amp; 0xFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还以 <code>#FF234567</code> 为例，转换为二进制为<br><code>1111 1111 | 0010 0011 | 0100 0101 | 0110 0111</code> （这里我用了 <code>|</code> 符号方便划分），其中 第二阵列 <code>0010 0011</code>，即右起第 17 ~25 位代表红色色值。将二进制右移 16位，等同于舍弃了红色右边 的 16 位用于存储绿色、蓝色的色值，得到 <code>0000 0000 | 0000 0000 | 1111 1111 | 0010 0011</code>，再与 <code>0xFF</code> 即二进制 <code>1111 1111</code> 做与运算，运算时高位为空则补0，与 0 做 <code>&amp;</code>与运算结果必为0，等同于与舍弃了右边代表透明度的高八位，最终得到红色的色值 <code>0010 0011</code>。</p><p>取红色色值也还有另一种解法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(color &amp; 0x00FF0000) &gt;&gt; 16</span><br></pre></td></tr></table></figure><p>先和 <code>0x00FF0000</code> 做与运算，舍弃除红色外所有色值，再右移 16 位得到该值。这种解法与上述的只不过是运算顺序不同，殊途同归。</p><p>至此，获取到了色值，想要怎么改变图片的显示就是算法上的事了，各凭本事各显神通。</p><p>今天的分享就到这，如有纰漏欢迎指正，下篇博客见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章&lt;a href=&quot;[https://yazhidev.github.io/2018/09/01/%E6%8B%A5%E6%8A%B1-C-C-Android-JNI-%E7%9A%84%E4%BD%BF%E7%94%A8/](https://yazhidev.git
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
