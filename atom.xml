<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>美丽新世界</title>
  <icon>https://www.gravatar.com/avatar/7e3d2d69172a3a1a291da558f2ac4b01</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yazhidev.github.io/"/>
  <updated>2022-06-07T23:54:53.293Z</updated>
  <id>https://yazhidev.github.io/</id>
  
  <author>
    <name>Taki</name>
    <email>yazhidev@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每个开发都应该懂的正则表达式</title>
    <link href="https://yazhidev.github.io/2022/03/08/%E6%AF%8F%E4%B8%AA%E5%BC%80%E5%8F%91%E9%83%BD%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://yazhidev.github.io/2022/03/08/每个开发都应该懂的正则表达式/</id>
    <published>2022-03-07T23:13:37.000Z</published>
    <updated>2022-06-07T23:54:53.293Z</updated>
    
    <content type="html"><![CDATA[<p>在日常工作中，相信每个开发都接触过一些检索、替换字符串/文本的问题。对于一些简单的问题例如查找字符串中是否存在某个子串，可能直接使用各类开发语言自带的 api 接口就可以很方便地实现。但是一旦规则复杂起来可能就会比较棘手，例如校验邮箱、手机号、版本号等，如果自行实现可能需要写不少逻辑代码，正则表达式就是为了解决这类问题的。举个例子，以下是 CI 构建组件时对版本号的校验，你能够快速读懂其规则吗？如果你对此不甚了解，那相信这篇文章一定能给你带来一些收获。</p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607162137759-133720640.png" alt="版本号校验"></p><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p>如上图所示，正则表达式就是一串字符<code>/^[0-9]+.[0-9].+[0-9]+$/</code>，正则表达式规定了由一个或几个特殊的字符组合成一个规则，并且多个规则可以自由组合。</p><p>在学习正则表达式时，不要被表达式里的特殊符号所迷惑，觉得看起来好复杂，其实说白了这些字符只是一些规则的映射而已，并且需要注意的是，如果字符串里使用到这些符号还需要转义。</p><p>常见的字符有 <code>* . ? + ^ - $ | \ / [ ] ( ) { }</code>。另外有的开发语言在使用时需要将正则表达式使用 / 符号抱起来，形如 /xxx/，这个了解下即可。</p><p>既然正则表达式由一系列规则组成，每个规则都描述了一套匹配的逻辑，那么学习正则表达式其实就是在学习这些匹配规则。让我们先从最直观的匹配字符开始入手。在开始之前，推荐大家两个网站，一个是用于测试的 <a href="https://tool.oschina.net/regex" target="_blank" rel="noopener">正则表达式规则测试</a>，一个<a href="https://regexper.com/#" target="_blank" rel="noopener">正则表达式图形化工具</a>，便于我们理解。</p><h2 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h2><h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><p>例如从 abcde 里寻找 abc，那么很明显，我们的匹配规则就是需要精确匹配 abc，其规则自然就是 abc。这个不多赘述。</p><h3 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h3><p>除了精确匹配以外，我们可能还需要一些模糊的规则，以便于发现/容纳更多可能。比如我们需要某处的字符是可变的，或者我们对于某处的字符数量不确定。因此就产生了横向和纵向两种字符模糊匹配。</p><h4 id="横向（字符次数匹配）"><a href="#横向（字符次数匹配）" class="headerlink" title="横向（字符次数匹配）"></a>横向（字符次数匹配）</h4><p>某处的字符数量可变，可以使用次数匹配规则。</p><p>常见的次数匹配规则有：</p><ul><li>{n}：限定n次</li><li>{m,n}：上下限次数（闭区间）</li><li>+：一次或多次，等效于 {1,}</li><li>？：零次或一次，等效于 {0,1}</li><li>*：任意多次</li></ul><p>这些规则跟在某个字符后面，代表规则前面的字符长度可变。</p><p>例如正则表达式： a{2,3}c，代表 a 字符出现2次或3次，例如 aac、aaac 都是可以匹配的。但是 ac 是无法匹配的。</p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607162451369-1690426277.png" alt="正则"></p><h4 id="纵向"><a href="#纵向" class="headerlink" title="纵向"></a>纵向</h4><p>某处的字符可变，比如需要匹配 dog 和 log。第一个字符有多种可能。</p><p>常见的字符可变规则有：</p><ul><li>. ：点代表任意字符</li><li>| ：或匹配。可以配合 () ，将多个子表达式组合</li><li>[]：区间里的字符都是允许的，例如 [123]，代表该处的字符可以是 1 或 2 或 3</li><li>-：区间里使用，表示范围，例如 [1-3] 等同于 [123]，[a-z] 代表所有小写英文字母</li><li>^：区间里使用，表示取反，例如 [^1-3] 代表除了 1、2、3 以外的字符<br>这些规则放在某处，代表某处的字符是可变的。</li></ul><p>例如  [dl]og ，代表中括号处（第一个字符）可以是 d 或 l，因此 log、dog 都是可以匹配的</p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607162531592-966771931.png" alt="正则"></p><p>除此之外，还会有一些常用的简写：</p><ul><li>\d：数字</li><li>\D：非数字</li><li>\w：数字大小写下划线，等同于 [0-9a-zA-Z_]​</li><li>\W：非单词字符，等同于 [^0-9a-zA-Z_]</li><li>\s：空白字符，包括空白、tab、换行</li></ul><h2 id="匹配位置"><a href="#匹配位置" class="headerlink" title="匹配位置"></a>匹配位置</h2><p>一个字符串，除了我们最直观看到字符以外，其实还暗含了许许多多的位置。这也是正则匹配的另一大块。什么是位置？首先用一张图来表示：</p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607162626485-947049259.png" alt="位置"></p><p>如图所示，一个字符串 hello，除了五个字符以外，每个字符首尾都有一个位置，这些位置都可以被匹配规则所扫描到。</p><p>常用的匹配位置的符号有：</p><ul><li>^ ：代表一行的开头</li><li>$ ：代表一行的结尾</li><li>\b：单词边界。具体就是单词字符和非单词字符之间的位置。包括非单词字符和开头、结尾之间的位置</li><li>\B：非单词边界</li></ul><p>可能有人对匹配位置的用法不太了解，举个例子，有一个字符串 123123，这时候如果你使用精确匹配规则 123，那么会匹配到两个123。但是如果配合 ^ 使用，将规则修改为 ^123，那么就只会匹配到第一个开头的 123，后续的 123 则不会被匹配到。</p><p>除此之外，关于匹配位置还有一个很灵活的特性：前瞻后顾</p><p>相关的规则有：</p><ul><li>exp1(?=exp2)​：前瞻，查找后面是exp2的exp1 = 查找exp2前面的exp1​（exp1、exp2 代表一个表达式）</li><li>(?&lt;=exp2)exp1：后顾，查找exp2后面的exp1​</li><li>exp1(?!exp2)：负前瞻，查找后面不是exp2的exp1​</li><li>(?&lt;!exp2)exp1：负后顾：查找前面不是exp2的exp1​</li></ul><p>这个在过滤日志时十分有用。例如有一些重复关键字的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">receive some error</span><br><span class="line">receive yuv</span><br><span class="line">receive yuv</span><br><span class="line">receive yuv</span><br><span class="line">receive yuv</span><br><span class="line"></span><br><span class="line">//receive(?! yuv)</span><br><span class="line">可以使用负前瞻过滤掉一些不想要的日志。只会匹配到 receive some error 这一行的 rece</span><br></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>在对正则表达式有个大致的认识后，让我们回到文章的开头，看一下文章开头的版本号验证正则表达式代表什么含义：<code>^[0-9]+.[0-9].+[0-9]+$</code></p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607162758899-66629481.png" alt="正则"></p><p>这里可以明显看出是有问题的，例如表达式里的 . 应该需要转义，否则就代表任意字符，这明显不符合版本号要求。经过确认后得知是前端显示问题，并了解到他们实际校验使用的正则表达式是：<code>^\d+\.\d+\.(\d+\.)*\d+((-rc\.\d+)|(\d*))$</code></p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607162831138-1197056065.png" alt="正则"></p><p>在对正则规则有个大致了解后，借助图形化工具可以很方便地了解正则表达式规则所代表的含义。<br>例如 1.1.1.1.1 这样的版本号也是允许的，经了解 CI 之前有特殊原因没限制版本号一定是 3 位。并且可以看到除了 rc 字符以外，不允许其他英文字母。<br>但同时我们也会发现另一个小问题，那就是类似 01.1.1 这样的版本号也是被允许的：<br>如果让你来优化会怎么做呢？我认为优化后的规则可以这么写：<code>^(0\.|[1-9][0-9]*\.)\d+\.(\d+\.)*\d+((-rc\.\d+)|(\d*))$</code>。<br>使用<code>(0\.|[1-9][0-9]*\.)</code>限制要么是0，要么是非0的两位以上数字，即可过滤 01.1.1 这样的不合理版本号。</p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607162925232-1750092847.png" alt="优化后的正则"></p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607162939541-23603090.png" alt="正则校验"></p><p>相信看到这里，大家都对正则表达式有了一个大致的了解。对于正则表达式还有一些特性（例如捕获、贪婪等）没有提及，这里抛砖引玉，感兴趣的小伙伴可以自行了解。<br>有了正则表达式的帮助可以让我们少写很多字符串判断逻辑的代码，除了让代码更简洁以外，也会大大提高代码的可读性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常工作中，相信每个开发都接触过一些检索、替换字符串/文本的问题。对于一些简单的问题例如查找字符串中是否存在某个子串，可能直接使用各类开发语言自带的 api 接口就可以很方便地实现。但是一旦规则复杂起来可能就会比较棘手，例如校验邮箱、手机号、版本号等，如果自行实现可能需要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊 Android App Bundle</title>
    <link href="https://yazhidev.github.io/2021/10/10/%E8%81%8A%E8%81%8A-Android-App-Bundle/"/>
    <id>https://yazhidev.github.io/2021/10/10/聊聊-Android-App-Bundle/</id>
    <published>2021-10-09T23:54:15.000Z</published>
    <updated>2022-06-08T00:00:00.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Android-App-Bundle"><a href="#什么是-Android-App-Bundle" class="headerlink" title="什么是 Android App Bundle"></a>什么是 Android App Bundle</h2><p>关于 Android App Bundle（下文简称 aab），引用以下官方的定义：</p><blockquote><p>Android App Bundle 是一种发布格式，其中包含您应用的所有经过编译的代码和资源，它会将 APK 生成及签名交由 Google Play 来完成。Google Play 会使用您的 App Bundle 针对每种设备配置生成并提供经过优化的 APK，因此只会下载特定设备所需的代码和资源来运行您的应用。您不必再构建、签署和管理多个 APK 来优化对不同设备的支持，而用户也可以获得更小且更优化的下载文件包。</p></blockquote><p>从 2021 年 8 月起，新应用需要使用 Android App Bundle 才能在 Google Play 中发布。因此对开发者来说，了解什么是 aab 非常重要。</p><h2 id="如何构建-aab"><a href="#如何构建-aab" class="headerlink" title="如何构建 aab"></a>如何构建 aab</h2><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607164932235-1692310588.png" alt="构建 aab"></p><p>像 CI、脚本等环境使用命令行构建，可以使用 Gradle 命令打包 debug 版本的 aab 包：<code>./gradlew bundleDebug</code></p><p>aab 严格上来说是一种发布格式，真正在安装 app 时还是使用 apk 包。只是借助于 aab 这种发布格式，Google Play 提供了按条件分发或按需下载应用的某些功能。</p><h2 id="动态下发能力"><a href="#动态下发能力" class="headerlink" title="动态下发能力"></a>动态下发能力</h2><p>提到动态下发，大家可能首先会想到热修复。业内的热修复方案使用的比较多的是类加载方案，基于 dex 分包，从 Java 类加载机制作为切入点，将需要动态下发（修复）的代码打成 dex 包或者通过算法合成差量 dex 包下发至客户端，并在下次 APP 启动时优先加载新的修复过的类，Java 类加载机制会保证旧的类不再被加载，从而实现动态修复的效果。</p><p>Google Play 的动态下发方案有别于热修复，它不适用于对已有代码的动态修改，它更像一种插件化方案，借助于 aab 包的格式，将原来一个庞大的 apk 按照不同的维度拆分成独立的 apk，当用户在 Google Play 商店下载应用时，Android 系统通过与 Google Play 商店通信，为当前设备匹配并下载最小的 apk，从而实现更快的下载速度。</p><p>不仅如此，借助于 Dynamic Feature 的特性，配合 com.google.android.play:core 组件的动态加载代码功能（详见 <a href="https://developer.android.google.cn/guide/app-bundle/dynamic-delivery#dynamic_feature_modules" target="_blank" rel="noopener">Play Feature Delivery</a> ），还可以实现按需下载模块，实现真正的插件化。</p><p>那么 aab 是如何为插件化方案助力的呢？</p><h2 id="创建功能模块"><a href="#创建功能模块" class="headerlink" title="创建功能模块"></a>创建功能模块</h2><p>首先我们创建一个功能模块（Dynamic Feature）看一下效果，在 Android Studio 中新建模块时选择 Dynamic Feature Module：</p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607165045311-359794394.png" alt="功能模块"></p><p>这里我们添加一个名为 dynamicfeature 的模块。通过这种方式添加的模块，Android Studio 会自动对该模块的 build.gradle 应用插件 apply plugin: ‘com.android.dynamic-feature’ 用于编译功能模块。</p><p>我们打出 aab 包看下添加了功能模块之后的包结构和普通的模块有什么不同：</p><p>﻿<img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607165059085-377360846.png" alt="模块结构"></p><p>对比一下 apk 格式：</p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607165116221-1332567525.png" alt="apk 格式"></p><p>可以看到 aab 格式和传统的 apk 格式有以下几个区别：</p><table><thead><tr><th></th><th>aab 格式</th><th>apk 格式</th></tr></thead><tbody><tr><td>模块划分</td><td>分为 base 模块和 dynamic feature 模块。</td><td>无模块划分</td></tr><tr><td>manifest.xml</td><td>每个模块都有一个</td><td>只有一个</td></tr><tr><td>dex</td><td>每个模块的 dex 存储在各自模块的目录中</td><td>全部存放于根目录</td></tr><tr><td>资源索引表</td><td>resources.pb，使用 ProtoBuf 协议格式，每个模块都有一个</td><td>resource.arsc</td></tr></tbody></table><p>除了上面提到的 resources.pb 以外，还有 assets.pb、native.pb，这三个 pb 文件是 aab 格式的重要部分，它们描述了 APP 的不同服务目标，动态下发时会根据这些目标而组织不同的资源进行下发。</p><h2 id="动态下载功能模块"><a href="#动态下载功能模块" class="headerlink" title="动态下载功能模块"></a>动态下载功能模块</h2><p>动态下载功能模块的示例代码详见 <a href="https://github.com/android/app-bundle-samples" target="_blank" rel="noopener">app-bundle-samples</a>。下载并安装功能模块大致分为以下几个步骤：</p><p>一、使用工厂类创建下载服务 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var manager: SplitInstallManager = SplitInstallManagerFactory.create(this)</span><br></pre></td></tr></table></figure><p>二、通过模块名创建下载功能模块的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val request = SplitInstallRequest.newBuilder()</span><br><span class="line">                .addModule(name)</span><br><span class="line">                .build()</span><br></pre></td></tr></table></figure><p>三、启动请求，并在下载后执行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.startInstall(request)</span><br></pre></td></tr></table></figure><p>借助于 aab 格式对功能模块代码与资源的模块划分，因此可以很方便地从 aab 包中提取出功能模块的内容，再配合 Google Play 的下载服务，就可以无侵入地实现插件化，按需下载、安装、卸载功能模块，除此之外，还可以按需请求指定的资源，例如语言包等等。</p><h2 id="如何使用-aab"><a href="#如何使用-aab" class="headerlink" title="如何使用 aab"></a>如何使用 aab</h2><p>上文有提到，aab 是一种发布格式，用于上传至 Google Play 对外发布，日常开发、测试时依然使用的是 apk 包。但如果想要对 aab 包做兼容测试，例如验证是否可以正确地提取 apk ，或者使用功能模块后，对应用的基本模块是否有影响等问题，这种情况下要怎么使用  aab 格式文件呢？这就需要用到官方提供的工具 BundleTool （<a href="https://github.com/google/bundletool/releases" target="_blank" rel="noopener">下载地址</a>）。下载 jar 后配置下环境变量就可以使用了。</p><p>bundletool 提供了诸多命令用于本地测试 aab 包，例如 build-apks 命令用于生成 apk：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundletool build-apks --bundle=/xxx/test.aab --output=/xxx/test.apks --connected-device</span><br></pre></td></tr></table></figure><p>上述命令的 output 的路径必须以 .apks 后缀结尾。上述命令会为应用支持的所有设备配置生成一组 APK，并将这些 APK 纳入到一个名为“APK set archive”的容器中，该容器以 .apks 作为文件扩展名。</p><p>根据名称 apks 顾名思义，大胆猜测 .apks 文件应该也只是一个压缩包，尝试手动把后缀改为 .zip 后解压可以看到文件的结构：</p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607165511746-959711736.png" alt="文件结构"></p><p><img src="https://img2022.cnblogs.com/blog/1751786/202206/1751786-20220607165520833-1062132253.png" alt="文件结构"></p><p>包含了 splits 和 standalones 文件夹和一个 .pb 后缀的文件。</p><p>生成的 apks 文件不同于 apk，我们无法直接使用 apks 文件安装 app，bundletool 另外提供了 install-apks 命令，用于在生成一组 apk 后，将其中适当的<br>apk 组合部署到已连接的设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundletool install-apks --apks=/xxx/test.apks</span><br></pre></td></tr></table></figure><p>通过 build-apks、install apks 组合使用，可以实现使用 aab 格式文件来安装 apk。通过我们上面的分析，我们大概能了解到在文章开头提到的“Google play 只会下载特定设备所需的代码和资源来运行您的应用”，其本质就是对不同的代码和资源做了分包，然后当不同的设备访问 Google Play 商店下载应用时，只需要下发对应的代码和资源包即可。bundletool 是开源的，我们跟随源码看一下 install-apks 命令做了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//src/main/java/com/android/tools/build/bundletool/commands/InstallApksCommand.java</span><br><span class="line"></span><br><span class="line">DeviceSpec deviceSpec = new DeviceAnalyzer(adbServer).getDeviceSpec(getDeviceId());</span><br><span class="line">//执行安装前，获取需要安装的代码和资源</span><br><span class="line">final ImmutableList&lt;Path&gt; apksToInstall =</span><br><span class="line">          getApksToInstall(toc, deviceSpec, tempDirectory.getPath());</span><br><span class="line"></span><br><span class="line">//src/main/java/com/android/tools/build/bundletool/device/DeviceAnalyzer.java</span><br><span class="line"></span><br><span class="line">//组合设备的各种信息，用于提取对应的资源</span><br><span class="line">DeviceSpec.Builder builder =</span><br><span class="line">  DeviceSpec.newBuilder()</span><br><span class="line">  .setSdkVersion(deviceSdkVersion)</span><br><span class="line">  .addAllSupportedAbis(supportedAbis)</span><br><span class="line">  .addAllSupportedLocales(deviceLocales)</span><br><span class="line">  .setScreenDensity(deviceDensity)</span><br><span class="line">  .addAllDeviceFeatures(deviceFeatures)</span><br><span class="line">  .addAllGlExtensions(glExtensions);</span><br><span class="line">if (codename != null) &#123;</span><br><span class="line">  builder.setCodename(codename);</span><br><span class="line">&#125;</span><br><span class="line">return builder.build();</span><br></pre></td></tr></table></figure><p>正是通过获取设备的 sdk 版本、支持的 abi、设备屏幕密度等等信息，从 aab 中提取出对应的资源，从而达到“瘦身”下载的效果。</p><p>就像下图所示，完整的 aab 包里包含了应用的所有资源，例如 xhdpi、xxhdpi 等各类屏幕密度的图片资源；x86、arm64 等各类架构的 so 库；en、zh 等各国语言资源包，等等，aab 是一种大而全的存在（apk 也一样），但是通过 Google Play 商店的动态分发，实现了针对不同的设备的小而精的瘦身下载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>aab 作为一种新的发布格式，海外市场通过 Google Play 商店可以便捷地实现“瘦身”下载与插件化能力，但在国内市场因为大部分手机都没搭载 Google 服务套件，因此无法体验到这些服务。但是通过探究其实现原理，我们可以借助 aab 实现自己的插件化方案，这种无侵入的插件化思想值得我们学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-Android-App-Bundle&quot;&gt;&lt;a href=&quot;#什么是-Android-App-Bundle&quot; class=&quot;headerlink&quot; title=&quot;什么是 Android App Bundle&quot;&gt;&lt;/a&gt;什么是 Android App Bund
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 仓库拆分</title>
    <link href="https://yazhidev.github.io/2021/03/12/Git-%E4%BB%93%E5%BA%93%E6%8B%86%E5%88%86/"/>
    <id>https://yazhidev.github.io/2021/03/12/Git-仓库拆分/</id>
    <published>2021-03-11T23:59:05.000Z</published>
    <updated>2022-06-07T23:59:54.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h2><h3 id="subtree"><a href="#subtree" class="headerlink" title="subtree"></a>subtree</h3><p>使用命令 <code>git subtree split -P dirPath -b branchName</code> 将目标文件夹的代码都保存到指定分支。试了下，该方案虽然保留了 commit，但是所有分支全都没了</p><h3 id="filter-branch"><a href="#filter-branch" class="headerlink" title="filter-branch"></a>filter-branch</h3><p><code>git filter-branch --prune-empty --subdirectory-filter dir1 -- --all</code></p><p><code>--prune-empty</code>：表示如果修改后的提交为空则扔掉不要<br><code>--subdirectory-filter</code>：指定子目录路径<br><code>-- --all</code>：针对所有的分支</p><p>当上述命令执行完毕后，就可以看到本地的新仓库已经是原仓库子目录中的内容了，且保留了关于该子目录所有的提交历史。看了下仓库大小和操作前没有变化，因为 .git 目录里还保留着无用的 object。还需要清理一下无用文件。下面来实操一下 <code>filter-branch</code> 怎么拆分仓库。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="模拟-git-仓库"><a href="#模拟-git-仓库" class="headerlink" title="模拟 git 仓库"></a>模拟 git 仓库</h3><p>为了比较好追踪问题，我们先模拟出一个 git 仓库，这样数据量小，排查起来会比较方便。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225731_20200924204405069_1004966953.png" alt="模拟git仓库"></p><p>看一下 objects 文件夹：</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225731_20200924201712993_1027804611.png" alt="本地git目录"></p><p>在操作之前，先看一下仓库大小，使用 <code>git count-objects -v</code> 命令可以计算仓库大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count: 27</span><br><span class="line">size: 31528</span><br><span class="line">in-pack: 0</span><br><span class="line">packs: 0</span><br><span class="line">size-pack: 0</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure><h3 id="查找仓库里的大文件"><a href="#查找仓库里的大文件" class="headerlink" title="查找仓库里的大文件"></a>查找仓库里的大文件</h3><p>使用下面的命令可以查找仓库中的大文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --all --objects | \</span><br><span class="line">grep &quot;$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -n 3 | awk -F &apos; &apos;  &apos;&#123;print $1&#125;&apos;)&quot;</span><br></pre></td></tr></table></figure><p>大概说明一下上面脚本使用到的命令：</p><p><code>git rev-list</code>：查看指定对象的文件路径、文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all |grep a6d75f</span><br><span class="line">//将列出文件路径</span><br><span class="line">a6d75f7315534b7cfe73597f1ae0f388b9494332 aaa/Main.java</span><br></pre></td></tr></table></figure><p><code>git verify-pack</code>：查看 git 打包文件的信息，输出 SHA-1、size 等字段。这里用到 $ 先保存 <code>git verify-pack</code> 的输出。</p><p>如果直接使用上述脚本会发现什么也没输出，因为脚本首先是分析 git 打包文件，然后再进行大小排序的。所以我们需要先使用命令 <code>git gc</code> 打包 git 本地目录存储的文件。</p><p>执行 gc 命令后，blob 对象会被打包，再查看 objects 目录可以看到创建了一个包文件（pack 文件）和一个索引文件。Git 会对大文件进行打包，生成 <code>.pack</code> 格式的文件以及同名的 <code>.idx</code> 格式的索引文件，存放在 .git/object/pack 目录中。通常来说，Git仓库的大文件都是.pack格式的，存放在这个目录中。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225732_20200924201741616_2101124256.png" alt="git pack 目录"></p><p>gc 后，我们再看一下仓库大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count: 0</span><br><span class="line">size: 0</span><br><span class="line">in-pack: 27</span><br><span class="line">packs: 1</span><br><span class="line">size-pack: 30671</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure><p>可以看到比 gc 之前稍稍少了一点。现在可以列出 idex 索引文件中存储的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git verify-pack -v .git/objects/pack/pack-e3b9f038d3df8b6214fef04e37477f98a0b48911.idx                                          </span><br><span class="line">690898ddaf1b386531b9c1c81eec09eb18f4efa8 commit 208 166 12</span><br><span class="line">2c9790dbda1a83f64c7c7a8660f11aea87e14e78 commit 215 168 178</span><br><span class="line">c4111b93fc90f70885dc71eae6be44811658197c commit 209 163 346</span><br><span class="line">0c5e8cf09a2574a38e26c1c7cb0361f8e3b7f2b1 commit 218 175 509</span><br><span class="line">50b29eb5e83cf486a72c3dfa6f0ba5ee3b2b2e32 commit 214 166 684</span><br><span class="line">f05893bf834b85795e8e592bbe51130bc1792ce1 commit 252 192 850</span><br><span class="line">dbd772576def32be5be8aa55fdbc2e5143551d5d commit 157 117 1042</span><br><span class="line">2095176e6f0116345c3fe223f724deb057ee8b73 blob   166 136 1159</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上述每行里各项值分别对应着：</p><p><code>SHA-1， type， size， size-in-packfile， offset-in-packfile</code></p><h3 id="执行-filter-branch"><a href="#执行-filter-branch" class="headerlink" title="执行 filter-branch"></a>执行 filter-branch</h3><p><code>filter-branch</code> 需要指定目录，拆分仓库时可能需要同时保留多个目录，可以使用以下脚本（这里仅保留 aaa，如果填的是 aaa bbb，即可同时保留 aaa 和 bbb 文件夹）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --index-filter &apos;git rm --cached -qr --ignore-unmatch -- . &amp;&amp; git reset -q $GIT_COMMIT -- aaa&apos; --prune-empty -- --all</span><br></pre></td></tr></table></figure><p>执行完命令后，git 图表变成：</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225732_20200924204424979_520695416.png" alt="git 图表"></p><p>可以看到，与 aaa 文件夹下文件无关的 commit 都被移除了。分支也都被保留了，棒棒的！正是我们想要的效果。再看保留下来的各个 commit 的内容：</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225732_20200924203145451_532996405.png" alt="操作后的 commit"></p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225732_20200924203229773_916287198.png" alt="操作后的 commit"></p><p>可以看到，虽然 commit 的提交信息没有变，但是内容却变了，first commit 原先新增了 aaa/Main.java 和 bbb/Main.java，但是操作后，提交记录里只剩下了 aaa/Main.java。内容变化了，同样的 SHA1 值也变化了。</p><p>再查看一下仓库大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count: 10</span><br><span class="line">size: 40</span><br><span class="line">in-pack: 27</span><br><span class="line">packs: 1</span><br><span class="line">size-pack: 30671</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure><p>额，size-pack 的大小没有变化，我们直接查看一下 objects 目录。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225732_20200924203511461_433704149.png" alt="git本地目录"></p><p>虽然工作目录中不需要的文件已经被清除了，但是 git/objects/pack 目录里存储的 pack 文件和索引文件却没有被删除，重新读取一下 idx 文件的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git verify-pack -v .git/objects/pack/pack-e3b9f038d3df8b6214fef04e37477f98a0b48911.idx</span><br><span class="line">——————</span><br><span class="line">690898ddaf1b386531b9c1c81eec09eb18f4efa8 commit 208 166 12</span><br><span class="line">2c9790dbda1a83f64c7c7a8660f11aea87e14e78 commit 215 168 178</span><br><span class="line">c4111b93fc90f70885dc71eae6be44811658197c commit 209 163 346</span><br><span class="line">0c5e8cf09a2574a38e26c1c7cb0361f8e3b7f2b1 commit 218 175 509</span><br><span class="line">50b29eb5e83cf486a72c3dfa6f0ba5ee3b2b2e32 commit 214 166 684</span><br><span class="line">f05893bf834b85795e8e592bbe51130bc1792ce1 commit 252 192 850</span><br><span class="line">dbd772576def32be5be8aa55fdbc2e5143551d5d commit 157 117 1042</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>和执行 <code>filter-branch</code> 之前是一模一样的。要不再 gc 一下看看？再次 gc 后，blob 文件又被打包，并生成了两个新的 idx 文件和 pack 文件：</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225732_20200924204214140_706134325.png" alt="git pack 目录"></p><p>再次查看索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git verify-pack -v .git/objects/pack/pack-af08fc2fbea78dfae1503ae4b03578a4113da969.idx</span><br><span class="line">——————</span><br><span class="line">690898ddaf1b386531b9c1c81eec09eb18f4efa8 commit 208 166 12</span><br><span class="line">fa322194e3401dfd14591d82951a9aca3b620631 commit 215 169 178</span><br><span class="line">2c9790dbda1a83f64c7c7a8660f11aea87e14e78 commit 215 168 347</span><br><span class="line">c4111b93fc90f70885dc71eae6be44811658197c commit 209 163 515</span><br><span class="line">bb57bc14d163c5fc7b9bbce7f6e006a8e5c37564 commit 218 172 678</span><br><span class="line">0c5e8cf09a2574a38e26c1c7cb0361f8e3b7f2b1 commit 218 175 850</span><br><span class="line">50b29eb5e83cf486a72c3dfa6f0ba5ee3b2b2e32 commit 214 166 1025</span><br><span class="line">2c4d78cfe2251613b1f23693a3ebe6f4ee9e793d commit 214 166 1191</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>690898</code> 这个 commit 对象是最初添加大文件时的 commit，可以看到该 commit 对象依然存在在最新的 idx 文件中。实锤了，一番操作实际上只是工作目录看起来空旷了，git 仓库里不该有的文件还是一样没落下。</p><h3 id="移除无用文件"><a href="#移除无用文件" class="headerlink" title="移除无用文件"></a>移除无用文件</h3><p>执行到这一步目标很清楚，就是把 <code>690898</code>  这类已经不可达的 commit 和 <code>pack-af08fc2fbea78dfae1503ae4b03578a4113da969.pack</code> 这些已经没有任何历史提交引用的文件都删除掉。</p><p>谷歌一搜，网络上流传的方法试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -Rf .git/refs/original</span><br><span class="line">rm -Rf .git/logs</span><br><span class="line">git gc</span><br></pre></td></tr></table></figure><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225732_20200924205128548_331995187.png" alt="git 本地路径"></p><p>可以看到，执行到这里，<code>git/refs/original</code> 里空空如也，并不需要删什么东西，而且 git gc 我们刚也试过了，并没有什么卵用。<code>git prune</code> 也是一样的，因为 gc 实际上就是调用 <code>git prune</code>。</p><p>事已至此，不妨用 Java 垃圾回收的思想来理解：文件之所以没有被删掉，肯定是哪里还存在这引用，找出引用应该是解决问题的关键。</p><p>引入的大文件，从上面可以看出就是 <code>04ddd8</code> 这个，使用命令查看以下文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all |grep 04ddd8</span><br><span class="line">————</span><br><span class="line">04ddd80c36932757f15327b35f5bcc123082c454 bigfile.zip</span><br></pre></td></tr></table></figure><p>再随便翻翻 git 本地目录，查看 <code>packed-refs</code> 文件，<code>refs</code> = <code>references</code>，感觉有点东西啊，打开一看果然发现文本里记录着 refs/original 相关的东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># pack-refs with: peeled fully-peeled sorted </span><br><span class="line">fa322194e3401dfd14591d82951a9aca3b620631 refs/heads/master</span><br><span class="line">bb57bc14d163c5fc7b9bbce7f6e006a8e5c37564 refs/heads/test</span><br><span class="line">690898ddaf1b386531b9c1c81eec09eb18f4efa8 refs/original/refs/heads/master</span><br><span class="line">c4111b93fc90f70885dc71eae6be44811658197c refs/original/refs/heads/test</span><br></pre></td></tr></table></figure><p><code>690898</code> 这个 SHA1 值很眼熟了，就是最开始的一个 commitID。再回看最初的 git 图表，可以看到 <code>690898</code> 和 <code>c4111b</code> 分别指向操作前的 master 分支和 test 分支。</p><p><code>filter-branch</code> 后，整个 git commit 树都变了，大清都亡了，之前的这两个引用肯定是没用的旧引用了，删删删！然后再使用命令检查可达性 ：</p><p><code>git fsck --full --unreachable</code>：验证数据库中对象的连通性和有效性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (37/37), done.</span><br><span class="line">unreachable blob 04ddd80c36932757f15327b35f5bcc123082c454</span><br><span class="line">unreachable commit 0c5e8cf09a2574a38e26c1c7cb0361f8e3b7f2b1</span><br><span class="line">unreachable blob ab7268ccda89f9f58e6ae60050b360301cc91a71</span><br><span class="line">unreachable commit 2c9790dbda1a83f64c7c7a8660f11aea87e14e78</span><br><span class="line">unreachable tree 2fc5bb169f78176029674d4b5234d51e287df50f</span><br><span class="line">unreachable commit c4111b93fc90f70885dc71eae6be44811658197c</span><br><span class="line">unreachable tree 45a12cd512c7ae28d05b7b391e8d872031f1a89c</span><br><span class="line">unreachable tree 4ed47074261cd7cb9f26b38452b56f88014ff2ac</span><br><span class="line">unreachable commit 50b29eb5e83cf486a72c3dfa6f0ba5ee3b2b2e32</span><br><span class="line">unreachable tree 5207eed7e90f90d9c6b6bf63cfea997033136def</span><br><span class="line">unreachable tree 53b3421a3db498b5b15e96141a46e3c0b2431881</span><br><span class="line">unreachable tree 598e2a6bb6dec5bb9b62c0bd757b66504413d5a2</span><br><span class="line">unreachable commit dbd772576def32be5be8aa55fdbc2e5143551d5d</span><br><span class="line">unreachable tree e27ea026bb5098ab33079172ae7835b27e40f4c4</span><br><span class="line">unreachable tree 651d867dfc1f337090bf8bec6fef4459b369ac1a</span><br><span class="line">unreachable commit 690898ddaf1b386531b9c1c81eec09eb18f4efa8</span><br><span class="line">unreachable tree ed9833e93207376f729c517a5780aa7063bca0bb</span><br><span class="line">unreachable commit f05893bf834b85795e8e592bbe51130bc1792ce1</span><br><span class="line">unreachable tree 708923165513ea1259dcaff627b201b142545c6d</span><br></pre></td></tr></table></figure><p>可以看到我们最想删掉的大文件 <code>04ddd8</code> 被列出来，并且是不可达的。</p><p>再执行命令 <code>git repack -A -d</code>，确保不可达的对象被解压并保持解压。然后再调用 <code>git prune</code></p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200926_225732_20200924211032564_680593003.png" alt="git 本地目录"></p><p>重新计算项目大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count: 0</span><br><span class="line">size: 0</span><br><span class="line">in-pack: 18</span><br><span class="line">packs: 1</span><br><span class="line">size-pack: 2</span><br><span class="line">prune-packable: 0</span><br><span class="line">garbage: 0</span><br><span class="line">size-garbage: 0</span><br></pre></td></tr></table></figure><p>可以看到，无用的旧文件已经被清除了~</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>这里记录以下调研过程中遇到的命令，git 接触很久了，但是很多命令却还是第一次见，深感自己之渺小。</p><p><strong>保存镜像</strong></p><p><code>git clone --mirror xxx地址</code></p><p><strong>查看仓库大小</strong></p><p><code>git count-objects -v</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方案对比&quot;&gt;&lt;a href=&quot;#方案对比&quot; class=&quot;headerlink&quot; title=&quot;方案对比&quot;&gt;&lt;/a&gt;方案对比&lt;/h2&gt;&lt;h3 id=&quot;subtree&quot;&gt;&lt;a href=&quot;#subtree&quot; class=&quot;headerlink&quot; title=&quot;sub
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android OpenGL ES 开发（二）：绘制图形</title>
    <link href="https://yazhidev.github.io/2021/01/08/Android-OpenGL-ES-%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2/"/>
    <id>https://yazhidev.github.io/2021/01/08/Android-OpenGL-ES-开发（二）：绘制图形/</id>
    <published>2021-01-07T23:57:51.000Z</published>
    <updated>2022-06-07T23:58:49.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenGL-绘制图形步骤"><a href="#OpenGL-绘制图形步骤" class="headerlink" title="OpenGL 绘制图形步骤"></a>OpenGL 绘制图形步骤</h1><p>上一篇介绍了 OpenGL 的相关概念，今天来实际操作，使用 OpenGL 绘制出图形，对其过程有一个初步的了解。</p><p>OpenGL 绘制图形主要概括成以下几个步骤：</p><ol><li>创建程序</li><li>初始化着色器</li><li>将着色器加入程序</li><li>链接并使用程序</li><li>绘制图形</li></ol><p>上述每个步骤还可能会被分解成更细的步骤，对应着多个 api，下面我们来逐个看下。</p><h2 id="创建程序"><a href="#创建程序" class="headerlink" title="创建程序"></a>创建程序</h2><p>使用 <a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/" target="_blank" rel="noopener">glCreateProgram</a> 创建一个 program 对象并返回一个引用 ID，该对象可以附加着色器对象。注意要在OpenGL渲染线程中创建，否则无法渲染。</p><h2 id="初始化着色器"><a href="#初始化着色器" class="headerlink" title="初始化着色器"></a>初始化着色器</h2><p>着色器的初始化可以细分为三个步骤：</p><ol><li>创建顶点、片元着色器对象</li><li>关联着色器代码与着色器对象</li><li>编译着色器代码</li></ol><p><a href="https://www.cnblogs.com/yazhidev/p/13737177.html" target="_blank" rel="noopener">上一篇文章</a>我们提到了顶点着色器和片元着色器都是可编程管道，因此着色器的初始化少不了对着色器代码的关联与编译，上面三个步骤对应的 api 为：</p><ol><li>glCreateShader(int type)<ul><li>type：<code>GLES20.GL_VERTEX_SHADER</code> 代表顶点着色器、<code>GLES20.GL_FRAGMENT_SHADER</code> 代表片元着色器</li></ul></li><li>glShaderSource(int shader, String code)<ul><li>shader：着色器对象 ID</li><li>code：着色器代码</li></ul></li><li>glCompileShader(code)<ul><li>code：着色器对象 ID</li></ul></li></ol><p>着色器代码使用 GLSL 语言编写，那代码要怎么保存并使用呢？我看到过三种方式，列出供大家参考：</p><ol><li>字符串变量保存</li></ol><p>这种应该是最直观的写法了，直接在对应的类中使用硬编码存储着色器代码，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final String vertexShaderCode =</span><br><span class="line">    &quot;attribute vec4 vPosition;&quot; +</span><br><span class="line">    &quot;void main() &#123;&quot; +</span><br><span class="line">    &quot;  gl_Position = vPosition;&quot; +</span><br><span class="line">    &quot;&#125;&quot;;</span><br></pre></td></tr></table></figure><p>这种方式不是很建议，可读性不好。</p><ol start="2"><li>存放于 assets 目录</li></ol><p>assets 文件夹下的文件不会被编译成二进制文件，因此适于存放着色器代码，还可以配合 AndroidStudio 插件 <strong>GLSL Support</strong> 实现语法高亮：</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20201229_122040_20201229095812604_2113046260.png" alt="assets"></p><p>然后再封装读取 assets 文件的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private fun loadCodeFromAssets(context: Context, fileName: String): String &#123;</span><br><span class="line">    var result = &quot;&quot;</span><br><span class="line">    try &#123;</span><br><span class="line">        val input = context.assets.open(name)</span><br><span class="line">        val reader = BufferedReader(InputStreamReader(input))</span><br><span class="line">        val str = StringBuilder()</span><br><span class="line">        var line: String?</span><br><span class="line">        while ((reader.readLine().also &#123; line = it &#125;) != null) &#123;</span><br><span class="line">            str.append(line)</span><br><span class="line">            str.append(&quot;\n&quot;) //注意结尾要添加换行符</span><br><span class="line">        &#125;</span><br><span class="line">        input.close()</span><br><span class="line">        reader.close()</span><br><span class="line">        result = str.toString()</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">        e.stackTrace</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是要在结尾添加换行符，否则最后输出的只是一行字符串，不符合 GLSL 语法，自然也就无法正常使用。</p><ol start="3"><li>存放于 raw 目录</li></ol><p>存放于 raw 目录和 assets 目录其实异曲同工，但有个好处是 raw 文件会映射到 R 文件，代码中可以通过 R.raw 的方法使用对应的着色器代码，但 raw 目录下不能有目录结构，这点需要做个取舍。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20201229_122040_20201229110953461_611151883.png" alt="raw 目录"></p><p>同样的，封装读取 raw 文件的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private fun loadCodeFromRaw(context: Context, fileId: Int): String &#123;</span><br><span class="line">    var result = &quot;&quot;</span><br><span class="line">    try &#123;</span><br><span class="line">        val input = context.resources.openRawResource(fileId)</span><br><span class="line">        val reader = BufferedReader(InputStreamReader(input))</span><br><span class="line">        val str = StringBuilder()</span><br><span class="line">        var line: String?</span><br><span class="line">        while ((reader.readLine().also &#123; line = it &#125;) != null) &#123;</span><br><span class="line">            str.append(line)</span><br><span class="line">            str.append(&quot;\n&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        input.close()</span><br><span class="line">        reader.close()</span><br><span class="line">        result = str.toString()</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">        e.stackTrace</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着色器程序可能编译失败，可以使用 <code>glGetShaderiv</code> 方法获取着色器编译状况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var compileStatus = IntArray(1)</span><br><span class="line">//获取着色器的编译情况</span><br><span class="line">GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compileStatus, 0);</span><br><span class="line">if (compileStatus[0] == 0) &#123;//若编译失败则显示错误日志并</span><br><span class="line">    GLES20.glDeleteShader(shader);//删除此shader</span><br><span class="line">    shader = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将着色器加入程序"><a href="#将着色器加入程序" class="headerlink" title="将着色器加入程序"></a>将着色器加入程序</h2><p>初始化着色器后拿到着色器对象 ID，再使用 <a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/" target="_blank" rel="noopener">glAttachShader</a> 将着色器对象附加到 program 对象上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glAttachShader(mProgram, shader) //将顶点着色器加入到程序</span><br><span class="line">GLES20.glAttachShader(mProgram, fragmentShader) //将片元着色器加入到程序中</span><br></pre></td></tr></table></figure><h2 id="链接并使用程序"><a href="#链接并使用程序" class="headerlink" title="链接并使用程序"></a>链接并使用程序</h2><p>使用 <a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/" target="_blank" rel="noopener">glLinkProgram</a> 为附加在 program 对象上的着色器对象创建可执行文件。链接可能失败，可以通过 <code>glGetProgramiv</code> 查询 program 对象状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glGetProgramiv(mProgram, GLES20.GL_LINK_STATUS, linkStatus, 0)</span><br><span class="line">// 如果连接失败，删除这程序</span><br><span class="line">if (linkStatus[0] == 0) &#123;</span><br><span class="line">    GLES20.glDeleteProgram(mProgram)</span><br><span class="line">    mProgram = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接成功后，通过 <code>glUseProgram</code> 使用程序，将 program 对象的可执行文件作为当前渲染状态的一部分。</p><h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><p>终于到最核心的绘制图形了，前面我们初始化了 OpenGL 程序以及着色器，现在需要准备绘制相关的数据，绘制出一个图形最基础的两个数据就是顶点坐标和图形颜色。</p><h3 id="定义顶点数据"><a href="#定义顶点数据" class="headerlink" title="定义顶点数据"></a>定义顶点数据</h3><p>尝试画一个三角定，定义三个顶点，每个顶点包含三个坐标 x，y，z。手机屏幕中心坐标系（0，0，0），左上角坐标（-1, 1, 0）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private val points = floatArrayOf(</span><br><span class="line">    0.0f, 0.0f, 0.0f, //屏幕中心</span><br><span class="line">    -1.0f, -1.0f, 0.0f, //左下角</span><br><span class="line">    1.0f, -1.0f, 0.0f //右下角</span><br><span class="line">)</span><br><span class="line">private val sizePerPoint = 3 //每个顶点三个坐标</span><br><span class="line">private val byteSize = sizePerPoint * 4 //每个顶点之前字节偏移量，float 四个字节</span><br><span class="line">private val pointNum = points.size / sizePerPoint //顶点数量</span><br><span class="line">private var vertexBuffer: FloatBuffer? = null //顶点数据浮点缓冲区</span><br></pre></td></tr></table></figure><p>OpenGL 修改顶点属性时接受的数据类型为缓冲区类型 Buffer，因此还需要将数组类型转为 Buffer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun createFloatBuffer(array: FloatArray): FloatBuffer &#123;</span><br><span class="line">    val bb = ByteBuffer.allocateDirect(array.size * 4);//float 四个字节</span><br><span class="line">    bb.order(ByteOrder.nativeOrder()) //使用本机硬件设备的字节顺序</span><br><span class="line">    val buffer = bb.asFloatBuffer() //创建浮点缓冲区</span><br><span class="line">    buffer.put(array) //添加数据</span><br><span class="line">    buffer.position(0);//从第一个坐标开始读取</span><br><span class="line">    return buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为顶点属性赋值"><a href="#为顶点属性赋值" class="headerlink" title="为顶点属性赋值"></a>为顶点属性赋值</h3><p>顶点着色器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 vPosition;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    gl_Position = vPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点着色器的每个输入变量叫顶点属性，着色器中定义了 vPosition 用于存放顶点数据，先使用 <code>GLES20.glGetAttribLocation</code> 获取 vPosition 句柄，再使用 <code>GLES20.glVertexAttribPointer</code> 为 vPosition 添加我们定义好的顶点数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void glVertexAttribPointer(</span><br><span class="line">        int indx,</span><br><span class="line">        int size,</span><br><span class="line">        int type,</span><br><span class="line">        boolean normalized,</span><br><span class="line">        int stride,</span><br><span class="line">        java.nio.Buffer ptr</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>该方法接收六个参数，分别代表：</p><ul><li>indx：要修改的顶点属性的句柄</li><li>size：每个顶点的坐标数，如果只有 x、y 两个坐标值就传 2</li><li>type：坐标数据类型</li><li>normalized：指定在访问定点数据值时是应将其标准化（true）还是直接转换为定点值（false）</li><li>stride：每个顶点之间的字节偏移量</li><li>ptr：顶点坐标 Buffer</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val vPositionHandle = GLES20.glGetAttribLocation(mProgram, &quot;vPosition&quot;) //获取 vPosition 句柄</span><br><span class="line">GLES20.glVertexAttribPointer(vPositionHandle, sizePerPoint, GLES20.GL_FLOAT, false, byteSize, vertexBuffer) //为 vPosition 添加顶点数据</span><br></pre></td></tr></table></figure><p>如果 glGetAttribLocation 返回值为 -1 代表获取失败，可能 program 对象或着色器对象里没有对应的属性。</p><p>还需要注意的是，为顶点属性赋值时，<code>glVertexAttribPointer</code> 建立了 CPU 和 GPU 之前的逻辑连接，实现了 CPU 数据上传到 GPU。但 GPU 数据是否可见，也就是顶点着色器能否读到数据，则由是否启用了对应的属性决定。默认情况下顶点属性都是关闭的，可以通过 <code>glEnableVertexAttribArray</code> 启用属性，允许着色器读取 GPU 数据。</p><h3 id="定义片元颜色"><a href="#定义片元颜色" class="headerlink" title="定义片元颜色"></a>定义片元颜色</h3><p>OpenGL 定义色值使用 float 数组，可以使用<a href="https://tool.lu/color/" target="_blank" rel="noopener">色值转换在线工具</a>将十六进制色值转换为 float 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private val colors = floatArrayOf(</span><br><span class="line">    0.93f, 0.34f, 0.16f, 1.00f</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="为颜色属性赋值"><a href="#为颜色属性赋值" class="headerlink" title="为颜色属性赋值"></a>为颜色属性赋值</h4><p>片元着色器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">precision mediump float;</span><br><span class="line">uniform vec4 zColor;</span><br><span class="line">void main() &#123;</span><br><span class="line">    gl_FragColor = zColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>颜色属性定义为 uniform 变量，为颜色属性赋值一样需要先获取属性句柄，再向属性添加数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mColorHandle = GLES20.glGetUniformLocation(mProgram, &quot;zColor&quot;); //获取 zColor 句柄</span><br><span class="line">GLES20.glUniform4fv(zColorHandle, 1, color, 0); //为 zColor 添加数据</span><br></pre></td></tr></table></figure><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glEnableVertexAttribArray(vPositionHandle) //启用顶点句柄</span><br><span class="line">GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, pointNum) //渲染图元</span><br><span class="line">GLES20.glDisableVertexAttribArray(vPositionHandle) //禁用顶点句柄</span><br></pre></td></tr></table></figure><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20201229_123627_20201229123612959_1845995943.png" alt="绘制三角形"></p><p>当当当当，三角形出现了。上次只是绘制了背景色，今天又向前迈一步绘制出图形。但是显而易见这并不是一个等边三角形，和我们定义的坐标有所出入，这是因为 OpenGL 屏幕坐标系是一个正方形并且分布均匀的坐标系，因此将图形绘制到非正方形屏幕上时图形会被压缩或者拉伸。下一篇文章我们会使用投影变换来解决这个问题。</p><p>Comming soon :P</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenGL-绘制图形步骤&quot;&gt;&lt;a href=&quot;#OpenGL-绘制图形步骤&quot; class=&quot;headerlink&quot; title=&quot;OpenGL 绘制图形步骤&quot;&gt;&lt;/a&gt;OpenGL 绘制图形步骤&lt;/h1&gt;&lt;p&gt;上一篇介绍了 OpenGL 的相关概念，今天来实际操
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android OpenGL ES 开发（一）：相关概念</title>
    <link href="https://yazhidev.github.io/2020/10/11/Android-OpenGL-ES-%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>https://yazhidev.github.io/2020/10/11/Android-OpenGL-ES-开发（一）：相关概念/</id>
    <published>2020-10-10T23:15:30.000Z</published>
    <updated>2022-06-07T23:58:15.629Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL(Open Graphics Library) 是开放图形库，是一个跨平台的图形 API。OpenGL ES(OpenGL for Embedded System)是专为移动端提供的一个子集。目前主要版本有1.0/1.1/2.0/3.0/3.1：</p><ul><li>1.0：Ａndroid 1.0和更高的版本支持这个API规范</li><li>2.0：不兼容 OpenGL ES 1.x。Android 2.2(API 8)和更高的版本支持这个API规范</li><li>3.0：向下兼容 OpenGL ES 2.x。Android 4.3(API 18)及更高的版本支持这个API规范</li><li>3.1：向下兼容 OpenGL ES3.0/2.0。Android 5.0（API 21）和更高的版本支持这个API规范</li></ul><p>先了解一下 OpenGl 几个相关的概念</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="管线"><a href="#管线" class="headerlink" title="管线"></a>管线</h3><p>也称渲染管线，因为 OpenGL ES 在渲染处理过程中会顺序执行一系列操作，这一系列相关的处理阶段就被称为 OpenGL ES 渲染管线。OpenGL ES 渲染过程就如流水线作业一样，这样的实现极大地提高了渲染的效率。如图就是 OpenGL ES 的管线图，学习OpenGL ES 就是学习这张图中的每一个部分。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200911_071858_20200906111207301_120328481.png" alt="OpenGL渲染管线"></p><p>图中阴影部分的 Vertex Shader(顶点着色器) 和 Fragment Shader(片元着色器) 是可编程管线 。</p><h3 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h3><p>OpenGl 物体图形都由点、线、多边形组成，组成他们的关键就在于顶点数据。绘制时需要准备绘制的位置，这些位置就是顶点，顶点组合起来就是顶点坐标。</p><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p>OpenGl 使用右手坐标系，手机屏幕中心坐标系（0，0，0），左上角坐标（-1, 1, 0），依此类推。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200911_071858_20200906111014612_1350569553.png" alt="右手坐标系"></p><h3 id="着色器语言"><a href="#着色器语言" class="headerlink" title="着色器语言"></a>着色器语言</h3><p>着色器的编程语言是基于 C 语言开发的，被称为 GLSL（OpenGL Shading Language），和 C 语言最大的区别是它新增了许多适合图形处理的东西，比如定义了向量和矩阵两个数据类型，另外 GLSL 也对高并发进行了特殊优化。</p><p>GLSL 详细语法可见：<a href="https://github.com/wshxbqq/GLSL-Card" target="_blank" rel="noopener">GLSL 中文手册</a></p><h3 id="顶点着色器（Vertex-Shader）"><a href="#顶点着色器（Vertex-Shader）" class="headerlink" title="顶点着色器（Vertex Shader）"></a>顶点着色器（Vertex Shader）</h3><p>顶点着色器分为输入和输出两部分，负责的功能是把输入的数据进行矩阵变换位置，计算光照公式生成逐顶点颜⾊，⽣成/变换纹理坐标。并且把位置和纹理坐标这样的参数发送到片段着色器。</p><p>顶点着色器的输入数据由下面组成：</p><ul><li>Attributes：使用顶点数组封装每个顶点的数据，一般用于每个顶点都各不相同的变量，如顶点位置、颜色等。</li><li>Uniforms：顶点着色器使用的常量数据，不能被着色器修改，一般用于对同一组顶点组成的单个3D物体中所有顶点都相同的变量，如当前光源的位置。</li><li>Samplers：这个是可选的，一种特殊的 uniforms，表示顶点着色器使用的纹理。</li><li>Shader program：顶点着色器的源码或可执行文件，描述了将对顶点执行的操作。</li></ul><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200911_071858_20200902074045970_1307915562.png" alt="顶点着色器"></p><p>顶点着色器对于 3D 模型网格的每个顶点执行一次，确定顶点的最终位置。顶点着色器取得一个位置及相关的颜色数据作为输入属性，用一个 4x4 矩阵变换位置，并输出变换后的位置和颜色。</p><p>顶点着色器是可编程渲染管道，例如一个简单的顶点着色器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 aPosition;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_Position = aPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子里的 gl_Position 是顶点着色器的内建输出变量。</p><p>gl_Position： 顶点坐标<br>gl_PositionSize：点的大小，默认值是 1</p><h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p>图元指的是点、直线和三角形。该过程还有两个重要操作：裁剪和淘汰。对不在屏幕可见的 3D 区域内的图元进行裁剪，根据图元面向前方或后方选择抛弃它们（比如物体内部的点）。</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>将图元转为片段的过程称为光栅化。片段可以理解为带有深度信息的像素点。屏幕上的一个像素点可能对应多个片段。</p><h3 id="片段着色器（Fragment-Shader）"><a href="#片段着色器（Fragment-Shader）" class="headerlink" title="片段着色器（Fragment Shader）"></a>片段着色器（Fragment Shader）</h3><p>片段着色器用于对片段进行处理，例如纹理采样、颜色汇总等，将每个片段的颜色等属性计算出来并向后传输。编写片元着色器可以实现滤镜、美颜、图片处理、类似抖音的一些特效等效果。片段着色器对光栅化之后 2D 图像中的每个像素处理一次，3D 物体的表面最终显示成什么样子由片段着色器决定。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200911_071858_20200907071634306_518331695.png" alt="片段着色器"></p><p>片段着色器也是可编程的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gl_FragColor 是片段着色器的内建输出变量，指当前片元的颜色。</p><h3 id="GLSurfaceView"><a href="#GLSurfaceView" class="headerlink" title="GLSurfaceView"></a>GLSurfaceView</h3><p>我们都知道 SurfaveView 最大的特点是可以在子线程中绘制图象，GLSurfaceView 继承自 SurfaceView，其实是对 SurfaceView 再做了一次封装，方便在 Android 中使用 OpenGL。</p><p>GLSurfaceView 的渲染被委托给渲染器在独立的渲染线程里进行，通过 <code>setRender(Render)</code> 设置渲染器。</p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>了解相关概念后，先动手编写个简单的 Demo 实操一下。Android 上使用 OpenGl ES 流程如下：</p><ol><li>在 AndroidMenifest 中设置 OpenGL 版本：</li></ol><p>如果应用不指定 android:glEsVersion 属性，则系统默认使用 OpenGL ES 1.0，即所有 Android 设备都支持的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义渲染器</li></ol><p>新建类实现 <code>GLSurfaceView.Renderer</code> 接口，并在三个回调方法中做相应操作。</p><ul><li>在 Surface 创建时，设置设置清除后的颜色预设值</li><li>在 Surface 变化时，更新视口矩形宽高、窗口位置</li><li>在每次绘制帧时，清空颜色缓冲并置为预设颜色</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CustomRender: GLSurfaceView.Renderer &#123;</span><br><span class="line">    override fun onDrawFrame(gl: GL10?) &#123;</span><br><span class="line">        //绘制当前帧</span><br><span class="line">        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) &#123;</span><br><span class="line">        //surface 变化时的回调，包括尺寸变化、设备屏幕方向变化等</span><br><span class="line">        GLES20.glViewport(0, 0, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) &#123;</span><br><span class="line">        //surface 创建时的回调</span><br><span class="line">        GLES20.glClearColor(0.0f, 0.0f, 1.0f, 1.0f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义 GLSurfaceView</li></ol><p>新建类继承自 GLSurfaceView，并在初始化时设置渲染器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class CustomGLSurfaceView(context: Context?) : GLSurfaceView(context) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        setRenderer(CustomRender())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>展示 GLSurfaceView</li></ol><p>将 GLSurfaceView 添加到布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class KotlinActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private val glSurfaceView by lazy &#123; CustomGLSurfaceView(this) &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(glSurfaceView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，页面会显示蓝色背景，这是 GLSurfaceView 最简单的运用，简单到我都不好意思放效果图。但千里之行始于足下，下一次我们接着深入 GLSurfaceView 的使用，动手编写着色器来实现图形绘制。</p><p>Comming soon  :P</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OpenGL(Open Graphics Library) 是开放图形库，是一个跨平台的图形 API。OpenGL ES(OpenGL for Embedded System)是专为移动端提供的一个子集。目前主要版本有1.0/1.1/2.0/3.0/3.1：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
    
      <category term="OpenGL" scheme="https://yazhidev.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Java 类型转换精度问题</title>
    <link href="https://yazhidev.github.io/2020/08/01/Java-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>https://yazhidev.github.io/2020/08/01/Java-类型转换精度问题/</id>
    <published>2020-08-01T12:41:06.000Z</published>
    <updated>2022-06-07T22:58:54.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型占用内存大小"><a href="#基本数据类型占用内存大小" class="headerlink" title="基本数据类型占用内存大小"></a>基本数据类型占用内存大小</h2><p>最近项目中修复了一个关于类型转换精度丢失的问题，以前对于类型转换会丢失精度只知其然，不知其所以然，这次了解了下相关原理，也分享给大家。先来回顾一下 Java 的基本数据类型中整型与浮点型及其所占用的内存大小：</p><p><strong>整型：</strong></p><ul><li>int：4 字节 32 位</li><li>long：8 字节 64 位</li></ul><p><strong>浮点型：</strong></p><ul><li>float：4 字节 32 位</li><li>double：8 字节 64 位</li></ul><p>Java 运算时，当两个不同类型的数进行基本运算符操作时，低精度会自动向高精度转换，字节短的会自动向字节长的转换。</p><p>《Java 核心技术》一书中这么归纳到：</p><blockquote><p>如果两个操作数其中有一个是 double 类型，另一个操作就会转换为 double 类型。<br>否则，如果其中一个操作数是 float 类型，另一个将会转换为 float 类型。<br>否则，如果其中一个操作数是 long 类型，另一个会转换为 long 类型。<br>否则，两个操作数都转换为 int 类型。</p></blockquote><p>需要注意 Java 自动转换类型可能会带来精度的丢失，附上一张不会丢失精度的合法类型转换说明图：</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200901_204139_20200824075634064_585870421.png" alt="合法转换"></p><p>图中实现箭头类型转换代表不会丢失精度，虚线箭头类型转换可能会丢失精度。</p><h2 id="基本数据类型表示范围"><a href="#基本数据类型表示范围" class="headerlink" title="基本数据类型表示范围"></a>基本数据类型表示范围</h2><p>精度和数据类型可表示的数值大小范围息息相关，计算机中所有数值归根到底都是使用二进制 0、1 来组成，因此一个数据类型所占用的内存大小越大，就意味着可用的二进制位数越多，当然可表示的范围就越大。回顾一下几个常见的参与运算的基本数据类型的取值范围：</p><p><strong>int</strong></p><p>二进制位数：32<br>最小值：Integer.MIN_VALUE= -2147483648 （-2 的 31 次方）<br>最大值：Integer.MAX_VALUE= 2147483647 （2 的 31 次方 -1）</p><p><strong>long</strong></p><p>二进制位数：64<br>最小值：Long.MIN_VALUE=-9223372036854775808 （-2 的 63 次方）<br>最大值：Long.MAX_VALUE=9223372036854775807 （2 的 63 次方 -1）</p><p><strong>float</strong></p><p>二进制位数：32<br>最小值：Float.MIN_VALUE=1.4E-45 （2 的 -149 次方）<br>最大值：Float.MAX_VALUE=3.4028235E38 （2 的 128 次方 -1）</p><p><strong>double</strong></p><p>二进制位数：64<br>最小值：Double.MIN_VALUE=4.9E-324 （2 的 -1074 次方）<br>最大值：Double.MAX_VALUE=1.7976931348623157E308 （2 的 1024 次方 -1）</p><p>当 long 类型的数大于 <code>Integer.MAX_VALUE</code> 时，long 强制转换 int，就会出现丢失精度。转换过程是将 long 类型数值的二进制数从低位到高位截取 32 位，再将 32 位二进制数转为 int。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l3 = 24696061952L; //10111000000000000000000000000000000</span><br><span class="line">int c3 = (int)l3; //-1073741824</span><br><span class="line">System.out.println(Integer.toBinaryString(c3)); //1000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>上面的例子中，long 类型截取 32 位后转为 int，最高位作为符号位，1 代表负数，强转后的 int 值为  <code>-1073741824</code>。<br>类似这种不合理的强制转换丢失的已经不仅仅是精度了。</p><p>不知道有没有人注意到，long 类型的二进制位数是 64，float 类型的二进制位数是 32，但是 float 类型可表示范围却远远大于 long 类型。更不用提一样是 32 位的 int 了，float 到底啥家庭啊？谜底就在内存结构中。</p><h2 id="浮点类型数值的内存结构"><a href="#浮点类型数值的内存结构" class="headerlink" title="浮点类型数值的内存结构"></a>浮点类型数值的内存结构</h2><p>与整形类型的内存结构不同，float 在内存中是这样的：</p><p><code>SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM</code></p><ul><li>S：最高位 S 代表符号位</li><li>E：后面 8 位 E 代表指数域，二进制中就是 2 的 n 次方，采用移位存储(127+指数)的二进制方式。</li><li>M：剩下的 23 位 M 代表小数域。规定小数点前的数必须为 1，因此只记录小数点后的数。（从左往右，低位补零）</li></ul><p>以 7.8125 为例，整数十进制转二进制，除 2 取余，逆序排列，求得 7 二进制为 <code>111</code>。小数十进制转二进制，乘 2 取整，顺序排列，求得 0.8125 二进制为：<code>0.1101</code>，组合起来是 <code>111.1101</code>。</p><p>根据规范，小数点前的数只保留 1，因此将 <code>111.1101</code> 小数点左移两位得 <code>1.111101 * 2^2</code>。</p><p>符号位 0，指数位为 2+127=129，即二进制 <code>10000001</code>，小数域为 <code>111101</code>。因此 float 数 7.8125 在内存中存储的格式为：<code>0 10000001 111101</code> 低位补零补齐到 32 位，得：<code>0100 0000 1111 1010 0000 0000 0000 0000</code>。</p><p>可以使用 Java 提供的 API 验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = Float.floatToIntBits(7.8125F); //得到 7.8125F 底层数据（十进制）</span><br><span class="line">Integer.toBinaryString(i); //得到指定 int 值的二进制数</span><br><span class="line">//输出 1000000111110100000000000000000</span><br><span class="line">//补上最高位符号位 0，结果与上面计算的一样。</span><br></pre></td></tr></table></figure><p>通过对浮点类型数值内存结构的了解，我们知道了 float 虽然可用于存储数值的位数没有 long 型多，但是 float 通过使用指数进行降维打击，可表示范围蹭蹭蹭往上涨。</p><p>double 的内存结构同理，只不过 double 二进制位数更多，总共 64 位分别分配给：符号位 1 位，指数位 11 位，小数位 52 位。</p><p>需要注意的是，虽然 float 因为有指数的概念，可表示范围变大了，但是其用于存储小数的位数却只有 23 位。这就意味着当一个整型类型数值的二进制位大于 24 位时，类型转换到 float 就会带来精度丢失了。</p><h2 id="整型转换浮点型的精度丢失问题"><a href="#整型转换浮点型的精度丢失问题" class="headerlink" title="整型转换浮点型的精度丢失问题"></a>整型转换浮点型的精度丢失问题</h2><p>看到上图中的int 转 float、long 转 float 都是虚线表示，代表运算时自动类型转换可能会出现精度丢失的问题。经过上面对浮点型数据内存结构的学习，我们应该不难理解，float 能表示的数的大小靠指数位，但是表示的数的精度需要靠小数位。而 float 的小数位只有 23 位，而 int 是 32 位。</p><p>举个例子：int 值 16777217，二进制数 <code>1 0000 0000 0000 0000 0000 0001</code>，除去最高位符号位后，需要 25 位表示。</p><p>顺带提一下，计算某个数值除了符号位外需要多少位二进制位可以表示，除了挨个去数二进制数外，还可以直接计算 log2 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 16777217;</span><br><span class="line">double num = Math.log(i) / Math.log(2.0);</span><br><span class="line">//num = 24.000000085991324，即需要 25 位二进制位表示</span><br></pre></td></tr></table></figure><p>int 转 float，转换过程是先将 int 的数值由十进制转为二进制，再通过对二进制数左移小数点直到个位为 1，变为：<code>1. 0000 0000 0000 0000 0000 0001 * 2 ^ 24</code>，转换后的数小数点后有 24 位，对 float 来说只能舍弃掉无法表示的位数，只保留 23 位小数位，指数位 24 + 127 = 151，二进制为 <code>10010111</code>，因此转换后的 float 二进制数为 <code>110010111 + 23个0</code>，float 值为 1.6777216E7，已经丢失了精度。</p><p>同理，int 转 double，由于 double 有 52 位小数位，因此足以 hold 住 int 的精度，而 long 需要 64 位表示精度，因此 long 转 double 也可能出现精度丢失。另外需要注意的是，单位秒的时间戳，也需要 31 位来表示，用 int 表示是够的，但是转 float 也一样会丢失精度。</p><p>以上就是对 Java 类型转换精度问题的分析，希望对你有帮助 :P</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本数据类型占用内存大小&quot;&gt;&lt;a href=&quot;#基本数据类型占用内存大小&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型占用内存大小&quot;&gt;&lt;/a&gt;基本数据类型占用内存大小&lt;/h2&gt;&lt;p&gt;最近项目中修复了一个关于类型转换精度丢失的问题，以前对于类型
      
    
    </summary>
    
    
      <category term="Java" scheme="https://yazhidev.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>认识 YUV</title>
    <link href="https://yazhidev.github.io/2020/06/20/%E8%AE%A4%E8%AF%86-YUV/"/>
    <id>https://yazhidev.github.io/2020/06/20/认识-YUV/</id>
    <published>2020-06-20T12:08:53.000Z</published>
    <updated>2022-06-07T22:58:54.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-YUV"><a href="#什么是-YUV" class="headerlink" title="什么是 YUV"></a>什么是 YUV</h2><p>YUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。与RGB类似，但RGB更多的用于渲染时，而YUV则用在数据传输，因为它占用更少的频宽。当然，实时通讯为了降低带宽都会采用H264/H265编码。YUV的含义：Y代表亮度信息（灰度），UV分别代表色彩信息。YUV的常用名称有许多，例如YUV422、YUV420、YUV444等。</p><h2 id="采样格式"><a href="#采样格式" class="headerlink" title="采样格式"></a>采样格式</h2><p>YUV 后面常带着三个数字，其含义代表 YUV 信息在像素点中的分布状况，也就是<strong>采样格式</strong>：</p><ol><li><p>YUV444 代表每个 Y 对应一组 UV，每个像素占3个字节。<br> 存放码流：Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3</p></li><li><p>YUV422 代表每 2 个 Y 对应一组 UV<br> 存放码流：Y0 U0 Y1 V1 Y2 U2 Y3 V3</p></li><li><p>YUV411 代表每 4 个 Y 对应一组 UI<br> 存放码流：Y0 U0 Y1 Y2 V2 Y3</p></li><li><p>YUV420 代表每个像素独有一个 Y，每四个像素共享一个 U，每四个像素共享一个 V</p></li></ol><p>以 YUV420 为例，Y 数据有效字节数为=Height×Width；U数据有效字节数=(Height/2)×(Width/2)；V数据有效字节数=(Height/2)×(Width/2)；</p><p>YUV420 是一类格式的集合，包含 I420、NV21 等不同格式，格式不同，YUV 的排列顺序也不同（Y 的顺序是一样的，UV 不一样）。官方将 YUV 三个平面都称为颜色平面（color plane）。Android 中使用 <code>ImageProxy</code> 的 <code>getPlanes()</code> 方法可得三个平面。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200623_100350_20200622214237817_1530731484.png" alt="i420"></p><p>NV21 是，planes[1] 是 UVU，planes[2] 是 VUV。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200623_100351_20200622214254540_149960528.png" alt="nv21"></p><p>NV21 存储的 UV 数据是有冗余的，取 planes[1] 每一排的奇数字节可得所有 U 数据，取 planes[2] 每一排的偶数字节可得所有 V 数据。</p><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>上面提到的 planes 是平面的，YUV 存储在三个独立的数组中。还有另外一种存储方式：packed（打包的），YUV 是连续交错存储的。</p><p>例如 YUY2 就属于 packed 类型，数据以第一个字节存放 Y0，第二个字节存放 U0，再 Y1、V0、Y1 等等，每四个字节，Y0 和 Y1 共用 U0、V0 分量，依次类推。</p><h2 id="YUV-图像显示"><a href="#YUV-图像显示" class="headerlink" title="YUV 图像显示"></a>YUV 图像显示</h2><p>显示 YUV 图像需要使用 OpenGl 库调用 GPU 资源。或者先将 YUV 图像转换为 RGB 图像。Android 提供了 <code>YuvImage</code> 将 YUV 数据转换成 jpeg 的方法，目前只支持 NV21 和 YUY2。这里编写一段测试代码眼见为实。</p><p><a href="https://github.com/yazhidev/AndroidDemo/blob/yuv/1dev/icon.jpg" target="_blank" rel="noopener">测试图片地址</a></p><p>先使用 ffmpeg 将 jpeg 图片转为 NV21 格式用于测试：</p><p><code>ffmpeg -i icon.jpg -s 960x960 -pix_fmt nv12 nv12.yuv</code></p><p>得到 <a href="https://github.com/yazhidev/AndroidDemo/blob/yuv/1dev/nv21.yuv" target="_blank" rel="noopener">yuv 格式图片</a> 后，存放到手机目录下，然后编写测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">val file = File(Environment.getExternalStorageDirectory().path + <span class="string">"/1dev/nv21.yuv"</span>)</span><br><span class="line"><span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从本地读取 yuv 图片字节数据</span></span><br><span class="line">        val fileInputStream = FileInputStream(file)</span><br><span class="line">        var data = ByteArray(fileInputStream.available())</span><br><span class="line">        fileInputStream.read(data)</span><br><span class="line">        fileInputStream.close()</span><br><span class="line">        <span class="comment">//测试图片分辨率</span></span><br><span class="line">        val width = <span class="number">960</span></span><br><span class="line">        val height = <span class="number">960</span></span><br><span class="line">        <span class="comment">//将 yuv 图片字节数据存放到 YuvImage 中</span></span><br><span class="line">        var  yuvImage = YuvImage(data, ImageFormat.NV21, width, height, <span class="keyword">null</span>)</span><br><span class="line">        val out = ByteArrayOutputStream()</span><br><span class="line">        <span class="comment">//使用 compressToJpeg 将存储的 yuv 数据转化为 RGB 图像</span></span><br><span class="line">        yuvImage.compressToJpeg(Rect(<span class="number">0</span>, <span class="number">0</span>, width, height), <span class="number">50</span>, out)</span><br><span class="line">        val imageBytes = out.toByteArray()</span><br><span class="line">        val bitmap = BitmapFactory.decodeByteArray(imageBytes, <span class="number">0</span>, imageBytes.size)</span><br><span class="line">        iv.setImageBitmap(bitmap)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: FileNotFoundException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得 bitmap 后就可以使用 ImageView 显示了。</p><p><img src="https://yazhidev.oss-cn-hangzhou.aliyuncs.com/20200626_200450_20200624233949868_1857835977.png" alt="YUV 转换 RGB 后显示"></p><p>到这里其实还只是 api 层面的使用，后续还应该深入了解 YUV 到 RGB 的转换原理。另外 YUV 视频渲染、OpenGL es 的使用等，后续再学习记录~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-YUV&quot;&gt;&lt;a href=&quot;#什么是-YUV&quot; class=&quot;headerlink&quot; title=&quot;什么是 YUV&quot;&gt;&lt;/a&gt;什么是 YUV&lt;/h2&gt;&lt;p&gt;YUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。与RGB类似，但
      
    
    </summary>
    
    
      <category term="音视频" scheme="https://yazhidev.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Git</title>
    <link href="https://yazhidev.github.io/2020/02/21/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Git/"/>
    <id>https://yazhidev.github.io/2020/02/21/深入浅出-Git/</id>
    <published>2020-02-21T12:03:41.000Z</published>
    <updated>2022-06-07T22:58:54.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><h3 id="你可能遇到过"><a href="#你可能遇到过" class="headerlink" title="你可能遇到过"></a>你可能遇到过</h3><p><img src="http://upload-images.jianshu.io/upload_images/1929170-1df87423ad4cb974.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="版本管理"> </p><p>如果你遇到这个场景，<strong>那你可能需要版本控制</strong>。</p><h3 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h3><blockquote><p>版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了已录下来。每一次文件的改变，文件的版本号都将增加。除了记录版本变更外，版本控制的另一个重要功能是并行开发。<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/3448966" target="_blank" rel="noopener">软件开发</a>往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。并行开发中最常见的不同版本软件的错误(Bug)修正问题也可以通过版本控制中分支与合并的方法有效地解决。</p><p>—— <a href="[https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/3311252?fr=aladdin](https://baike.baidu.com/item/版本控制/3311252?fr=aladdin">版本控制 from 百度百科</a>)</p></blockquote><p>版本控制分为集中式、本地式、分布式。</p><h2 id="Git：分布式版本控制"><a href="#Git：分布式版本控制" class="headerlink" title="Git：分布式版本控制"></a>Git：分布式版本控制</h2><p>git 是一套以<strong>键值存储的文件寻址</strong>系统。</p><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p><img src="https://upload-images.jianshu.io/upload_images/1929170-9d846451dab34c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git"> </p><p>Workspace：工作区</p><p>Index：暂存区</p><p>Repository：仓库</p><p>Remote：远程仓库</p><h3 id="数据存储原理"><a href="#数据存储原理" class="headerlink" title="数据存储原理"></a>数据存储原理</h3><h4 id="SH1A-算法"><a href="#SH1A-算法" class="headerlink" title="SH1A 算法"></a>SH1A 算法</h4><p>哈希算法的一种。对文件内容进行计算，可以得到一个哈希值，形如 <code>5453545dccd33565a585ffe5f53fda3e067b84d8</code>。<br>对于内容不同的对象，会计算得到不同的SHA1哈希值。</p><h4 id="几种类型文件"><a href="#几种类型文件" class="headerlink" title="几种类型文件"></a>几种类型文件</h4><p>Git 目录（.git/objects/）的几种（对象）类型文件：</p><h5 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h5><p>用来存储文件内容，或者说表示一个（<strong>完整的</strong>）文件，而不仅仅只是差异存储。<br>Git 通过使用 zlib 压缩文件，可以有效地压缩<strong>文本文件</strong>的体积。因此 Git 比较适用于对文本文件的管理，对于二进制文件（比如音频、视频）则压缩比不大。<br>每个 blob 对象都会通过 SHA1 算法生成哈希值作为<strong>指针（或者叫索引、Key等）</strong>，指向该文件的压缩。<br>两个一样内容只是名字不同的文件，会共享同一个 blob 对象。因为内容的 SHA1 是一样的。</p><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p>这里说的 index 就是上面说的暂存区的实体存在，其实是一个文件，位于 <code>.git/index</code> ，直接打开会乱码，可以使用命令 <code>git ls-files --stage</code> 查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --stage</span><br><span class="line">----</span><br><span class="line">100644 92390d97e4159df5c7ef31baf03c8a3378c93395 0       a.txt</span><br><span class="line">100644 ff532afc325d8a07df0e2e3cb37bbee271d05840 0       dirb/b.txt</span><br></pre></td></tr></table></figure><p>里面记录了所有跟踪文件的 blob 对象的哈希值，以及文件的路径。<br>如果文件内容没有改变，index 里则一直指向旧的哈希值。</p><h5 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h5><p>代表的是目录结构，或者简单理解为代表一个目录。tree 对象也会通过 SHA1 算法生成哈希值作为指针。tree 对象中包含一条或多条 blob 的指针。<br>目录结构如果是一样的，会共享同一个 tree 对象。</p><h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5><p>commit 存储一次提交的信息，包括 tree、blob，父节点（的 commit id），以及提交的作者是谁等信息。<br>commit 的 ID 值就是对对象内容进行 SHA1 算法得到的哈希值。</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-2b25237e262ab9f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git数据存储"> </p><h3 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h3><p>git add，生成 blob 文件，同时 index 文件中记录。<br>git commit 时，根据 index 文件中记录的内容，生成 tree 对象和 commit 对象。</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>体现在目录的 <code>./git/refs/heads/</code> 中，这里包含master和一些其他分支文件。每个分支文件保存的是一个 <code>commitID</code>。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>其实就是保存了 <code>commitID</code></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>了解了原理后，再回过头来看一些常用的 Git 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git pull</span><br><span class="line">git push</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1929170-d14cf3c1b0d2f22a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git 工作流程"> </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>分享个小故事。大家应该都知道 Linux ——世界上最知名的开源操作系统，Android 系统就是基于 Linux 内核开发。它由 Linus Torvalds 在 1991 年发明，并最终经由开源社区的无数个开发者共同开发，至今仍然是最充满生命力的操作系统之一。</p><p>2005 年，Linux 开发团队一直使用的商业版本控制系统 BitKeeper 宣布不再免费授权社区使用，Linus 在各种交涉无果后，<strong>花了两周时间</strong>自己用 C 写了一个分布式版本控制系统并且开源了，一个月之内整个 Linux 系统的源码就交由 Git 管理了。至此之后 Git 迅速成为最流行的版本控制系统之一。2008 年，Github 网站上线，为开源项目免费提供 Git 存储，总多知名项目纷纷迁移至 Github，同时也造福了无数的个人开发者。</p><h3 id="开源万岁！"><a href="#开源万岁！" class="headerlink" title="开源万岁！"></a><strong>开源万岁！</strong></h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/tonyq/p/7596131.html" target="_blank" rel="noopener">Git 是如何存储文件的</a><br><a href="https://www.cnblogs.com/blog-cxj2017522/p/6902545.html" target="_blank" rel="noopener">Git底层原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h2&gt;&lt;h3 id=&quot;你可能遇到过&quot;&gt;&lt;a href=&quot;#你可能遇到过&quot; class=&quot;headerlink&quot; title=&quot;你可能遇到过&quot;&gt;&lt;/a&gt;你
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机编码原理</title>
    <link href="https://yazhidev.github.io/2019/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/"/>
    <id>https://yazhidev.github.io/2019/07/21/计算机编码原理/</id>
    <published>2019-07-21T13:10:01.000Z</published>
    <updated>2022-06-07T22:58:54.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="码表"><a href="#码表" class="headerlink" title="码表"></a>码表</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>计算机保存的是二进制代码，使用码表使每个二进制代码代替十进制数。这张表中规定了字符和二进制的映射关系。计算机存储字符时将字符查询码表，然后存储对应的二进制。计算机取出字符时将二进制查询码表，然后转换成对应的字符显示。</p><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>美国码表，码表中只有英文大小写字母、数字、美式标点符号等。每个字符占用1个字节，所有字符映射的二进制都为正数，因此有128个字符映射关系。</p><h3 id="GBK-GB18030"><a href="#GBK-GB18030" class="headerlink" title="GBK/GB18030"></a>GBK/GB18030</h3><p>GBK 编码是使用双字节来表示的，即不论中、英文字符均使用双字节来表示，为了区分中文，将其最高位都设定成1。GBK包含全部中文字符，是国家编码，通用性比UTF8差，不过UTF8占用的数据库比GBK大。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode 是一个很大的集合，是十六进制的，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。</p><p>Unicide 是一个符号集，规定了符号的二进制代码，却没有规定如何存储二进制代码。那么如何区别 unicode 和 ascii 呢？计算机怎么知道三个字节表示一个符号，而不是三个符号？于是就衍生了 UTF-8。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8 是 unicode 的一种实现方式之一。它是一种可变长度字符集,每个字符编码最多四个字节。</p><p>UTF-8的编码规则很简单，只有二条： </p><ol><li><p>对于单字节的符号，字节的第一位（字节的最高位）设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 </p></li><li><p>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p></li></ol><table><thead><tr><th>Unicode符号范围 (十六进制)</th><th>UTF-8编码方式 （二进制） </th></tr></thead><tbody><tr><td>0000 0000-0000 007F</td><td>0xxxxxxx </td></tr><tr><td>0000 0080-0000 07FF</td><td>110xxxxx 10xxxxxx </td></tr><tr><td>0000 0800-0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx </td></tr><tr><td>0001 0000-0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx </td></tr></tbody></table><p>因此对于英语字母，使用 utf-8 与 ascii 是一样的。</p><p>UTF-8 存储的字符，除了第一个字节外，其余字节的头两个比特都是以”10”开始，使文字处理器能够较快地找出每个字符的开始位置。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>例如“严”，unicode 字符是 <code>4E25（100111000100101）</code>，<code>4e25</code> 在第三行范围，因此需要三个字节，将二进制码以此替换掉上面的 x，得到最终的 utf-8 编码为：<code>11100100 10111000 10100101</code>。转换成十六进制就是<code>E4B8A5</code></p><p>虽然 utf-8 具有良好的国际通用性，但是 utf-8 中的中文使用三个字节来编码，比 gbk 多占用了 50% 的存储空间。下面来介绍 gbk 编码方式。</p><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>是基于 64 个可打印的字符来表示二进制的数据的一种方法，用于解决中文、日文等文字无法被服务器或网关有效处理。</p><p>64 个字符：A~Z、a~z、0~9、+、/，还会使用 = 做填充字符</p><h3 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h3><ol><li>三个字节分一组，每个字节 8 位，总共 24 位</li><li>将 24 位每 6 位分一组，共分为四组（如果不足6位则补0，如果 6 位全是空的，则使用 = 号代替）</li><li>每组前面添加 2 个 0，变为 8 位二进制位，共四个字节</li><li>使用每个字节的值作索引，获得对应的值</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/wo541075754/article/details/81734770" target="_blank" rel="noopener">一篇文章彻底弄懂Base64编码原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;码表&quot;&gt;&lt;a href=&quot;#码表&quot; class=&quot;headerlink&quot; title=&quot;码表&quot;&gt;&lt;/a&gt;码表&lt;/h2&gt;&lt;h3 id=&quot;理解&quot;&gt;&lt;a href=&quot;#理解&quot; class=&quot;headerlink&quot; title=&quot;理解&quot;&gt;&lt;/a&gt;理解&lt;/h3&gt;&lt;p&gt;计算机
      
    
    </summary>
    
    
      <category term="计算机原理" scheme="https://yazhidev.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《Kotlin 核心编程》读书笔记</title>
    <link href="https://yazhidev.github.io/2019/07/17/%E3%80%8AKotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://yazhidev.github.io/2019/07/17/《Kotlin-核心编程》读书笔记/</id>
    <published>2019-07-17T14:04:57.000Z</published>
    <updated>2022-06-07T22:58:54.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="密封类-sealed"><a href="#密封类-sealed" class="headerlink" title="密封类 sealed"></a>密封类 sealed</h3><p>密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。</p><h3 id="第五章-类型系统"><a href="#第五章-类型系统" class="headerlink" title="第五章 类型系统"></a>第五章 类型系统</h3><p><code>as</code> 不安全的类型转换，转换失败会抛类型转换失败异常。使用 <code>as？</code> 转换失败返回 null。</p><p>Int 等同于 int</p><p>Int? 等同于 Integer</p><h4 id="协变与不变"><a href="#协变与不变" class="headerlink" title="协变与不变"></a>协变与不变</h4><p>java 中数组是协变的，意思就是任意 A 是 B 的父类，则 A[] 也是 B[] 的父类。</p><p>List 是不变的，只知道自己是一个 Lit，无法获取泛型参数的类型。Kotlin 中数值支持泛型，当然也不再协变。Any 是所有类的父类，但是你不能将任意一个对象数组赋值给 Array<any>。</any></p><p>Kotlin 中 List 是协变的。因为 Kotlin 中 List 的定义是 <code>publick interface List&lt;out E&gt; : Collection&lt;E&gt; {}</code>，out 关键字，说明泛型类和泛型方法是协变的。为了保证类型安全，kotlin 中的 List 是无法添加元素的。</p><h4 id="获取泛型类型"><a href="#获取泛型类型" class="headerlink" title="获取泛型类型"></a>获取泛型类型</h4><ol><li><p>通过匿名内部类</p><p> 泛型虽然是类型擦除的，但是类型信息是放在对应 class 的常量池中的。匿名内部类在初始化的时候会绑定父类或父接口的相应信息。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val list = object: ArrayLisr&lt;String&gt;()</span><br><span class="line">print(list.javaClass.genericSuperclass)</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>使用内联函数</p><p> kotlin 内联函数在编译的时候编译期会将相应的字节码插入调用的地方，也就是说，参数类型也会被插入字节码中。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在kotlin中一个内联函数（inline）可以被具体化（reified），这意味着我们可以得到使用泛型类型的Class</span><br><span class="line">inline fun &lt;reified T&gt; getType() &#123;</span><br><span class="line">    return T::class.java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>需要注意的是，Java 并不支持指定一个函数是否内联，所以 reified 来实例化的内联函数不能在 Java 中调用，因为它永远是需要内联的。</code></pre><h4 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h4><p><out t>  -&gt; Java 中的 &lt;? extends T&gt;</out></p><p><in t>  -&gt; Java 中的 &lt;? super T&gt;</in></p><h2 id="第-6-章-Lambda-和集合"><a href="#第-6-章-Lambda-和集合" class="headerlink" title="第 6 章 Lambda 和集合"></a>第 6 章 Lambda 和集合</h2><h3 id="序列-sequence"><a href="#序列-sequence" class="headerlink" title="序列 sequence"></a>序列 sequence</h3><p>序列是惰性求值（延时求值）的，普通集合进行链式操作是（例如 filter、map），每一步都会先产生新的集合，而序列则是将所有操作都应用在一个元素上，当第一个元素执行完 filter、map 后，第二个元素再继续执行 filter、map。</p><p>与 Java8 的流（Stream）不同，流是一次性的，只能遍历一次。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>inline 修饰的函数，会被内联进调用它的地方。直接在字节码中生成相应的函数体实现</p><h4 id="实现非局部返回"><a href="#实现非局部返回" class="headerlink" title="实现非局部返回"></a>实现非局部返回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun localReturn() &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fun foo() &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    localReturn()</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//打印出12</span><br></pre></td></tr></table></figure><p>因为函数体中的 return 只会在该函数的局部生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun foo(returning: () -&gt; Unit) &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    returning()</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//报错：Lambda 中不允许存在 return</span><br></pre></td></tr></table></figure><p>这时可以使用内联函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun foo(returning: () -&gt; Unit) &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    returning()</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用标签实现 Lambda 非局部返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    foo &#123;return@foo&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第七章-多态和扩展"><a href="#第七章-多态和扩展" class="headerlink" title="第七章 多态和扩展"></a>第七章 多态和扩展</h2><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>operator 关键字叫上 Kotlin 规定的函数名：plus（加法），minus（减法），times（乘法），div（除法），mod（取余）等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data class Area(val valus: Double)</span><br><span class="line"></span><br><span class="line">operator fun Area.plus(that: Area): Area &#123;</span><br><span class="line">    return Area(this.value + that.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    print(Area(1.0) + Area(2.0))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展函数实现机制"><a href="#扩展函数实现机制" class="headerlink" title="扩展函数实现机制"></a>扩展函数实现机制</h3><p>可以将扩展函数理解为静态方法。</p><p>使用扩展函数添加属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val Mutablelist&lt;Int&gt;.sumIsEven: Boolean</span><br><span class="line">    get() = this.sum() % 2 == 0</span><br></pre></td></tr></table></figure><h3 id="静态与动态调度"><a href="#静态与动态调度" class="headerlink" title="静态与动态调度"></a>静态与动态调度</h3><p>调用重载方法时，调用变为静态并且取决于编译时类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(Base base) &#123;&#125;</span><br><span class="line"></span><br><span class="line">void foo(Extanded base) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Base base = new Extended()</span><br><span class="line">foo(base) //调用的是 Base 参数类型的方法</span><br></pre></td></tr></table></figure><h2 id="第九章-设计模式"><a href="#第九章-设计模式" class="headerlink" title="第九章 设计模式"></a>第九章 设计模式</h2><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><ol><li>使用类委托减少样板代码</li></ol><p>使用 by 关键字，将装饰类的所有方法委托给被装饰对象，然后只需要复写需要装饰的方法即可。</p><ol start="2"><li>使用扩展函数代替装饰者</li></ol><h2 id="第十章-函数式编程"><a href="#第十章-函数式编程" class="headerlink" title="第十章 函数式编程"></a>第十章 函数式编程</h2><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>也称正则序，当用到时才求值</p><h2 id="第十一章-异步和并发"><a href="#第十一章-异步和并发" class="headerlink" title="第十一章 异步和并发"></a>第十一章 异步和并发</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步指的是一个行为，当执行的时候，在代码层面需要我们主动去等待结果，直到结果返回。</p><p>多线程执行时看上去是同步执行，但是线程执行是通过 CPU 调度，CPU 在每个线程间快速切换，同一个时间片内只能执行一个线程。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是一个无优先级的子程序调度组件，允许子程序。线程包含于进程，协程包含于线程。只要内存只够， 一个线程中可以有任意多个协程，但某一个时刻只能有一个协程在运行，多个协程共享该线程分配到的计算机资源。</p><h4 id="launch-和-runBlocking"><a href="#launch-和-runBlocking" class="headerlink" title="launch 和 runBlocking"></a>launch 和 runBlocking</h4><p>runBloking 是最高级的协程，也就是主协程。launch 创建的线程能够在 runBlocking 中运行，反过来不行。runBlocking 会阻塞当前执行的线程。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val job = launch &#123;</span><br><span class="line">    search()</span><br><span class="line">&#125;</span><br><span class="line">job.join()</span><br></pre></td></tr></table></figure><p>join 后程序会一直等待，直到启动的协程结束。这里的等待是非阻塞式的等待，不会将当前线程挂起。</p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>会创建一个子协程，会和其他子协程一样并行工作。async 会返回一个 Deferred 对象。Deferred 值是一个非阻塞可取消的 future，是一个带有结果的 job。</p><p>future 的意思是，将来会返回一个结果，利用 await 方法可以等待这个值的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第四章&quot;&gt;&lt;a href=&quot;#第四章&quot; class=&quot;headerlink&quot; title=&quot;第四章&quot;&gt;&lt;/a&gt;第四章&lt;/h2&gt;&lt;h3 id=&quot;密封类-sealed&quot;&gt;&lt;a href=&quot;#密封类-sealed&quot; class=&quot;headerlink&quot; title=&quot;密
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://yazhidev.github.io/tags/Kotlin/"/>
    
      <category term="读书笔记" scheme="https://yazhidev.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>理解 WindowManagerService</title>
    <link href="https://yazhidev.github.io/2019/04/15/%E7%90%86%E8%A7%A3%20WindowManagerService%20/"/>
    <id>https://yazhidev.github.io/2019/04/15/理解 WindowManagerService /</id>
    <published>2019-04-15T00:20:00.000Z</published>
    <updated>2022-06-07T22:58:54.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>是一个抽象类，唯一的实现类是 PhoneWindow</p><p>分类：</p><ol><li><p>父 Window</p></li><li><p>子 Window，不能单独存在，需要依附在父 window 上，例如 dialog</p></li><li><p>系统 Window，例如 toast</p></li></ol><h3 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h3><p>在 Activity attach 时构造了 PhoneWindow 的实例对象。</p><h3 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h3><p>是一个接口，用于操作 Window，继承了 ViewManager。实现类是 WindowManagerImpl</p><p>ViewManager 的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params);</span><br><span class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params);</span><br><span class="line">public void removeView(View view);</span><br></pre></td></tr></table></figure><p>可以看到三个操作方法都是针对 View 的，View 是 Window 的实体类</p><h3 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h3><p>没有直接操作 View，而是交个了 mGlobal（WindowManagerGlobal）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h3><p>保存了所有的 ViewRootImpl，在 addView 时会创建 ViewRootImpl 实例，并将要 add 的 View 设置给 ViewRootImpl（见源码 1.1）</p><p>View 的绘制过程是由 ViewRootImpl 来完成的。在新建一个 Activity 时，这个要 add 的 View 就是 DecorView。</p><h3 id="IWindowSession"><a href="#IWindowSession" class="headerlink" title="IWindowSession"></a>IWindowSession</h3><p>(AIDL)窗口令牌，描述了一个显示行为，并且WMS要求每一个窗口必须隶属于某一个显示令牌。</p><h3 id="WindowState"><a href="#WindowState" class="headerlink" title="WindowState"></a>WindowState</h3><p>当向WMS添加一个窗口时，WMS会为其创建一个WindowState。</p><h3 id="WindowManagerService（WMS）"><a href="#WindowManagerService（WMS）" class="headerlink" title="WindowManagerService（WMS）"></a>WindowManagerService（WMS）</h3><p>WMS为所有窗口分配Surface，掌管Surface的显示顺序（Z-order）以及位置尺寸，控制窗口动画，并且还是输入系统的一重要的中转站。</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-32447838580d50e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Window 体系图"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//WindowManagerGlobal </span><br><span class="line"></span><br><span class="line">private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"></span><br><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">            Display display, Window parentWindow) &#123;</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">mRoots.add(root);</span><br><span class="line">root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yhaolpz/article/details/68936932" target="_blank" rel="noopener">Android 带你彻底理解 Window 和 WindowManager</a></p><p><a href="https://blog.csdn.net/wf_fln/article/details/78593080" target="_blank" rel="noopener">深入理解WindowManagerService</a></p><p><a href="https://blog.csdn.net/afu10086/article/details/80138154" target="_blank" rel="noopener">WindowManagerService 分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h2&gt;&lt;h3 id=&quot;Window&quot;&gt;&lt;a href=&quot;#Window&quot; class=&quot;headerlink&quot; title=&quot;Windo
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread、IntentService 理解</title>
    <link href="https://yazhidev.github.io/2019/04/02/HandlerThread%E3%80%81IntentService%E7%90%86%E8%A7%A3/"/>
    <id>https://yazhidev.github.io/2019/04/02/HandlerThread、IntentService理解/</id>
    <published>2019-04-02T00:20:16.000Z</published>
    <updated>2022-06-07T22:58:54.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread 继承 Thread，HandlerThread 本质上就是一个普通 Thread，只不过内部建立了 Looper，因此拥有自己的消息队列。不适合频繁处理耗时操作，因为消息是串行处理的，某个人任务执行时间过长，会导致后续的任务被延迟处理</p><p>通过调用 Thread 的 start 方法开始运行<br>结束消息轮询也是通过操作 Looper 实现的，退出 Looper 后，线程没有可执行代码，则会自动结束</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>在 run 方法内初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepare();</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">Process.setThreadPriority(mPriority);</span><br><span class="line">onLooperPrepared();</span><br><span class="line">Looper.loop(); //开启轮询，因此除非主动退出，否则线程不会结束</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean quit() &#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    if (looper != null) &#123;</span><br><span class="line">        looper.quit();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个 quitSafely 方法。二者的区别是调用了 MessageQueue 的 <code>void quit(boolean safe)</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// MessageQueue</span><br><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">···</span><br><span class="line">if (safe) &#123;</span><br><span class="line">        removeAllFutureMessagesLocked();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        removeAllMessagesLocked();</span><br><span class="line">    &#125;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// removeAllMessagesLocked 方法，将队列里的所有消息不经检查直接回收</span><br><span class="line">private void removeAllMessagesLocked() &#123;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//removeAllFutureMessagesLocked 会将延时消息移除，非延迟消息会派发</span><br><span class="line">private void removeAllFutureMessagesLocked() &#123;</span><br><span class="line">    final long now = SystemClock.uptimeMillis();</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    if (p != null) &#123;</span><br><span class="line">        if (p.when &gt; now) &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Message n;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                n = p.next;</span><br><span class="line">                if (n == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (n.when &gt; now) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                p = n;</span><br><span class="line">                n = p.next;</span><br><span class="line">                p.recycleUnchecked();</span><br><span class="line">            &#125; while (n != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>四大组件是在主线程的，不可执行耗时操作。<br>IntentService 是个抽象类，需要实现抽象方法 onHandleIntent（可在该方法内执行耗时操作）。IntentService 会拥有消息队列（内部使用了 HandlerThread 的 Looper），且会在回调 onHandleIntent 后自动 stopSelf，销毁 Service。</p><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">super.onCreate();</span><br><span class="line">    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); //创建 HandlerThread 实例，并开启线程（Looper 轮询）</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ServiceHandler 收到消息后回调 onHandleIntent，执行用户的操作，执行完后销毁自身</span><br><span class="line">private final class ServiceHandler extends Handler &#123;</span><br><span class="line">    public ServiceHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开启 Service 后就发送个消息</span><br><span class="line">@Override</span><br><span class="line">public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HandlerThread&quot;&gt;&lt;a href=&quot;#HandlerThread&quot; class=&quot;headerlink&quot; title=&quot;HandlerThread&quot;&gt;&lt;/a&gt;HandlerThread&lt;/h2&gt;&lt;p&gt;HandlerThread 继承 Thread，Ha
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型</title>
    <link href="https://yazhidev.github.io/2019/03/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://yazhidev.github.io/2019/03/28/Java-内存模型/</id>
    <published>2019-03-27T23:46:13.000Z</published>
    <updated>2022-06-07T22:58:54.438Z</updated>
    
    <content type="html"><![CDATA[<p>Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。</p><p>经典问题：</p><p>20 个线程，每个线程都对同一个 int 做自增操作 100 次，最后的结果 i 一定小余 2000。</p><p>Java中的运算操作，例如自增或自减，若没有进行额外的同步操作，在多线程环境下就是线程不安全的。num++解析为num=num+1，明显，这个操作不具备原子性，多线程并发共享这个变量时必然会出现问题。</p><p>原因：</p><p>普通变量的值在线程间传递都需要通过主内存来完成。例如，线程 A 修改了一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。 </p><p>Java中的原子操作包括： </p><ul><li>除long和double之外的基本类型的赋值操作（long和double占用的字节数都是8，在32位操作系统上对64位的数据的读写要分两步完成，虽然 volatile 只保证可见性，但 java 内存模型保证声明为 volatile 的long和double变量的get和set操作是原子的。）</li><li>所有引用reference的赋值操作 </li><li>java.concurrent.Atomic.* 包中所有类的一切操作。 </li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>一个线程对一个变量进行更改操作 其他线程获取会获得最新的值</p><p>sleep 方法并没有加锁，为什么能够保证可见性。sleep是阻塞线程并不释放锁，让出cpu调度。让出cpu调度后下次执行会刷新工作内存</p><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>在单线程中不影响最终结果，jvm 会对指令做优化排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在线程A中执行:</span><br><span class="line"></span><br><span class="line">context = loadContext(); （1）</span><br><span class="line">contextReady = true; （2）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在线程B中执行:</span><br><span class="line"></span><br><span class="line">if(contextReady) &#123;</span><br><span class="line">   context.xxx </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1，2 的顺序可能因为指令重排做了调换。先执行2，再执行1。</p><p>因此在多线程中可能导致线程 B 中， context 还没有初始化，但 contextReady 已经是 true，就报空指针。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>1.阻止屏障两侧的指令重排序；<br>2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li><p>内存屏障策略：</p><p>  在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</p><p>  在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p></li></ul><p>因此 volatile 可以做到：</p><ol><li><p>线程的可见性</p><p> volatile 变量在各个线程的工作内存中不存在一致性问题。因为每次赋值后，都会通过内存屏障更新主存中的值。</p></li><li><p>禁止指令重排</p><p> 因为每次读写前后都会插入内存屏障，而内存屏障前后的指令不可被重排。</p></li></ol><p>但是需要注意的是 volatile 只保证可见性，并不保证原子性。为了实现上述 i++ 的原子性运算，需要用到实现线程安全的两个保障手段：阻塞同步和非阻塞同步都是。</p><ul><li><p>阻塞同步</p><p>  即加锁。但是会带来线程阻塞和唤醒的性能开销</p></li><li><p>非阻塞同步</p><p>  对于阻塞同步而言主要解决了阻塞同步中线程阻塞和唤醒带来的性能问题。在并发环境下，某个线程对共享变量先进行操作，如果没有其他线程争用共享数据那操作就成功；如果存在数据的争用冲突，那就才去补偿措施，比如不断的重试机制，直到成功为止，因为这种乐观的并发策略不需要把线程挂起，也就把这种同步操作称为非阻塞同步（操作和冲突检测具备原子性）。Java 中实现 CAS 乐观锁的方式是使用 AtomicInteger。</p></li></ul><h2 id="CAS（Compare-And-Swap-比较并交换）"><a href="#CAS（Compare-And-Swap-比较并交换）" class="headerlink" title="CAS（Compare-And-Swap 比较并交换）"></a>CAS（Compare-And-Swap 比较并交换）</h2><p>CAS 操作包含三个操作数：内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p><p>Java 的 CAS 会使用 cpu 上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作。但 CAS 也存在一些问题：</p><ol><li><p>ABA 问题</p><p> 如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p></li><li><p>循环时间长开销大</p></li></ol><ol start="3"><li><p>只能保证一个共享变量的原子操作</p><p> AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p></li></ol><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>依赖于 Unsafe 提供的一些底层能力，实现了 CAS 的乐观锁。如果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// AtomicInteger</span><br><span class="line">private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">private static final long VALUE;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        VALUE = U.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); //用于返回类定义的某个属性在主存中设定的偏移量</span><br><span class="line">    &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile int value; //使用 volatile 保证可见性</span><br><span class="line"></span><br><span class="line">public AtomicInteger(int initialValue) &#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//原子性的加法运算，依赖 Unsafe 类</span><br><span class="line">public final int addAndGet(int delta) &#123;</span><br><span class="line">    return U.getAndAddInt(this, VALUE, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Unsafe</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2); //通过对象引用地址和 value 值的偏移量，获取 value 的值</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// natUnsafe.cc 底层实现</span><br><span class="line"></span><br><span class="line">jboolean</span><br><span class="line">sun::misc::Unsafe::compareAndSwapInt (jobject obj, jlong offset,</span><br><span class="line">      jint expect, jint update)</span><br><span class="line">&#123;</span><br><span class="line">  jint *addr = (jint *)((char *)obj + offset);</span><br><span class="line">  return compareAndSwap (addr, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline bool</span><br><span class="line">compareAndSwap (volatile jint *addr, jint old, jint new_val)</span><br><span class="line">&#123;</span><br><span class="line">  jboolean result = false;</span><br><span class="line">  spinlock lock;</span><br><span class="line">  if ((result = (*addr == old))) //如果值不相等就什么也不做，返回 false</span><br><span class="line">    *addr = new_val;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。&lt;/p&gt;
&lt;p&gt;经典问题：&lt;/p&gt;
&lt;p&gt;20 个线程，每个线程都对同一个 int 做自增操作 100 次，最后的结果 i 一定小余 2000。&lt;/p&gt;
&lt;p&gt;Java中的运算操作，例如
      
    
    </summary>
    
    
      <category term="Java" scheme="https://yazhidev.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析 Binder 机制</title>
    <link href="https://yazhidev.github.io/2019/03/15/%E6%B5%85%E6%9E%90-Binder-%E6%9C%BA%E5%88%B6/"/>
    <id>https://yazhidev.github.io/2019/03/15/浅析-Binder-机制/</id>
    <published>2019-03-15T00:37:24.000Z</published>
    <updated>2022-06-07T22:58:54.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ol><li><p>进程隔离</p><p> 进程隔离，不同进程之间，不共享内存。而操作系统是多进程的，因此需要 IPC。</p></li><li><p>进程空间划分</p><p> Kernel 是操作系统的核心，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。因此把 Kernel 和上层的应用程序隔离，分为内核空间和用户空间。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1929170-e63a92df044802ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程隔离"></p><p>Android 利用了 Linux 的动态可加载内核模块机制，使 Binder 驱动运行在内核空间，负责各个用户进程通信。</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-f42db494f98df733.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder 机制"></p><h3 id="Binder-通信模型：C-S-模型"><a href="#Binder-通信模型：C-S-模型" class="headerlink" title="Binder 通信模型：C/S 模型"></a>Binder 通信模型：C/S 模型</h3><p>通信过程：</p><ol><li>Server 向 ServiceManager 也是通过发送 Binder 消息注册。ServiceManager 是比较特殊的服务，所有应用都能直接使用，因为ServiceManager对于Client端来说Handle句柄是固定的，都是0，所以ServiceManager服务并不需要查询，可以直接使用。</li><li>client 通过 ServiceManager 获得一个 server 的 Binder 实体的代理，对 server 进行调用。代理接口中定义的方法与 server 中定义的方法时一一对应的。</li><li>client 调用某个代理接口中的方法时，代理接口的方法会将 client 传递的参数打包成 Parcel 对象。client 线程挂起。</li><li>代理接口将 Parcel 发送给内核中的 binder 驱动。驱动通过一系列调用，将请求派发给 server 的 Binder 本地对象的 onTransact 方法。</li><li>onTransact 方法解包 Parcel 对象，处理并将结果返回给 binder 驱动，驱动唤醒 client 线程，并将结果返回。</li></ol><p>Android APP进程都是由Zygote进程孵化出来的。常见场景：点击桌面icon启动APP，或者startActivity启动一个新进程里面的Activity，最终都会由AMS去调用Process.start()方法去向Zygote进程发送请求，让Zygote去fork一个新进程，Zygote收到请求后会调用Zygote.forkAndSpecialize()来fork出新进程,之后会通过RuntimeInit.nativeZygoteInit来初始化Andriod APP运行需要的一些环境，而binder线程就是在这个时候新建启动的。</p><p>IPC 是一个概念，Binder 是一种 IPC 的具体实现；AIDL 是 Binder 机制向外提供的接口，目的就是为了方便对 Binder 的使用；</p><p>Android 系统匿名共享内存 Ashmem，其作用之一即通过 Binder 进程间通信机制来实现进程间的内存共享。 </p><p>Client 进程只不过是持有了 Server端的代理；代理对象协助驱动完成了跨进程通信。</p><p>对 Server 来说，Binder 就是 Binder 本地对象，对 Client 来说, Binder 是 Binder 本地对象的代理。在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册。</p><p>我们所持有的Binder引用(即服务端的类引用)并不是实际真实的远程Binder对象，我们的引用在Binder驱动里还要做一次映射。客户端要调用远程对象函数时，只需把数据写入到Parcel，在调用所持有的Binder引用的transact()函数，transact函数执行过程中会把参数、标识符（标记远程对象及其函数）等数据放入到Client的共享内存，Binder驱动从Client的共享内存中读取数据，根据这些数据找到对应的远程进程的共享内存，把数据拷贝到远程进程的共享内存中，并通知远程进程执行onTransact()函数。远程进程Binder对象执行完成后，将结果写入自己的共享内存中，Binder驱动再将远程进程的共享内存数据拷贝到客户端的共享内存，并唤醒客户端线程。</p><p>整个的调用过程是一个同步过程，在server处理的时候，client会block住。因此client调用过程不应在主线程。</p><p>区别于传统的 IPC 的两次拷贝， Binder 机制使用内存映射。</p><p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。<br>只需要一次拷贝（用户内核到服务内核的拷贝）内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>Client 连接 Server 时，需要创建一个 ServiceConnection 作为入参，ServiceConnection 的回调方法 onServiceConnected 中会通过 asInterface(IBinder binder) 拿到 IBinder 对象，如果 Client 和 Server 在同一个进出，binder 就是 Binder 本地对象，否则是一个代理对象。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5acccf845188255c3201100f#heading-23" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a></p><p><a href="https://blog.csdn.net/augfun/article/details/82343249" target="_blank" rel="noopener">简单理解Binder机制的原理</a></p><p><a href="https://blog.csdn.net/china0851/article/details/87945740" target="_blank" rel="noopener">https://blog.csdn.net/china0851/article/details/87945740</a></p><p><a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">Binder系列5—注册服务(addService)</a></p><p><a href="https://juejin.im/post/58c90816a22b9d006413f624" target="_blank" rel="noopener">听说你Binder机制学的不错，来解决下这几个问题（一）</a></p><p><a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;几个概念&quot;&gt;&lt;a href=&quot;#几个概念&quot; class=&quot;headerlink&quot; title=&quot;几个概念&quot;&gt;&lt;/a&gt;几个概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进程隔离&lt;/p&gt;
&lt;p&gt; 进程隔离，不同进程之间，不共享内存。而操作系统是多进程的，因此需要 IPC。&lt;/
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 焦点分发机制梳理</title>
    <link href="https://yazhidev.github.io/2019/03/13/Android-%E7%84%A6%E7%82%B9%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%A2%B3%E7%90%86/"/>
    <id>https://yazhidev.github.io/2019/03/13/Android-焦点分发机制梳理/</id>
    <published>2019-03-13T11:45:06.000Z</published>
    <updated>2022-06-07T22:58:54.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><p>连接 DecorView， Window</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-c5ffeb5b3fc4096d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>DecorView -&gt; Activity -&gt; PhoneWindow -&gt; DecorView 的来回绕一圈。</p><p>既然触摸事件已经到了 Activity.dispatchTouchEvent() 中了，为什么不直接分发给 DecorView ，而是要通过PhoneWindow 来间接发送呢？因为 Activity 不知道有 DecorView 这种奇怪的东西存在啊！不知道！但是，Activity 持有 PhoneWindow ，而 PhoneWindow 当然知道自己的窗口里有些什么了，所以能够把事件派发给DecorView 。你看，在 Android 中，Activity 并不知道自己的 Window 中有些什么，这样耦合性就很低了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Activity</span><br><span class="line"></span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    ... </span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        //又把事件传到了Window中！</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return onTouchEvent(ev); </span><br><span class="line">    //这就是为什么最后事件没有被消费的话，Activity会去处理的原因。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InputStage-策略"><a href="#InputStage-策略" class="headerlink" title="InputStage 策略"></a>InputStage 策略</h2><p>在 RootViewImpl 中的函数通道是各种策略（InputStage）的组合，各策略负责的任务不同，如SyntheticInputStage、ViewPostImeInputStage、NativePostImeInputStage 等等，这些策略以链表结构结构起来，当一个策略者没有消费事件时，就传递个下一个策略者。其中触摸和按键事件由 ViewPostImeInputStage 处理。</p><p>ViewPostImeInputStage 是 ViewRootImpl 的内部类，</p><h2 id="分发-KeyEvent"><a href="#分发-KeyEvent" class="headerlink" title="分发 KeyEvent"></a>分发 KeyEvent</h2><ol><li><p>ViewPostImeInputStage</p><p>-&gt; onProcess (KeyEvent)</p><p>-&gt; processKeyEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">private int processKeyEvent(QueuedInputEvent q) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Deliver the key to the view hierarchy.</span><br><span class="line">    // mView 即 DecorView</span><br><span class="line">    if (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">        return FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // Handle automatic focus changes.</span><br><span class="line">   if (performFocusNavigation(event)) &#123;</span><br><span class="line">        return FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean performFocusNavigation(KeyEvent event) &#123;</span><br><span class="line">    int direction = 0;</span><br><span class="line">    switch (event.getKeyCode()) &#123;</span><br><span class="line">        case KeyEvent.KEYCODE_DPAD_LEFT:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case KeyEvent.KEYCODE_DPAD_RIGHT:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_RIGHT;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case KeyEvent.KEYCODE_DPAD_UP:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_UP;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case KeyEvent.KEYCODE_DPAD_DOWN:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_DOWN;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case KeyEvent.KEYCODE_TAB:</span><br><span class="line">            if (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_FORWARD;</span><br><span class="line">            &#125; else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">                direction = View.FOCUS_BACKWARD;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (direction != 0) &#123;</span><br><span class="line">        View focused = mView.findFocus();</span><br><span class="line">        if (focused != null) &#123;</span><br><span class="line">            View v = focused.focusSearch(direction);</span><br><span class="line">            if (v != null &amp;&amp; v != focused) &#123;</span><br><span class="line">                // do the math the get the interesting rect</span><br><span class="line">                // of previous focused into the coord system of</span><br><span class="line">                // newly focused view</span><br><span class="line">                focused.getFocusedRect(mTempRect);</span><br><span class="line">                if (mView instanceof ViewGroup) &#123;</span><br><span class="line">                    ((ViewGroup) mView).offsetDescendantRectToMyCoords(</span><br><span class="line">                            focused, mTempRect);</span><br><span class="line">                    ((ViewGroup) mView).offsetRectIntoDescendantCoords(</span><br><span class="line">                            v, mTempRect);</span><br><span class="line">                &#125;</span><br><span class="line">                if (v.requestFocus(direction, mTempRect)) &#123;</span><br><span class="line">                    playSoundEffect(SoundEffectConstants</span><br><span class="line">                            .getContantForFocusDirection(direction));</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Give the focused view a last chance to handle the dpad key.</span><br><span class="line">            if (mView.dispatchUnhandledMove(focused, direction)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mView.restoreDefaultFocus()) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DecorView</p><p>-&gt; dispatchKeyEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">    // Let the focused view and/or our descendants get the key first</span><br><span class="line">    return super.dispatchKeyEvent(event) || executeKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ViewGroup</p><p>-&gt; dispatchKeyEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if ((mPrivateFlags &amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS))</span><br><span class="line">            == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) &#123;</span><br><span class="line">        if (super.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (mFocused != null &amp;&amp; (mFocused.mPrivateFlags &amp; PFLAG_HAS_BOUNDS)</span><br><span class="line">            == PFLAG_HAS_BOUNDS) &#123;</span><br><span class="line">        if (mFocused.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类（View）处理了（return true），则不往下传。或者 mFocused 不为空，先 mFocused 分发，如果 mFocused 没有处理（返回 true），则 DecorView 最终返回 false，交由 ViewRoomImpl 继续处理。</p></li><li><p>View</p><p>-&gt; dispatchKeyEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ListenerInfo li = mListenerInfo;</span><br><span class="line">    if (li != null &amp;&amp; li.mOnKeyListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出，要拦截焦点分发，可以：</p><ul><li>设置 OnKeyListener 监听</li><li>重写 dispatchKeyEvent 方法并返回 true</li></ul></li><li><p>mView 分发焦点之后没有被处理，会先根据 KeyCode 为 direction 赋值，用于后续的寻找焦点。<code>View focused = mView.findFocus()</code> 会一层一层往下直到返回当前持有焦点的 View，如果 DecorView 的子 view 持有焦点（focused），则调用 focused 的 focusSearch 方法寻找下一个焦点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//ViewGroup</span><br><span class="line">@Override</span><br><span class="line">public View focusSearch(View focused, int direction) &#123;</span><br><span class="line">    if (isRootNamespace()) &#123;</span><br><span class="line">        // root namespace means we should consider ourselves the top of the</span><br><span class="line">        // tree for focus searching; otherwise we could be focus searching</span><br><span class="line">        // into other tabs.  see LocalActivityManager and TabHost for more info.</span><br><span class="line">        return FocusFinder.getInstance().findNextFocus(this, focused, direction);</span><br><span class="line">    &#125; else if (mParent != null) &#123;</span><br><span class="line">        return mParent.focusSearch(focused, direction);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//View</span><br><span class="line">public View focusSearch(@FocusRealDirection int direction) &#123;</span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        return mParent.focusSearch(this, direction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 focusSearch 方法最终调用 <code>FocusFinder.getInstance().findNextFocus(this, focused, direction)</code> 来寻找下一个获取焦点的 View。FocusFinder 会优先通过 View 在 XML 布局设置的下一个焦点的 ID 来查找焦点。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/b7cef3b3e703" target="_blank" rel="noopener">点击事件 InputStage</a></p><p><a href="https://juejin.im/entry/58f0212161ff4b0058e1b25f" target="_blank" rel="noopener">Android 焦点事件分发与传递机制</a></p><p><a href="https://www.jianshu.com/p/a633727ccb29" target="_blank" rel="noopener">焦点 inputStage 相关</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ViewRootImpl&quot;&gt;&lt;a href=&quot;#ViewRootImpl&quot; class=&quot;headerlink&quot; title=&quot;ViewRootImpl&quot;&gt;&lt;/a&gt;ViewRootImpl&lt;/h2&gt;&lt;p&gt;连接 DecorView， Window&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动模式</title>
    <link href="https://yazhidev.github.io/2019/03/13/Android-%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yazhidev.github.io/2019/03/13/Android-启动模式/</id>
    <published>2019-03-13T09:58:33.000Z</published>
    <updated>2022-06-07T22:58:54.435Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关的概念"><a href="#相关的概念" class="headerlink" title="相关的概念"></a>相关的概念</h3><p><img src="https://upload-images.jianshu.io/upload_images/1929170-4fe897deaa6cf32b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关系图"></p><ol><li><p>ActivityStack</p><p> 应用程序在一个单例的 ActivityStack 中，一个 ActivityStack 可能包含了多个 task</p></li><li><p>TaskRecord</p><ol><li>一个进程（程序）有一个默认的task affinity，默认为包名</li><li>Activity 会进入启动它的 Activity 所在的 Task 栈中</li><li>app 的切换实质上就是 task 栈的切换</li></ol></li><li><p>ActivityRecord</p><p> 包含了一个Activity的所有信息，例如所在 task、所在进程的信息 ProcessRecord 等</p></li><li><p>ProcessRecord</p><p> 当前运行的进程信息</p></li></ol><h3 id="四种启动模式"><a href="#四种启动模式" class="headerlink" title="四种启动模式"></a>四种启动模式</h3><ol><li><p>standard</p><ol><li>Activity 会重新创建一个新的实例，不论原有实例是否存在。</li></ol></li><li><p>singleTop</p><p> 栈顶复用，要创建的 Activity 已经处于栈顶时，此时会直接复用栈顶的 Activity，不调用 onCreate、onStart，回调 onNewIntent</p><p> 与使用 Intent.FLAG_ACTIVITY_SINGLE_TOP 等价</p><p> 场景：消息推送界面。防止重复推送，多次打开某个页面</p></li><li><p>singleTask </p><p> 要创建的 Activity 已经处于栈中时，此时不会创建新的 Activity，而是将存在栈中的 Activity 上面的其他 Activity 所有销毁，使它成为栈顶</p><p> 与使用 Intent.FLAG_ACTIVITY_CLEAR_TOP 等价</p><p> 场景：主页</p></li><li><p>singleInstance</p><p> 会复用已有的 activity，且栈中只有一个 activity</p><p> 场景：呼叫来电界面</p></li></ol><h3 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h3><h4 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h4><p>FLAG_ACTIVITY_NEW_TASK 会先判断 activity 的 taskAffinity 指定的 task 是否已存在，如果已存在则不会新建 task，不存在则新建 task。如果配合 FLAG_ACTIVITY_MULTIPLE_TASK 一起使用，则不搜索是否已有 task，都会新建新的 task。</p><p>在 Service 中或使用 applicationContext 启动 Activity 必须要有该 flag。</p><h4 id="FLAG-ACTIVITY-MULTIPLE-TASK"><a href="#FLAG-ACTIVITY-MULTIPLE-TASK" class="headerlink" title="FLAG_ACTIVITY_MULTIPLE_TASK"></a>FLAG_ACTIVITY_MULTIPLE_TASK</h4><p>(FLAG_ACTIVITY_MULTIPLE_TASK)[<a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_MULTIPLE_TASK]" target="_blank" rel="noopener">https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_MULTIPLE_TASK]</a></p><p>This flag is used to create a new task and launch an activity into it. This flag is always paired with either FLAG_ACTIVITY_NEW_DOCUMENT or FLAG_ACTIVITY_NEW_TASK. In both cases these flags alone would search through existing tasks for ones matching this Intent. Only if no such task is found would a new task be created. When paired with FLAG_ACTIVITY_MULTIPLE_TASK both of these behaviors are modified to skip the search for a matching task and unconditionally start a new task. </p><p>举个栗子：</p><p>KotlinActivity 中只是用 FLAG_ACTIVITY_NEW_TASK 启动 activity，两个 activity 会在同一个 task 中。如果使用 FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK 启动 Main2Activity。两个 activity 会在不同的 task 中，但是 taskAffinity 是一样的，没指定默认是包名。</p><p>在 Service 中启动结果是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">newTask+mutable 后，task 是什么样</span><br><span class="line"></span><br><span class="line">Task id #771</span><br><span class="line">TaskRecord&#123;750276f #771 A=com.andy.demo U=0 sz=1&#125;</span><br><span class="line">Intent &#123; flg=0x18000000 cmp=com.andy.demo/.Main2Activity &#125;</span><br><span class="line">Hist #0: ActivityRecord&#123;c6870ec u0 com.andy.demo/.Main2Activity t771&#125;</span><br><span class="line">Intent &#123; flg=0x18000000 cmp=com.andy.demo/.Main2Activity &#125;</span><br><span class="line">ProcessRecord&#123;c9f9567 32573:com.andy.demo/u0a251&#125;</span><br><span class="line"></span><br><span class="line">Task id #770</span><br><span class="line">TaskRecord&#123;4222f14 #770 A=com.andy.demo U=0 sz=1&#125;</span><br><span class="line">Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.andy.demo/.KotlinActivity &#125;</span><br><span class="line">Hist #0: ActivityRecord&#123;447e0c4 u0 com.andy.demo/.KotlinActivity t770&#125;</span><br><span class="line">Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.andy.demo/.KotlinActivity &#125;</span><br><span class="line">ProcessRecord&#123;c9f9567 32573:com.andy.demo/u0a251&#125;</span><br></pre></td></tr></table></figure><h3 id="附-adb-命令"><a href="#附-adb-命令" class="headerlink" title="附 adb 命令"></a>附 adb 命令</h3><p><code>adb shell dumpsys activity activities</code> 获取运行的 activity</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相关的概念&quot;&gt;&lt;a href=&quot;#相关的概念&quot; class=&quot;headerlink&quot; title=&quot;相关的概念&quot;&gt;&lt;/a&gt;相关的概念&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java 类加载机制</title>
    <link href="https://yazhidev.github.io/2019/03/02/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://yazhidev.github.io/2019/03/02/Java-类加载机制/</id>
    <published>2019-03-02T12:39:55.000Z</published>
    <updated>2022-06-07T22:58:54.438Z</updated>
    
    <content type="html"><![CDATA[<p>类的生命周期</p><p><img src="http://upload-images.jianshu.io/upload_images/1929170-3b72184710adf2be.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类生命周期"></p><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p>分为五个部分：加载，验证，准备，解析，初始化</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类变量分配内存并设置类变量初始值</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>虚拟机将常量池内的符号引用替换为直接引用。（虚拟机将运行时常量池中那些仅代表其他信息的符号引用（例如字节码中的 #1，#2 等）解析为直接指向所需信息所在地址的指针。）</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。</client></client></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节码（.class 文件）。类加载器负责读取 Java 字节码，并转换成 java.lang.Class 类的一个实例。</p><p>关于类加载器需要了解：</p><h3 id="类加载器的命名空间"><a href="#类加载器的命名空间" class="headerlink" title="类加载器的命名空间"></a>类加载器的命名空间</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。也就是说，你现在要比较两个类是否相等，只有在这两个类是同一个类加载器加载的前提下才有意义。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>JVM中有三种系统提供的类加载器：启动类加载器，扩展类加载器、应用程序类加载器。某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><p>该机制最大的好处就是让 Java 类同其类加载器一起具备了一种带优先级的层次关系。这句话可能不好理解，我们举个例子。比如我们要加载顶层的 Java 类——java.lang.Object 类，无论我们用哪个类加载器去加载 Object 类，这个加载请求最终都会委托给 Bootstrap ClassLoader，这样就保证了所有加载器加载的 Object 类都是同一个类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类的生命周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1929170-3b72184710adf2be.jpg?imageMogr2/auto-orient/strip%7CimageVi
      
    
    </summary>
    
    
      <category term="Java" scheme="https://yazhidev.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从字节码层面理解泛型</title>
    <link href="https://yazhidev.github.io/2019/02/12/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B/"/>
    <id>https://yazhidev.github.io/2019/02/12/从字节码层面理解泛型/</id>
    <published>2019-02-12T13:09:19.000Z</published>
    <updated>2022-06-07T22:58:54.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//编译成 class 文件</span><br><span class="line">javac Test.java </span><br><span class="line"></span><br><span class="line">//反汇编 class 文件</span><br><span class="line">javap -V Test.class</span><br></pre></td></tr></table></figure><p>Android Studio 编译的 class<br>文件位于 <code>build/intermediates/clases/debug/包名</code> 下</p><h2 id="IDEA-插件"><a href="#IDEA-插件" class="headerlink" title="IDEA 插件"></a>IDEA 插件</h2><ul><li><p>jclasslib Bytecode viewer</p></li><li><p>ASM Bytecode Viewer</p></li></ul><p>这两款插件都可以在 Android Studio Plugins 里直接下载安装</p><h2 id="字节码的组成"><a href="#字节码的组成" class="headerlink" title="字节码的组成"></a>字节码的组成</h2><p>方法调用在JVM中转换成的是字节码执行，字节码指令执行的数据结构就是栈帧。</p><p>栈帧的数据结构主要分为四个部分：局部变量表、操作数栈、动态链接以及方法返回地址（包括正常调用和异常调用的完成结果）。</p><h3 id="局部变量表（local-variables）"><a href="#局部变量表（local-variables）" class="headerlink" title="局部变量表（local variables）"></a>局部变量表（local variables）</h3><p>当方法被调用时，参数会传递到从0开始的连续的局部变量表的索引位置上。local variables的最大长度是在编译期间决定的。一个局部变量表的占用了32位的存储空间（一个存储单位称之为slot，槽），所以可以存储一个boolean、byte、char、short、float、int、refrence和returnAdress数据，long和double需要2个连续的局部变量表来保存，通过较小位置的索引来获取。如果被调用的是实例方法，那么第0个位置存储“this”关键字代表当前实例对象的引用。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈同局部变量表一样，也是编译期间就能决定了其存储空间（最大的单位长度）。</p><p>操作数栈是在JVM字节码执行一些指令（第二部分会介绍一些指令集）时创建的，主要是把局部变量表中的变量压入操作数栈，在操作数栈中进行字节码指令的操作，再将变量出操作数栈，结果入操作数栈。</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧指向运行时常量池中该栈帧所属的方法的引用，也就是字节码的发放调用的引用。动态链接就是将符号引用所表示的方法，转换成方法的直接引用。加载阶段或第一次使用时转化为直接引用的（将变量的访问转化为访问这些变量的存储结构所在的运行时内存位置）就叫做静态解析。JVM的动态链接还支持运行期转化为直接引用。也可以叫做Late Binding,晚期绑定。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法正常退出会把返回值压入调用者的栈帧的操作数栈，PC计数器的值就会调整到方法调用指令后面的一条指令。这样使得当前的栈帧能够和调用者连接起来，并且让调用者的栈帧的操作数栈继续往下执行。</p><p>方法的异常调用完成，主要是JVM抛出的异常，如果异常没有被捕获住，或者遇到athrow字节码指令显示抛出，那么就没有返回值给调用者。</p><p>Java 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    private int myNum = 20;</span><br><span class="line"></span><br><span class="line">    public void func() &#123;</span><br><span class="line">        myNum = 50;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的 class 源文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cafe babe 0000 0033 0015 0a00 0400 1109</span><br><span class="line">0003 0012 0700 1307 0014 0100 056d 794e</span><br><span class="line">756d 0100 0149 0100 063c 696e 6974 3e01</span><br><span class="line">0003 2829 5601 0004 436f 6465 0100 0f4c</span><br><span class="line">696e 654e 756d 6265 7254 6162 6c65 0100</span><br><span class="line">124c 6f63 616c 5661 7269 6162 6c65 5461</span><br><span class="line">626c 6501 0004 7468 6973 0100 1a4c 636f</span><br><span class="line">6d2f 7961 7a68 6964 6576 2f64 656d 6f2f</span><br><span class="line">4d79 5465 7374 3b01 0004 6675 6e63 0100</span><br><span class="line">0a53 6f75 7263 6546 696c 6501 000b 4d79</span><br><span class="line">5465 7374 2e6a 6176 610c 0007 0008 0c00</span><br><span class="line">0500 0601 0018 636f 6d2f 7961 7a68 6964</span><br><span class="line">6576 2f64 656d 6f2f 4d79 5465 7374 0100</span><br><span class="line">106a 6176 612f 6c61 6e67 2f4f 626a 6563</span><br><span class="line">7400 2100 0300 0400 0000 0100 0200 0500</span><br><span class="line">0600 0000 0200 0100 0700 0800 0100 0900</span><br><span class="line">0000 3900 0200 0100 0000 0b2a b700 012a</span><br><span class="line">1014 b500 02b1 0000 0002 000a 0000 000a</span><br><span class="line">0002 0000 0007 0004 0008 000b 0000 000c</span><br><span class="line">0001 0000 000b 000c 000d 0000 0001 000e</span><br><span class="line">0008 0001 0009 0000 0035 0002 0001 0000</span><br><span class="line">0007 2a10 32b5 0002 b100 0000 0200 0a00</span><br><span class="line">0000 0a00 0200 0000 0b00 0600 0c00 0b00</span><br><span class="line">0000 0c00 0100 0000 0700 0c00 0d00 0000</span><br><span class="line">0100 0f00 0000 0200 10</span><br></pre></td></tr></table></figure></p><p>javap 反汇编后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/zengyazhi/Documents/zyzdev/AndroidDemo/app/build/intermediates/classes/debug/com/yazhidev/demo/MyTest.class</span><br><span class="line">  Last modified 2018-12-28; size 393 bytes</span><br><span class="line">  MD5 checksum 2872209fbe3efb46c70b23bf85be75fd</span><br><span class="line">  Compiled from &quot;MyTest.java&quot;</span><br><span class="line">public class com.yazhidev.demo.MyTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 51</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#17         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#18         // com/yazhidev/demo/MyTest.myNum:I</span><br><span class="line">   #3 = Class              #19            // com/yazhidev/demo/MyTest</span><br><span class="line">   #4 = Class              #20            // java/lang/Object</span><br><span class="line">   #5 = Utf8               myNum</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/yazhidev/demo/MyTest;</span><br><span class="line">  #14 = Utf8               func</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               MyTest.java</span><br><span class="line">  #17 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #18 = NameAndType        #5:#6          // myNum:I</span><br><span class="line">  #19 = Utf8               com/yazhidev/demo/MyTest</span><br><span class="line">  #20 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.yazhidev.demo.MyTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: bipush        20</span><br><span class="line">         7: putfield      #2                  // Field myNum:I</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">        line 8: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      11     0  this   Lcom/yazhidev/demo/MyTest;</span><br><span class="line"></span><br><span class="line">  public void func();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: bipush        50</span><br><span class="line">         3: putfield      #2                  // Field myNum:I</span><br><span class="line">         6: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">        line 12: 6</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  this   Lcom/yazhidev/demo/MyTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MyTest.java&quot;</span><br></pre></td></tr></table></figure><h2 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h2><p>opcode（指令） = 操作码 + 操作数</p><p>例如 <code>bipush 10</code> 这是一条指令，是由操作码 <code>bipush</code> 后跟一个操作数 <code>10</code> 组成，该指令的作用是将整型数 <code>10</code> 压到操作数栈中。</p><ul><li><p>aload_0（指令码：0x2a）</p><p>  从局部变量数组中加载一个对象引用到操作数栈的栈顶，最后的数字对应的是局部变量数组中的位置，只能是0，1，2，3。（第一个局部变量是this引用）</p></li><li><p>invokespecial（0xb7）</p><p>  只能调用三类方法：<init>方法；私有方法；super.method()。因为这三类方法的调用对象在编译时就可以确定</init></p></li><li><p>invokevirtual（0xb6）</p><p>  是一种动态分派的调用指令</p></li><li><p>bipush（0x10）</p><p>  用来把一个字节作为整型压到操作数栈中</p></li><li><p>putfield（0xb5）</p><p>  后面跟一个操作数（该操作数引用的是运行时常量池里的一个字段，在这里这个字段是 myNum），将栈顶的值赋给这个。赋给这个字段的值，以及包含这个字段的对象引用，在执行这条指令的时候，都会从操作数栈顶上 pop 出来</p></li><li><p>ldc（0x12）</p><p>  常量池中的常量值入栈</p></li><li><p>CHECKCAST（0xc0）</p><p>  类型强转</p></li></ul><p>部分字节码指令集可见：</p><p><a href="http://www.blogjava.net/DLevin/archive/2011/09/13/358497.html" target="_blank" rel="noopener">《Java二进制指令代码解析》</a></p><p><a href="https://segmentfault.com/a/1190000008722128" target="_blank" rel="noopener">《JVM 虚拟机字节码指令表》</a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>回到上面 MyTest 的构造函数里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">4: aload_0</span><br><span class="line">5: bipush        20</span><br><span class="line">7: putfield      #2                  // Field myNum:I</span><br><span class="line">10: return</span><br></pre></td></tr></table></figure><p>ASM Bytecode viewer 显示的字节码为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// class version 51.0 (51)</span><br><span class="line">// access flags 0x21</span><br><span class="line">public class com/yazhidev/demo/MyTest &#123;</span><br><span class="line"></span><br><span class="line">  // compiled from: MyTest.java</span><br><span class="line"></span><br><span class="line">  // access flags 0x2</span><br><span class="line">  private I myNum</span><br><span class="line"></span><br><span class="line">  // access flags 0x1</span><br><span class="line">  public &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 7 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER 8 L1</span><br><span class="line">    ALOAD 0</span><br><span class="line">    BIPUSH 20</span><br><span class="line">    PUTFIELD com/yazhidev/demo/MyTest.myNum : I</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/MyTest; L0 L2 0</span><br><span class="line">    MAXSTACK = 2</span><br><span class="line">    MAXLOCALS = 1</span><br><span class="line"></span><br><span class="line">  // access flags 0x1</span><br><span class="line">  public func()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 11 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    BIPUSH 50</span><br><span class="line">    PUTFIELD com/yazhidev/demo/MyTest.myNum : I</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER 12 L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/MyTest; L0 L2 0</span><br><span class="line">    MAXSTACK = 2</span><br><span class="line">    MAXLOCALS = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="从字节码看泛型"><a href="#从字节码看泛型" class="headerlink" title="从字节码看泛型"></a>从字节码看泛型</h2><p>Java 的泛型是完全在编译器中实现的，由编译器执行类型检查和类型推断，然后生成普通的非泛型的字节码，虚拟机完全不感知泛型的存在。编译器使用泛型类型信息保证类型安全，然后在生成字节码之前将其清除。</p><p>Java 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Generic&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从生成的字节码中可以看到，泛型 T 已经被擦除了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Ljava/lang/Object; data</span><br><span class="line"></span><br><span class="line">public getData()Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">public setData(Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><h3 id="类型擦除与多态冲突的问题"><a href="#类型擦除与多态冲突的问题" class="headerlink" title="类型擦除与多态冲突的问题"></a>类型擦除与多态冲突的问题</h3><p>子类 B，指定了泛型类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class B extends Generic&lt;Number&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Number n;</span><br><span class="line"></span><br><span class="line">    public Number get() &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(Number n) &#123;</span><br><span class="line">        this.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类 C，未指定泛型类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class C extends Generic &#123;</span><br><span class="line"></span><br><span class="line">    private Number n;</span><br><span class="line"></span><br><span class="line">    public Number get() &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(Number n) &#123;</span><br><span class="line">        this.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在写 B 类时，指定了泛型类型为 <code>Number</code>，对于 B 类的方法 <code>get()Number</code> 和 <code>set(Number)</code>，我们的本意应该是对父类的 <code>get()T</code> 和 <code>set(T)</code> 方法进行重写。但上面我们知道了，父类的 <code>get()T</code> 和 <code>set(T)</code> 在字节码中实际上是 <code>get()Object</code> 和 <code>set(Object)</code>，与类 B 的方法 <code>set(Number)</code> 方法参数不一样，理论上应该算重载而不是重写。为了解决这一冲突，JVM 采用了一种特殊的方法：桥接。</p><p>我们先看 B 类的字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public get()Ljava/lang/Number;</span><br><span class="line">public set(Ljava/lang/Number;)V</span><br><span class="line"></span><br><span class="line">// access flags 0x1041</span><br><span class="line">public synthetic bridge set(Ljava/lang/Object;)V</span><br><span class="line">    L0</span><br><span class="line">    LINENUMBER 7 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    ALOAD 1</span><br><span class="line">    CHECKCAST java/lang/Number</span><br><span class="line">    INVOKEVIRTUAL com/yazhidev/demo/B.set (Ljava/lang/Number;)V</span><br><span class="line">    RETURN</span><br><span class="line">    L1</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/B; L0 L1 0</span><br><span class="line">    MAXSTACK = 2</span><br><span class="line">    MAXLOCALS = 2</span><br><span class="line"></span><br><span class="line">// access flags 0x1041</span><br><span class="line">public synthetic bridge get()Ljava/lang/Object;</span><br><span class="line">    L0</span><br><span class="line">    LINENUMBER 7 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    INVOKEVIRTUAL com/yazhidev/demo/B.get ()Ljava/lang/Number;</span><br><span class="line">    ARETURN</span><br><span class="line">    L1</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/B; L0 L1 0</span><br><span class="line">    MAXSTACK = 1</span><br><span class="line">    MAXLOCALS = 1</span><br></pre></td></tr></table></figure><p>可以发现编译器自动生成了 <code>set(Object)</code> 和 <code>get()Object</code> 两个桥接方法来重写父类方法，同时这两个桥接方法实际上调用了对应的 <code>set(Number)</code> 方法和 <code>get()Number</code> 方法。虚拟机通过使用桥接方法，来解决了类型擦除和多态的冲突。对于开发者来说，对于指定了泛型类型为 <code>Number</code> 的 B 类来说，其 <code>set(Number)</code> 方法就是对父类方法 <code>set(T)</code> 的重写，同理 <code>get()Number</code> 也是对父类方法 <code>get()T</code> 的重写。</p><p>但 C 类则有些不同，C 类未指定泛型类型，所以父类中的方法为 <code>get()Object</code> 和 <code>set(Object)</code>，C 类中的 <code>set(Number)</code> 与父类 <code>set(Object)</code> 方法参数不同，理所当然是重载，我们都知道，只有返回值不同不满足重载条件，所以对 C 类的 <code>get()Number</code> 方法来说，应该算是对父类方法 <code>get()T</code> 的重写。</p><p>我们来看 C 类的字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public get()Ljava/lang/String;</span><br><span class="line">public set(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">// access flags 0x1041</span><br><span class="line">public synthetic bridge get()Ljava/lang/Object;</span><br><span class="line">    L0</span><br><span class="line">    LINENUMBER 7 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    INVOKEVIRTUAL com/yazhidev/demo/C.get ()Ljava/lang/String;</span><br><span class="line">    ARETURN</span><br><span class="line">    L1</span><br><span class="line">    LOCALVARIABLE this Lcom/yazhidev/demo/C; L0 L1 0</span><br><span class="line">    MAXSTACK = 1</span><br><span class="line">    MAXLOCALS = 1</span><br></pre></td></tr></table></figure><p>可以发现编译期自动生成了 <code>get()Object</code>  桥接方法来重写父类方法。但我们发现字节码里却同时存在了两个只有返回值类型不同的同名方法，这是为什么呢？</p><p>这里就需要提到方法特征签名，只有特征签名不同的方法才可以共存。</p><ul><li><p>Java 层方法签名 = 方法名 + 参数类型 + 参数顺序</p><p>  所以在 Java 语言里，重载一个方法需要两个同名方法的参数类型不同，或者参数顺序不同，只有返回值类型不同是无法通过编译的。</p></li><li><p>JVM 层方法签名 = 方法名 + 参数类型 + 参数顺序 + 返回值类型 + 可能抛出的异常</p><p>  所以在 class 文件里，是可以存在两个只有返回值类型不同的同名方法。也就是上面的 <code>get()Object</code> 和 <code>get()Number</code></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jianleixing.iteye.com/blog/2017732" target="_blank" rel="noopener">《描述符与特征签名的区别》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;命令行&quot;&gt;&lt;a href=&quot;#命令行&quot; class=&quot;headerlink&quot; title=&quot;命令行&quot;&gt;&lt;/a&gt;命令行&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="Java" scheme="https://yazhidev.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《C++ 程序设计》读书笔记</title>
    <link href="https://yazhidev.github.io/2018/12/16/%E3%80%8AC-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://yazhidev.github.io/2018/12/16/《C-程序设计》读书笔记/</id>
    <published>2018-12-16T02:20:38.000Z</published>
    <updated>2022-06-07T22:58:54.441Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文联合编辑：小辣辣。向她致以最崇高的敬（爱）意 ❤</p></blockquote><hr><h2 id="第一章-C-的初步认识"><a href="#第一章-C-的初步认识" class="headerlink" title="第一章 C++的初步认识"></a>第一章 C++的初步认识</h2><p>在程序进行编译时，先对所有的预处理命令进行处理，将头文件的具体内容代替 <code>#include</code> 指令，然后再对该程序单元进行整体编译。</p><p>对函数做声明，它的作用是通知 C++ 编译系统。</p><h2 id="第二章-数据的存储、表示形式和基本运算"><a href="#第二章-数据的存储、表示形式和基本运算" class="headerlink" title="第二章 数据的存储、表示形式和基本运算"></a>第二章 数据的存储、表示形式和基本运算</h2><p>C++ 没有规定每一种数据所占的字节数，只规定 int 型数据所占的字节数不大于 long 型，不小于 short 型。</p><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PRICE 30</span><br></pre></td></tr></table></figure><p>符号常量虽有名字，但它不是变量。在进行编译预处理时，所有的 PRICE 都被置换为字符 30，在正式进行编译时已经没有 PRICE 这个标识符了。但 C++ 程序员一般更喜欢用 const 定义常变量。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p><code>/</code> 除法运算符<br>结果是整数，如果有一个是负数，则舍入方向是不固定的。多数编译系统采取向零取整的方法</p></li><li><p><code>%</code> 模运算符<br>两侧均应为整型数据，如 7%4 的值为 3</p></li></ul><p>+，–，*，/ 运算中的两个数中有一个数为 float 型数据，则运算结果是 double 型，因为 C++ 在运算时对所有 float 型数据都按 double 型数据处理。</p><p>进行运算时，不同类型的数据都要先转换成同一类型，然后进行运算。</p><h3 id="自增（减）运算符"><a href="#自增（减）运算符" class="headerlink" title="自增（减）运算符"></a>自增（减）运算符</h3><p>也用于指针变量，使指针指向下一个地址。</p><h3 id="赋值运算符和赋值表达式"><a href="#赋值运算符和赋值表达式" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h3><h4 id="赋值过程中的类型转换"><a href="#赋值过程中的类型转换" class="headerlink" title="赋值过程中的类型转换"></a>赋值过程中的类型转换</h4><p>将浮点型数据赋值给整型变量时，舍弃其小数部分。</p><p>不同类型的整型数据间的赋值归根到底就是一条：按存储单元中的存储形式直接传送。</p><h2 id="程序初步设计"><a href="#程序初步设计" class="headerlink" title="程序初步设计"></a>程序初步设计</h2><h3 id="关系运算和逻辑运算"><a href="#关系运算和逻辑运算" class="headerlink" title="关系运算和逻辑运算"></a>关系运算和逻辑运算</h3><p>运算符优先级：</p><p>算数运算符 ＞ 关系运算符 ＞赋值运算符</p><p>在 C 和 C++ 中都用数据 1 代表真，0 代表假。编译系统在处理逻辑型数据时，将 false 处理为 0，将 true 处理为 0。逻辑变量在内存中占 1 个字节，用来存放 0 或 1。</p><h3 id="用-for-语句构成循环"><a href="#用-for-语句构成循环" class="headerlink" title="用 for 语句构成循环"></a>用 for 语句构成循环</h3><p>for（表达式1；表达式2；表达式3）语句</p><p>表达式 1 可以省略，但其后得分号不可省略。</p><p>如果表达式 2 省略，即不判断循环条件，循环无休止地进行下去。</p><h2 id="第四章-利用函数实现指定的功能"><a href="#第四章-利用函数实现指定的功能" class="headerlink" title="第四章 利用函数实现指定的功能"></a>第四章 利用函数实现指定的功能</h2><h3 id="函数参数和函数的值"><a href="#函数参数和函数的值" class="headerlink" title="函数参数和函数的值"></a>函数参数和函数的值</h3><p>在调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放，实参单元仍保留并维持原值。因此，在执行一个被调用函数时，形参的值如果发生改变，并不会改变主调用函数中实参的值。</p><h3 id="对被调用函数的声明和函数原型"><a href="#对被调用函数的声明和函数原型" class="headerlink" title="对被调用函数的声明和函数原型"></a>对被调用函数的声明和函数原型</h3><p>在函数声明中可以不写形参名，只写形参类型</p><h3 id="内置函数（内联函数）"><a href="#内置函数（内联函数）" class="headerlink" title="内置函数（内联函数）"></a>内置函数（内联函数）</h3><p>转去被调用函数前，要记下当时执行的指令的地址，还要记下当时有关的信息，以便在函数调用后继续执行，如果有的函数需要频繁使用，则所用时间会很长，从而降低执行效率。可以使用内置函数将所调用的函数的代码直接嵌入到主调函数中，而不是将流程转出去。使用关键字 inline。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt; typename T &gt; //类似 Java 的泛型</span><br></pre></td></tr></table></figure><h3 id="有默认参数的函数"><a href="#有默认参数的函数" class="headerlink" title="有默认参数的函数"></a>有默认参数的函数</h3><p>注意点：如果函数的定义在函数调用之前，则应在函数定义中给出默认值。如果函数的定义在函数调用之后，则在函数调用之前需要有函数声明，此时必须许多函数声明中给出默认值，函数定义时可以不给出默认值。</p><h3 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h3><ul><li><p>auto（默认）</p><p>  自动变量，动态局部变量，函数调用结束后释放</p></li><li><p>static</p><p>  静态局部变量在静态存储区内分配存储单元，在程序整个运行期间都不释放。<br>  加上 static 声明，则该变量只能用于本文件</p></li><li><p>register</p><p>  寄存器变量，如果有一些变量使用频繁，则为存取变量的值要花不少时间，为提高效率，C++ 允许将局部变量的值放在 cpu 的寄存器中</p></li><li><p>extern</p><p>  全局变量（外部变量），作用域从变量的定义开始，到本程序文件的末尾<br>  注意 extern 是用作变量声明，而不是变量定义。它只是对一个已定义的外部变量做声明，以扩展其作用域。</p></li></ul><h3 id="内部函数和外部函数"><a href="#内部函数和外部函数" class="headerlink" title="内部函数和外部函数"></a>内部函数和外部函数</h3><h4 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h4><p>如果在函数的首部的最左端冠以关键字 <code>extern</code>，则表示此函数是外部函数，可供其他文件调用。</p><h2 id="第五章-利用数组处理批量数据"><a href="#第五章-利用数组处理批量数据" class="headerlink" title="第五章 利用数组处理批量数据"></a>第五章 利用数组处理批量数据</h2><h3 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h3><ul><li>可以只给一部分元素赋值（后面的元素默认为 0）</li><li>对全部数组元素赋初值时，可以不指定数组长度</li></ul><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><ul><li>可以对部分元素赋值</li></ul><h3 id="用数组作函数参数"><a href="#用数组作函数参数" class="headerlink" title="用数组作函数参数"></a>用数组作函数参数</h3><p>数组名作实参和形参，传递的是数组的起始地址。</p><p>数组名代表数组首元素的地址。</p><p>用数组名作实参，如果改变了形参数组元素的值将同时改变实参数组元素的值。</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><h4 id="定义和初始化字符数组"><a href="#定义和初始化字符数组" class="headerlink" title="定义和初始化字符数组"></a>定义和初始化字符数组</h4><p>如果提供的初值个数大于数组长度，则按语法错误处理。如果小于数组长度，则只将字符赋值给数组中前面的元素，其余的元素自动定义为空字符 <code>\0</code></p><h4 id="字符数组的赋值和引用"><a href="#字符数组的赋值和引用" class="headerlink" title="字符数组的赋值和引用"></a>字符数组的赋值和引用</h4><p>只能对字符数组的元素赋值，而不能用赋值语句对整个数组赋值。</p><h4 id="结束标志"><a href="#结束标志" class="headerlink" title="结束标志"></a>结束标志</h4><p>遇到字符 <code>\0</code> 就表示字符串到此结束。对于一个字符串常量，系统会自动在所在字符的后面加一个 <code>\0</code> 作为结束符，然后再把它存在字符数组中。</p><p>可以用字符串常量来初始化字符数组。</p><h4 id="字符数组的输入和输出"><a href="#字符数组的输入和输出" class="headerlink" title="字符数组的输入和输出"></a>字符数组的输入和输出</h4><ul><li>输出得字符不包含结束符 <code>\0</code></li></ul><h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>比较函数 strcmp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcmp（str1，str2）</span><br></pre></td></tr></table></figure><p>对两个字符串自左至右逐个字符相比(按 ASCII 值大小比较)</p><p>两个字符串比较，不能用以下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(str1 ＞ str2) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面写法表示将两个数组的地址进行比较。</p><h4 id="字符串变量的定义和引用"><a href="#字符串变量的定义和引用" class="headerlink" title="字符串变量的定义和引用"></a>字符串变量的定义和引用</h4><p>和其他类型变量一样，字符串变量必须先定义后使用。</p><h2 id="第六章-善于使用指针和引用"><a href="#第六章-善于使用指针和引用" class="headerlink" title="第六章 善于使用指针和引用"></a>第六章 善于使用指针和引用</h2><p><code>i_pointer</code> 是一个指针变量，<code>* i_pointer</code> 表示 i_pointer 所指向的变量。<br><code>*</code> 不是指针变量名的一部分，在变量名前加一个 <code>*</code> 表示该变量是指针变量。</p><p>不能用一个整数给指针变量赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * pointer = 2000;</span><br></pre></td></tr></table></figure><p>编译系统并不把 2000 认为是地址，而认为是整数。可以将一个已定义的变量的地址作为指针变量的初值。</p><p>一个指针只能指向同一个类型的变量。</p><h3 id="引用指针变量"><a href="#引用指针变量" class="headerlink" title="引用指针变量"></a>引用指针变量</h3><p><code>&amp;</code> ： 取地址运算符</p><p><code>&amp;a</code> 为变量 a 的地址， <code>*p</code> 为指针变量 p 所指向的存储单元</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * pointer = &amp; a //定义指针变量</span><br></pre></td></tr></table></figure><p>pointer：指针变量</p><p><code>* pointer</code> 等效于 a（对指针变量 pointer 做 <code>*</code> 运算，指向 pointer 指向的存储单元，即 a）</p><p><code>&amp;</code> 和 <code>*</code> 两个运算符的优先级别相同，但按自右而左方向结合。例如已知 <code>pointer = &amp;a</code>，<code>&amp; * pointer</code>的含义是：先进行 <code>*pointer</code> 的运算，它就是变量 a，再执行 <code>&amp;</code> 运算，因此 <code>&amp; * pointer</code> 与 <code>&amp; a</code> 相同，即变量 a 的地址。</p><h3 id="用指针作函数参数"><a href="#用指针作函数参数" class="headerlink" title="用指针作函数参数"></a>用指针作函数参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    void swap(int * p1, int * p2)</span><br><span class="line">    int * pointer_1, * pointer_2, a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    pointer_1 = &amp;a;</span><br><span class="line">    pointer_2 = &amp;b;</span><br><span class="line">    swap(pointer_1, pointer_2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int * p1, int * p2) &#123; //定义指针变量 p1, p2，即 swap 的形参须是指针</span><br><span class="line">    int temp;</span><br><span class="line">    temp = * p1; // * p1：对指针变量做 * 运算，指向值</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能试图通过改变形参指针变量的值而使实参指针变量的值改变。实参和形参之间的数据传递是单向的“值传递”的方式，指针变量作函数参数也要遵循这一规则，调用函数时不会改变实参指针变量的值，但可以改变实参指针变量指向变量的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) </span><br><span class="line">&#123;</span><br><span class="line">    void myswap(int * p1, int * p2);</span><br><span class="line">    int * point1, * point2, a, b;</span><br><span class="line">    a = 10, b = 20;</span><br><span class="line">    point1 = &amp;a;</span><br><span class="line">    point2 = &amp;b;</span><br><span class="line">    cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    if(a &lt; b) myswap(point1, point2);</span><br><span class="line">    cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    if(a &lt; b) realswap(point1, point2);</span><br><span class="line">    cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指针变量也是值传递，形参修改并不影响实参 point1 指针</span><br><span class="line">void myswap(int * p1, int * p2) &#123;</span><br><span class="line">    int * temp;</span><br><span class="line">    temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void realswap(int * p1, int * p2) &#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = * p1;</span><br><span class="line">    * p1 = * p2; //* p1，直接修改 p1 指向的值（a）的值</span><br><span class="line">    * p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出 </span><br><span class="line">a10b20</span><br><span class="line">a10b20</span><br><span class="line">a20b10</span><br><span class="line"></span><br><span class="line">//分析</span><br><span class="line">point1 = &amp; a</span><br><span class="line">* point1 即 point1 所指向的变量</span><br></pre></td></tr></table></figure><h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><h4 id="指向数组元素的指针"><a href="#指向数组元素的指针" class="headerlink" title="指向数组元素的指针"></a>指向数组元素的指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[10]; //定义一个数组，有 10 个元素</span><br><span class="line">int *p;</span><br><span class="line">p = &amp;a[0] //将元素 a[0] 的地址赋给指针变量 p，使 p 指向 a[0]</span><br></pre></td></tr></table></figure><p>在 C++ 中，数组名代表数组中的第 1 个元素（即序号为 0 的元素）的<strong>地址</strong>，因此以下语句等价：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[0];</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure><p>数组名 a 不代表整个数组，<code>p=a</code> 的作用是把 a 数组的首元素的地址赋给指针变量 p。</p><p>如果指针变量 p 已指向数组中的一个元素，则 p + 1 指向同一个数组中的下一个元素。</p><p>如果 p 的初值为 &amp;a[0]，那么 <code>p + i</code> 和 <code>a + i</code> 就是 a[i] 的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(p+5)</span><br><span class="line">*(a+5)</span><br><span class="line">a[5]</span><br></pre></td></tr></table></figure><p>这三种表示方法等价。</p><p>可以看出，数组名后面的括号 []，实际上是变址运算符，指向数组元素的指针变量也可以带下标，如 <code>p[i]</code> 与 <code>*(p+i)</code> 等价。</p><p>效率比较：</p><ol><li><p>下标法：a[i]</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针法：*(a + i)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*(a + i)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用指针变量指向数组元素</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int i;</span><br><span class="line">for(p = a; p &lt; (a + 10); p++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>1 和 2 的执行效率相同，C++ 编译系统是将 a[i] 转换为 *(a + 1) 处理的，对每个 a[i] 都分别计算地址 a + i x d，然后访问该元素。3 比 1 和 2 快，用指针变量直接指向元素，不必每次都重新计算地址。</p><p>在使用指针变量指向数组元素是，应切实保证指向数组中有效的元素。</p><p>C++ 编译系统将形参数组名一律作为指针变量来处理。</p><h3 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a>函数与指针</h3><p>只须将函数名 max 赋给 p，不能写成 p ＝ max(a,b)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * a(int x, int y);</span><br></pre></td></tr></table></figure><p>a 是函数名，调用它以后m能得到一个指向整型数据的指针（地址）。</p><h3 id="指针数组和指向指针的指针"><a href="#指针数组和指向指针的指针" class="headerlink" title="指针数组和指向指针的指针"></a>指针数组和指向指针的指针</h3><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * p[4]</span><br></pre></td></tr></table></figure><p>由于 [] 比 * 优先级高，因此 p 先与 [4] 结合，形成 p[4] 形式，这显然是数组形式。不要写成 int 这是指向一维数组的指针变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* (name + i ++)</span><br></pre></td></tr></table></figure><p>表示先求 * 的值，即 name 它是一个地址。将它赋给 p，然后 i 加 1，最后输出以 p 地址开始的字符串。</p><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>由于 name[i] 的值是地址(即指针)，因此 name + i 就是指向指针型数据的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 指针变量（比如变量 a 的地址）</span><br><span class="line">char * p </span><br><span class="line"></span><br><span class="line">// 存储 a 的地址的指针的地址</span><br><span class="line">char *(* p) </span><br><span class="line"></span><br><span class="line">* p = &apos;C++&apos;</span><br><span class="line">** p 指向 ‘C++’ 的第一个字符元素的内容</span><br></pre></td></tr></table></figure><h3 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h3><p>用指向常量的指针变量只是限制了通过指针变量改变它指向的对象的值。</p><ul><li><p>const 类型名 * p （指向常量的指针变量）</p><p>  p 的指向可变，但 p 指向的对象的值不可变。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 12;</span><br><span class="line">int b = 15;</span><br><span class="line">const int * p = &amp; a;</span><br><span class="line"></span><br><span class="line">p = &amp;b; //合法，p 的指向可变</span><br><span class="line">* p = 20; //非法，p 指向的对象的值不可变</span><br><span class="line">a = 15; //合法，a 不是 const 常量</span><br></pre></td></tr></table></figure></li></ul><pre><code>如果想绝对保证 a 的值始终不变，应当把 a 定义为常变量。</code></pre><ul><li><p>int * const p （常指针变量）</p><p>  指针变量的指向不可变，但指向变量的值可变</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 12;</span><br><span class="line">int b = 15;</span><br><span class="line">int * const p = &amp; a;</span><br><span class="line"></span><br><span class="line">p = &amp;b; //非法，p 的指向不可变</span><br><span class="line">* p = 20; //合法，p 指向变量的值可变</span><br></pre></td></tr></table></figure></li><li><p>const int a</p><p>  a 的值不可变</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int a = 12;</span><br><span class="line"></span><br><span class="line">a = 20; //非法</span><br></pre></td></tr></table></figure></li></ul><h3 id="void-指针类型"><a href="#void-指针类型" class="headerlink" title="void 指针类型"></a>void 指针类型</h3><p>该空间尚未使用，其中没有数据，谈不上指向什么类型的数据，故返回一个 <code>void *</code> 类型的指针，表示它不指向确定的具有类型的数据。</p><h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>指针变量可以有空值，即该指针变量不指向任何变量，它可以这样表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// iostream 头文件中已定义了符号常量 NULL 代表整数 0</span><br><span class="line">p = NULL;</span><br></pre></td></tr></table></figure><p>如果两个指针不指向同一个数组，则比较是无意义的。如果一定要对不同类型的指针变量赋值，可以用到强制类型转换。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在数据类型名后面出现的 &amp; 是引用声明符号，在其他场合出现的都是地址符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char &amp;d = c; // 引用的声明符</span><br><span class="line">int * p = &amp; a; //地址符</span><br></pre></td></tr></table></figure><p>在声明一个引用后，不能再使之作为另一变量的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1, a2;</span><br><span class="line">int &amp;b = a1;</span><br><span class="line">int &amp;b = a2; //非法</span><br></pre></td></tr></table></figure><p>引用其实就是一个指针常量，它的指向不可改变。</p><h3 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h3><p>传递变量的地址：形参是指针变量，实参是一个变量的地址。调用函数时，形参（指针变量）得到实参变量的地址，因此指向实参变量单元。</p><p>实参不是地址而是整型变量名，由于形参是引用，系统会自动将实参的地址传递给形参，注意：此时传送的是实参变量的地址而不是实参变量的值。实参是地址，传递的是地址，故仍然是值传递。方式（3）中实参是变量名，而传递的是变量的地址，这才是传址方式。</p><h2 id="第七章-用户自定义数据类型"><a href="#第七章-用户自定义数据类型" class="headerlink" title="第七章 用户自定义数据类型"></a>第七章 用户自定义数据类型</h2><h3 id="引用结构体变量"><a href="#引用结构体变量" class="headerlink" title="引用结构体变量"></a>引用结构体变量</h3><p><code>.</code> 是成员运算符，它在所有运算符中优先级最高，因此可以把 <code>student.num</code> 作为一个整体来看待。</p><h3 id="指向结构体变量的指针"><a href="#指向结构体变量的指针" class="headerlink" title="指向结构体变量的指针"></a>指向结构体变量的指针</h3><p>C 和 C++ 提供了指向结构体变量的运算符 <code>-&gt;</code>,形象的表示“指向”关系。例如，<code>p-&gt;num</code> 表示指针 p 当前指向的结构体变量中的成员 num。</p><p><code>p-&gt;n++</code> 得到p指向的结构体变量中的成 员 n的值，用完该值后使它加 1。</p><p><code>++p-&gt;n</code> 得到 p 指向的结构体变量中的成员 n 的值，并使之加 1，然后再使用它。</p><h4 id="用结构体变量和指向结构体变量的指针构成链表"><a href="#用结构体变量和指向结构体变量的指针构成链表" class="headerlink" title="用结构体变量和指向结构体变量的指针构成链表"></a>用结构体变量和指向结构体变量的指针构成链表</h4><p>用结构体变量和指向结构体变量的指针构成链表，最有一个元素不再指向其他元素，它成为“表尾”，它的地址部分放到一个“NULL”（表示“空地址”），链表到此结束。</p><p>所有节点（结构体变量）都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表成为静态链表。</p><p>动态链表则是指个结点是可以随时插入和删除的，这些节点并没有变量名，只能先找到一个结点上，才能根据它提供的下一个结点的地址找到下一个结点。</p><h3 id="结构体类型数据最为函数参数"><a href="#结构体类型数据最为函数参数" class="headerlink" title="结构体类型数据最为函数参数"></a>结构体类型数据最为函数参数</h3><p>调用函数时形参要单独开辟内存单元，如果结构体变量占的存储空间很大，则在虚实结合时控件和时间的开销都比较大，效率是不高的。</p><h3 id="用-new-和-delete-运算符进行动态分配和撤销存储空间"><a href="#用-new-和-delete-运算符进行动态分配和撤销存储空间" class="headerlink" title="用 new 和 delete 运算符进行动态分配和撤销存储空间"></a>用 new 和 delete 运算符进行动态分配和撤销存储空间</h3><p>new 运算符使用的一般格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new 类型 [初值]</span><br></pre></td></tr></table></figure><p>注意：用 new 分配数组空间时不能指定初始值</p><p>delete 运算符使用的一般格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete 指针变量</span><br><span class="line">或</span><br><span class="line">delete [] 指针变量</span><br></pre></td></tr></table></figure><p>在指针变量前面加一对方括号，表示是对数组空间的操作。</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举元素按常量处理，故称枚举常量，它们不是常量，不能对它们赋值，即枚举元素的值是固定的。</p><h2 id="第八章-类和对象的特性"><a href="#第八章-类和对象的特性" class="headerlink" title="第八章 类和对象的特性"></a>第八章 类和对象的特性</h2><h3 id="声明类类型"><a href="#声明类类型" class="headerlink" title="声明类类型"></a>声明类类型</h3><p>如果在类的定义中既不指定 private，也不指定 public，则系统就默认为是私有的。</p><p>除了 private 和 public之外，还有一种成员访问限定符 protect（受保护的），用protect声明的成员不能被类外访问（这点与私有成员类似），但可以被派生类的成员函数访问。</p><h3 id="成员函数的性质"><a href="#成员函数的性质" class="headerlink" title="成员函数的性质"></a>成员函数的性质</h3><p><code>::</code> 是作用域限定符（field qualifier）或称作用域运算符，用它声明函数是属于哪个子类的。</p><p>函数名前既无类名又无作用域运算符，表示函数不属于任何类，这个函数不是成员函数，而是全局函数。</p><h3 id="内置成员函数"><a href="#内置成员函数" class="headerlink" title="内置成员函数"></a>内置成员函数</h3><p>在类体中定义的成员函数的规模一般都很小，而系统调用函数的过程所花费的时间开销相对是比较大的，为减少时间的开销，如果在类体中定义的成员函数中不包括循环等控制结构，C++ 系统就自动把它们作为内置（inline）函数来处理。</p><h3 id="成员函数的存储方式"><a href="#成员函数的存储方式" class="headerlink" title="成员函数的存储方式"></a>成员函数的存储方式</h3><p>每个对象所占用的存储空间只是该对象的数据成员所占的存储空间，而不包括函数代码所占用的存储空间。</p><h2 id="第九章-怎样使用类和对象"><a href="#第九章-怎样使用类和对象" class="headerlink" title="第九章 怎样使用类和对象"></a>第九章 怎样使用类和对象</h2><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>不能在类生命中对数据成员初始化，因为类并不是一个实体，而是一种抽象类型，并不占存储空间，显然误触容纳数据。</p><h3 id="用构造函数实现数据成员的初始化"><a href="#用构造函数实现数据成员的初始化" class="headerlink" title="用构造函数实现数据成员的初始化"></a>用构造函数实现数据成员的初始化</h3><p>在类外定义构造成员函数，要加上类名和域限定符。</p><p>在建立对象时系统为该对象分配存储单元，此时执行构造函数。</p><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><p>无参构造函数应注意正确书写定义对象的语句</p><p>请记住：构造函数是不能被用户显式调用的</p><h3 id="使用默认参数的构造函数"><a href="#使用默认参数的构造函数" class="headerlink" title="使用默认参数的构造函数"></a>使用默认参数的构造函数</h3><p>由于不需要实参也可以调用构造函数，因此全部参数都指定了一个默认值的构造函数也属于默认的构造函数。</p><p>编译系统无法识别应该调用那个构造函数，出现歧义性</p><p>在一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>如果用户没有定义析构函数，C++ 编译系统会自动生成一个析构函数，但它只是徒有析构函数的名称和形式，实际上什么操作都不进行。</p><h3 id="调用构造函数和析构函数的顺序"><a href="#调用构造函数和析构函数的顺序" class="headerlink" title="调用构造函数和析构函数的顺序"></a>调用构造函数和析构函数的顺序</h3><p>先构造的后析构，后构造的先析构。相当于一个栈，先进后出。</p><h3 id="指向对象成员的指针"><a href="#指向对象成员的指针" class="headerlink" title="指向对象成员的指针"></a>指向对象成员的指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time * pt; //定义 pt 是指向 Time 类对象的指针变量</span><br><span class="line">Time tl; //定义 tl 为 Time 类对象</span><br><span class="line">pt = &amp; tl; //将 tl 的起始地址赋给 pt</span><br><span class="line"></span><br><span class="line">* pt; //pt 所指向的对象，即 tl；</span><br><span class="line">//以下表示是等价的</span><br><span class="line">(* pt).hour; </span><br><span class="line">pt -&gt; hour;</span><br></pre></td></tr></table></figure><p>指针变量的类型必须与赋值号右侧函数的类型相匹配，要求在以下3方面都要匹配：1.函数参数的类型和参数个数；2、函数返回值类型；3.所属的类</p><p>定义指向公用成员函数的指针变量的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据类型名 （类名 :: * 指针变量名）（参数列表）;</span><br><span class="line"></span><br><span class="line">//形如：</span><br><span class="line">void(Time:: *p2)()</span><br></pre></td></tr></table></figure><p>使指针变量指向一个公用成员函数的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指针变量名 = &amp; 类名 :: 成员函数名</span><br><span class="line">//形如</span><br><span class="line">p2 = &amp;Time::get_time;</span><br></pre></td></tr></table></figure><h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><p>常对象必须有初值，在常对象的生命周期中，对象中的所有数据成员的值都不能被修改</p><p>定义常对象的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 const 对象名[(实参表)]；</span><br></pre></td></tr></table></figure><p>也可以把const写在最左边：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const 类名 对象名[(实参表)]；</span><br></pre></td></tr></table></figure><p>与上面的格式是等价的。</p><p>在定义常对象时，必须同时对之初始化，之后不能再改变。</p><h3 id="常对象成员"><a href="#常对象成员" class="headerlink" title="常对象成员"></a>常对象成员</h3><ul><li><p>常成员函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意const的位置在函数名和括号之后</span><br><span class="line">viod get_time() const;</span><br></pre></td></tr></table></figure></li></ul><h3 id="指向对象的常指针"><a href="#指向对象的常指针" class="headerlink" title="指向对象的常指针"></a>指向对象的常指针</h3><p>指向对象的常指针变量的值不能改变，即始终指向同一个对象，但可以改变其所指向的对象的值。</p><p>往往常指针作为函数的形参，目的是不允许在函数执行过程中改变指针变量的值，使其始终指向原来的对象。</p><h3 id="指向常对象的指针变量"><a href="#指向常对象的指针变量" class="headerlink" title="指向常对象的指针变量"></a>指向常对象的指针变量</h3><p>一个对象已经被声明为常变量，只能用指向常变量的指针变量指向它。</p><p>指向常变量的指针变量除了可以指向常变量，还可以指向未被声明为const的变量。此时不能通过此指针变量来改变该变量的值。</p><p>指向常对象的指针最常用于函数的形参，目的是在白虎形参指针所指向的对象，使它在函数执行过程中不被修改。</p><p>以下是非法的：</p><ul><li>形参：指向非 const 型变量的指针；实参 const 变量的地址； </li></ul><p>因为参数传递本质是值传递/地址传递。过程：形参指向实参。因为非 const 型变量指针只能指向非 const 型变量。所以以上是非法的。</p><p>在函数调用时将建立一个新的对象，它是实参对象的拷贝</p><h3 id="对象的动态建立和释放"><a href="#对象的动态建立和释放" class="headerlink" title="对象的动态建立和释放"></a>对象的动态建立和释放</h3><p>用new运算符动态地分配内存后，将返回一个指向新对象的指针。</p><h3 id="对象的赋值"><a href="#对象的赋值" class="headerlink" title="对象的赋值"></a>对象的赋值</h3><p>对象的赋值只对其中数据成员赋值，而不对成员函数赋值。</p><p>不同对象的成员函数时同一个函数代码段，不需要，也无法对它赋值。</p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态数据成员可初始化，但只能在类体外进行初始化。</p><p>公用静态数据成员与全局变量不同，静态数据成员的作用域只限于定义该类的作用域内（如果是在一个函数中定义类，那么其中静态数据成员的作用域就是在此函数内）</p><h3 id="静态数据成员函数"><a href="#静态数据成员函数" class="headerlink" title="静态数据成员函数"></a>静态数据成员函数</h3><p>非静态成员函数有 this 指针，而静态成员函数没有this指针。由此决定了静态成员函数不能访问本类中的非静态成员。</p><p>在 C++ 程序中最好养成这样的习惯：只用静态成员函数引用静态数据成员，而不引用非静态数据成员。</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>在类外定义的且未用类最限定的函数，是非成员函数，不属于任何类。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><ol><li>友元的关系是单向的而不是双向的。</li><li>友元的关系不能传递。</li></ol><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模板名 &lt;实际类型名&gt; 对象名（参数表);</span><br></pre></td></tr></table></figure><h2 id="第十章-运算符重载"><a href="#第十章-运算符重载" class="headerlink" title="第十章 运算符重载"></a>第十章 运算符重载</h2><h3 id="重载运算符的规则"><a href="#重载运算符的规则" class="headerlink" title="重载运算符的规则"></a>重载运算符的规则</h3><p>重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象（或类对象的引用），参数不能全是 C++ 的标准类型</p><h3 id="运算符重载函数作为类成员函数和友元函数"><a href="#运算符重载函数作为类成员函数和友元函数" class="headerlink" title="运算符重载函数作为类成员函数和友元函数"></a>运算符重载函数作为类成员函数和友元函数</h3><p>将双目运算符重载为友元函数时，由于友元函数不是该类的成员函数，因此在函数的形参表中必须有两个参数，不能省略。</p><h3 id="用转换构造函数进行不同类型数据的转换"><a href="#用转换构造函数进行不同类型数据的转换" class="headerlink" title="用转换构造函数进行不同类型数据的转换"></a>用转换构造函数进行不同类型数据的转换</h3><p>通常把有一个参数的构造函数作类型转换，所以，称为转换构造函数。</p><h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>类型转换函数的作用是将一个类的对象转换成另一个类型的数据。形式如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operator 类型名（） </span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在函数名前不能指定函数类型，函数没有参数。类型转换函数只能作为成员函数，因为转换的主体是本类的对象，不能作为友元函数或普通函数。</p><p>如果运算符重载函数为成员函数，它的第一个参数必须是本类的对象。当第一个操作数不是类对象时，不能将运算符函数重载为成员函数，如果将运算符“+” 重载为类的成员函数，交换律不适用。</p><p>类型转换函数与运算符重载不共存。因为可能出现二义性。</p><h2 id="第十一章-继承与派生"><a href="#第十一章-继承与派生" class="headerlink" title="第十一章 继承与派生"></a>第十一章 继承与派生</h2><h3 id="派生类的声明方式"><a href="#派生类的声明方式" class="headerlink" title="派生类的声明方式"></a>派生类的声明方式</h3><p>基类名前有 public 的称为公用继承。如果不写此项，默认为 privite（私有的）</p><h3 id="派生类成员的访问属性"><a href="#派生类成员的访问属性" class="headerlink" title="派生类成员的访问属性"></a>派生类成员的访问属性</h3><p>基类的成员函数只能访问基类的成员，而不能派生类的成员。</p><ul><li><p>公用继承</p><p>  基类的公用成员和保护成员在派生类中保持原有访问属性，私有成员仍为基类私有</p></li><li><p>私有继承</p><p>  基类的公有成员和保护成员在派生类中成了私有成员，私有成员仍为基类私有</p></li><li><p>受保护继承</p><p>  基类的公有成员和保护成员在派生类中成了保护成员，私有成员仍为基类私有</p></li></ul><h3 id="派生类的构造函数和析构函数"><a href="#派生类的构造函数和析构函数" class="headerlink" title="派生类的构造函数和析构函数"></a>派生类的构造函数和析构函数</h3><p>基类的构造函数式不能继承的，对继承过来的基类成员初始化的工作也要由派生类的构造函数承担。解决这个问题的思路是：在执行派生类的构造函数时，调用基类的构造函数。</p><h4 id="简单的派生类构造函数"><a href="#简单的派生类构造函数" class="headerlink" title="简单的派生类构造函数"></a>简单的派生类构造函数</h4><p>在类中对派生类构造函数作声明时，不包括上面给出的一般形式中的基类的构造函数名（参数表）部分</p><h4 id="有子对象的派生类的构造函数"><a href="#有子对象的派生类的构造函数" class="headerlink" title="有子对象的派生类的构造函数"></a>有子对象的派生类的构造函数</h4><p>应当在建立对象时对它的数据成员初始化。</p><p>派生类构造函数的任务应该包括：</p><ol><li>对基类数据成员初始化</li><li>对子对象数据成员初始化</li><li>对派生类数据成员初始化</li></ol><p>定义派生类构造函数的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">派生类构造函数名（总参数表）：基类构造函数名（参数表），子对象名（参数表）</span><br><span class="line">&#123; 派生类中新增数据成员初始化语句 &#125;</span><br></pre></td></tr></table></figure><h3 id="派生类构造函数的特殊形式"><a href="#派生类构造函数的特殊形式" class="headerlink" title="派生类构造函数的特殊形式"></a>派生类构造函数的特殊形式</h3><p>如果在基类中没有定义构造函数，或定义了没有参数的构造函数，那么，在定义派生类构造函数时可以不写基类构造函数。因此此时派生类构造函数没有向基类构造函数传递参数的任务。在调用派生类构造函数时，系统会自动首先调用基类的默认构造函数。</p><h3 id="派生类的析构函数"><a href="#派生类的析构函数" class="headerlink" title="派生类的析构函数"></a>派生类的析构函数</h3><p>在执行派生类的析构函数时，系统会自动调用基类的析构函数和子对象的析构函数。调用的顺序与构造函数相反：先执行派生类自己的析构函数，然后调用子对象的析构函数，最后调用基类的析构函数。</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>形式如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">派生类构造函数名（总参数表）：基类 1 构造函数（参数表），基类 2 构造函数（参数表）, 基类 3 构造函数（参数表）</span><br><span class="line">&#123; 派生类中新增数据成员初始化语句 &#125;</span><br></pre></td></tr></table></figure><p>声明基类的顺序决定了基类构造函数的调用顺序</p><h3 id="多重继承引发的二义性问题"><a href="#多重继承引发的二义性问题" class="headerlink" title="多重继承引发的二义性问题"></a>多重继承引发的二义性问题</h3><p>基类的同名成员在派生类中被屏蔽。成为不可见的。因此如果在定义派生类对象的模块中通过对象名访问同名的成员，则访问的是派生类的成员。请注意：不同的成员函数，只有在函数名和参数个数相同、类型相匹配的情况下才发生同名覆盖。</p><h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><p>虚基类使得在继间接共同基类时只保留一份成员。</p><p>需要注意，为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。</p><p>由于虚基类在派生类中只有一份数据成员，所以这份数据成员的初始化必须由派生类直接给出。</p><p>C++ 编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类对虚基类的构造函数的调用，这就保证了虚基类的数据成员不会被多次初始化。</p><h3 id="基类与派生类的转换"><a href="#基类与派生类的转换" class="headerlink" title="基类与派生类的转换"></a>基类与派生类的转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A al; //定义基类 A 对象 al</span><br><span class="line">B bl; //B 是 A 的派生类</span><br><span class="line">A&amp; r = al; //定义基类 A 对象的引用 r，并引用 al 对其初始化</span><br></pre></td></tr></table></figure><p>这时，r 是 al 的引用（别名），r 和 al 共享同一段存储单元。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&amp; r = bl;</span><br></pre></td></tr></table></figure><p>此时 r 并不是 bl 的别名，也不是与 bl 共享同一段存储单元，它只是 bl 中基类部分的别名，r 与 bl 中基类部分共享同一段存储单元，r 与 bl 具有相同的其实地址。</p><p>即基类的引用类型，指向了派生类的变量。指向的也是派生类中从基类继承的部分。</p><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><p>在一个类中以另一个类的对象作为数据成员的，称为类的组合。</p><h2 id="第十二章-多态性与虚函数"><a href="#第十二章-多态性与虚函数" class="headerlink" title="第十二章 多态性与虚函数"></a>第十二章 多态性与虚函数</h2><p>派生类对象可以替代基类对象向基类对象的引用初始化或赋值。调用的不是在 Circle 中声明的运算符重载函数，而是在 Point 中声明的运算符重载函数，输出的是“点”的信息，而不是“圆”的信息。</p><p>这两个 area 函数不是重载函数，它们不仅函数名相同，而且函数类型和参数个数都相同，两个同名函数不在同一个类中，而是分别在基类和派生类中，属于同名覆盖。</p><h3 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a>虚函数的作用</h3><p>编译系统按照同名覆盖的原则决定调用的对象。</p><p>C++ 的虚函数就是用来解决动态多态的问题的。所谓虚函数，就是在基类声明函数是虚拟的，并不是实际存在的函数，然后在派生类中才正式定义此函数。</p><p>本来，基类指针是用来指向基类对象的，如果用它指向派生类对象，则自动进行指针类型转换，将派生类的对象的指针先转换为基类的指针，这样，基类指针指向的是派生类中的基类部分。</p><p>有时在基类中定义的非虚函数会在派生类中被重新定义，如果用基类指针调用该成员函数，则系统会调用对象中基类部分的成员函数；如果用派生类指针调用该函数，则系统会调用派生类对象中的成员函数，这并不是多态性行为（使用的是不同类型的指针）</p><h3 id="静态关联和动态关联"><a href="#静态关联和动态关联" class="headerlink" title="静态关联和动态关联"></a>静态关联和动态关联</h3><p>确定调用的具体对象的过程称为关联。</p><p>函数重载和通过对象名调用的虚函数，在编译时即可确定其调用的虚函数属于哪一个类，其过程称为静态关联。</p><p>由于是在运行阶段把虚函数和类对象“绑定”在一起的，因此称为动态关联。</p><h3 id="在什么情况下应当声明虚函数"><a href="#在什么情况下应当声明虚函数" class="headerlink" title="在什么情况下应当声明虚函数"></a>在什么情况下应当声明虚函数</h3><p>一个成员函数被声明为虚函数后，在同一类族中的类就不能定义一个非 virtual 的但与该虚函数具有相同的参数。</p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>先调用了派生类的析构函数，再调用了基类的析构函数。当基类的析构函数为虚函数，无论指针指的是同一类族中的哪一个类对象。</p><p>如果将基类的析构函数声明为虚函数时，由该函数所派生的所有派生类的析构函数有都自动成为虚函数，即使派生类的析构函数与基类的析构函数名字不相同。</p><h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual 函数类型 函数名（参数类别） = 0;</span><br></pre></td></tr></table></figure><p>纯虚函数只有函数的名字而不具备函数的功能，不能被调用。它只是通知编译系统：在这里声明一个虚函数，待派生类中定义。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>凡是包含纯虚函数的类的都是抽象类。因为纯虚函数是不能被调用的，包含纯虚函数的类是无法建立对象的。抽象类的作用是作为一个类族的共同基类。</p><p>抽象基类不能也不必要定义对象。</p><h4 id="区别静态关联和动态关联"><a href="#区别静态关联和动态关联" class="headerlink" title="区别静态关联和动态关联"></a>区别静态关联和动态关联</h4><p>在编译阶段就能确定调用的是哪一个类的虚函数，所以属于静态关联。如果是通过基类指针调用虚函数，在编译阶段无法从语句本身确定调用哪一个类的虚函数，只有在运行时，指针指向某一类对象后，才能确定调用的是哪一个类的虚函数，故为动态关联。</p><h2 id="第十三章-输入输出流"><a href="#第十三章-输入输出流" class="headerlink" title="第十三章 输入输出流"></a>第十三章 输入输出流</h2><h3 id="istream-类的其他成员函数"><a href="#istream-类的其他成员函数" class="headerlink" title="istream 类的其他成员函数"></a>istream 类的其他成员函数</h3><p>如果到达文件末尾（遇到文件结束符），eof 函数值为非零值（表示真），否则为 0（假）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文联合编辑：小辣辣。向她致以最崇高的敬（爱）意 ❤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第一章-C-的初步认识&quot;&gt;&lt;a href=&quot;#第一章-C-的初步认识&quot; class=&quot;headerlink&quot; title=&quot;第一章 
      
    
    </summary>
    
    
      <category term="C++" scheme="https://yazhidev.github.io/tags/C/"/>
    
      <category term="读书笔记" scheme="https://yazhidev.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>APK 的前世今生：从 Android 源码到 apk 的编译打包流程</title>
    <link href="https://yazhidev.github.io/2018/11/18/APK-%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%9A%E4%BB%8E-Android-%E6%BA%90%E7%A0%81%E5%88%B0-apk-%E7%9A%84%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <id>https://yazhidev.github.io/2018/11/18/APK-的前世今生：从-Android-源码到-apk-的编译打包流程/</id>
    <published>2018-11-18T05:03:28.000Z</published>
    <updated>2022-06-07T22:58:54.434Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要研究热修复的原理，并自己实现一套简单的热修复框架（音视频的坑刚挖好就又挖另一个坑了2333），已经在看书入门 c++，方便后续查看业内一些知名热修复框架的源码，另外在涉及编译期/运行时修改代码之前，先了解一下 apk 是如何从项目源码被打包生成的，可能对后续的从思路上或实际操作都会所裨益。</p><p>文中涉及到的工具所在目录：<code>Android/sdk/build-tools</code>。下面开始分解并逐步实现对源码的打包。</p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><h3 id="1-生成仅包含资源文件的-apk-包和-R-java-文件"><a href="#1-生成仅包含资源文件的-apk-包和-R-java-文件" class="headerlink" title="1. 生成仅包含资源文件的 apk 包和 R.java 文件"></a>1. 生成仅包含资源文件的 apk 包和 R.java 文件</h3><p>根据资源文件和 AndroidManifest.xml 由工具 AAPT 生成 R.java 文件。Android Gradle Plugin 3.0.0 以后默认使用 AAPT2，详见 <a href="https://developer.android.com/studio/command-line/aapt2" target="_blank" rel="noopener">AAPT2 官方文档</a>。来看一下 AAPT2 的使用：</p><h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><p>编译所有 Android 支持的资源文件。可以通过编译语句将单个资源文件编译成 <code>.flat</code> 后缀的过渡二进制文件</p><p>AAPT 可以编译单个文件，例如编译 strings.xml，会生成 values_strings.arsc.flat 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt2 compile app/src/main/res/values/strings.xml -o test/</span><br></pre></td></tr></table></figure><p>但一个项目不可能只有一个资源文件，通常都是编译 整个 res 资源目录，会生成 zip 压缩包，包含了所有资源文件编译后的 flat 格式文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt2 compile --dir app/src/main/res/ -o package/res.zip</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>–dir：指定输入目录</li><li>-o： 指定输出目录（如果输入源是文件夹，则需要指定编译后的（zip）文件名）</li></ul><h4 id="链接（link）"><a href="#链接（link）" class="headerlink" title="链接（link）"></a>链接（link）</h4><p>将预编译生成的过渡二进制文件合并并打包成单独的 APK 包，R 文件和 ProGuard 规则文件也是在这个时期生成的，生成的 APK 包不包含 DEX 字节码并且是未签名的（后续可使用 D8 编译工具将 Java 字节码编译成 DEX 字节码，使用 apksigner 对 APK 签名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aapt2 link package/res.zip \</span><br><span class="line">-I ~/Library/Android/sdk/platforms/android-27/android.jar \</span><br><span class="line">--java package/ \</span><br><span class="line">--manifest app/src/main/AndroidManifest.xml \</span><br><span class="line">-o package/res.apk</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>-I：必要参数，指定 android.jar 目录，因为 xml 中可能使用到了例如 android:id 等自带的 android 命名空间</li><li>o：指定输出 apk 路径</li><li>–java：指定生成的 R 文件的路径</li><li>–manifest：必要参数，Manifest 文件中包含了 app 的包名和 application id</li></ul><p>执行上述命令后报错：style/Theme.AppCompat.Light.DarkActionBar  not found. </p><p>以及 layout_constraintBottom_toBottomOf （新建的工程默认依赖了 constraint-layout库）等各种 not found。</p><p>报这些错是因为 link 时没有引入第三方库，在 Google 文档里没有找到相关的命令，所以先移除这些依赖，跑通整个流程后再回头看怎么解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// AppTheme 暂时先移除对 Theme.Appcompat 的依赖</span><br><span class="line"> &lt;style name=&quot;AppTheme&quot; parent=&quot;android:Theme.Holo.Light.DarkActionBar&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>再执行一遍命令，可以看到指定的输出目录已经生成了 apk 包和 R 文件：</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-23a3332793c1e3a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="仅包含资源文件的apk与R文件"></p><h3 id="2-处理aidl，生成对应的java文件"><a href="#2-处理aidl，生成对应的java文件" class="headerlink" title="2. 处理aidl，生成对应的java文件"></a>2. 处理aidl，生成对应的java文件</h3><p>因为 demo 没有涉及到 aidl，暂且跳过。</p><h3 id="3-编译-java-文件为-class-文件"><a href="#3-编译-java-文件为-class-文件" class="headerlink" title="3. 编译 .java 文件为 .class 文件"></a>3. 编译 .java 文件为 .class 文件</h3><p>编译项目 src 目录下所有 .java 文件还有之前生成的 R.java 、aidl 生成的 java 文件为相应的的 class 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-8 \</span><br><span class="line">-target 1.8 \</span><br><span class="line">-bootclasspath ~/Library/Android/sdk/platforms/android-27/android.jar \</span><br><span class="line">app/src/main/java/com/yazhidev/demo/*.java package/com/yazhidev/demo/R.java \</span><br><span class="line">-d package/</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>-encoding: 指定编码方式为 uts-8</li><li>-target：指定 Java 版本号</li><li>-bootclasspath：引入 Android.jar 包内的类</li><li>-d：指定编译生成的字节码文件存放的路径</li></ul><h3 id="4-class-文件编译为-dex-文件"><a href="#4-class-文件编译为-dex-文件" class="headerlink" title="4. class 文件编译为 dex 文件"></a>4. class 文件编译为 dex 文件</h3><p>dex 文件是 Android 虚拟机所能识别、解析并运行的文件。Java 源文件被编译为 class 文件后，需要通过 dex 编译器将多个 class 文件整合为一个 dex 文件，从 Android Studio 3.1 开始，已经使用 D8 替代原先的 DX 作为默认的 dex 编译器。D8 的使用很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d8 package/com/yazhidev/demo/*.class \</span><br><span class="line">--classpath ~/Library/Android/sdk/platforms/android-27/android.jar \</span><br><span class="line">--output ./</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>–classpath：指定编译需要引用到的类</li><li>–output：指定编译后生成的 .dex 文件的存放路径</li></ul><h3 id="5-将-dex-文件添加进-apk-包"><a href="#5-将-dex-文件添加进-apk-包" class="headerlink" title="5. 将 dex 文件添加进 apk 包"></a>5. 将 dex 文件添加进 apk 包</h3><p>原本这步是通过 apkbuilder 脚本来做的，现在改成用 aapt 命令来做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt add package/res.apk classes.dex</span><br></pre></td></tr></table></figure><p>需要注意的是 dex 文件前不能加路径，否则会将路径带入 apk 包中。</p><h3 id="6-优化对齐-apk-文件"><a href="#6-优化对齐-apk-文件" class="headerlink" title="6. 优化对齐 apk 文件"></a>6. 优化对齐 apk 文件</h3><p><a href="https://developer.android.com/studio/command-line/apksigner" target="_blank" rel="noopener">apksigner 文档</a>中提到，如果使用 apksigner 对 apk 签名，则需要在签名之前使用 zipalign 优化对齐。</p><p>zipalign 的使用很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zipalign 4 package/res.apk package/app-unsigned-aligned.apk</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">4 代表 32 位对齐，zipalign 可以确保所有未压缩的数据的开头均相对于文件开头部分执行特定的字节对齐，这样可减少应用消耗的 RAM 量。</span><br><span class="line"></span><br><span class="line">### 7. 签名</span><br><span class="line"></span><br><span class="line">签名需要私钥，可以通过 Android Studio 生成，也可通过 JDK bin 目录下的 keytool 工具生成。keytool 以及 apksigner 的使用可参考：[从命令行构建和签署您的应用](https://developer.android.com/studio/publish/app-signing)</span><br><span class="line"></span><br><span class="line">我自己这么就直接使用现有的 key 签名，签名的命令很简单：</span><br></pre></td></tr></table></figure><p>//apk 签名<br>apksigner sign –ks key.jks –out package/app-release.apk package/app-unsigned-aligned.apk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">参数含义：</span><br><span class="line">- --ks：指定私钥文件</span><br><span class="line">- --out：指定签名后的 apk 输出路径</span><br></pre></td></tr></table></figure></p><p>//检查 apk 的签名<br>apksigner verify app.apk<br><code>`</code></p><p>至此，就完成了 Android 源码打包成 apk 的整个流程，当然以上只是最简单的情况，对于第三方库、多 module 等情景下的打包流程都没有涉及。将 apk 安装到手机上，可以正常打开:</p><p><img src="https://upload-images.jianshu.io/upload_images/1929170-22e822fa268140b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="丑出天际的首页"></p><p>一打开首页我的内心的拒绝的，这首页可以说是丑出天际。但起码从 0 到 1 了（化身阿 Q 疯狂自我安慰），一番操作算是对 apk 的打包流程有了个笼统的认识，后面要了解一下 app 启动流程，为热修复的学习打基础。（也许后面会回来填坑？）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想要研究热修复的原理，并自己实现一套简单的热修复框架（音视频的坑刚挖好就又挖另一个坑了2333），已经在看书入门 c++，方便后续查看业内一些知名热修复框架的源码，另外在涉及编译期/运行时修改代码之前，先了解一下 apk 是如何从项目源码被打包生成的，可能对后续的从思路
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yazhidev.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
