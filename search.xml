<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[每个开发都应该懂的正则表达式]]></title>
    <url>%2F2022%2F06%2F08%2F%E6%AF%8F%E4%B8%AA%E5%BC%80%E5%8F%91%E9%83%BD%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在日常工作中，相信每个开发都接触过一些检索、替换字符串/文本的问题。对于一些简单的问题例如查找字符串中是否存在某个子串，可能直接使用各类开发语言自带的 api 接口就可以很方便地实现。但是一旦规则复杂起来可能就会比较棘手，例如校验邮箱、手机号、版本号等，如果自行实现可能需要写不少逻辑代码，正则表达式就是为了解决这类问题的。举个例子，以下是 CI 构建组件时对版本号的校验，你能够快速读懂其规则吗？如果你对此不甚了解，那相信这篇文章一定能给你带来一些收获。 什么是正则表达式如上图所示，正则表达式就是一串字符/^[0-9]+.[0-9].+[0-9]+$/，正则表达式规定了由一个或几个特殊的字符组合成一个规则，并且多个规则可以自由组合。 在学习正则表达式时，不要被表达式里的特殊符号所迷惑，觉得看起来好复杂，其实说白了这些字符只是一些规则的映射而已，并且需要注意的是，如果字符串里使用到这些符号还需要转义。 常见的字符有 * . ? + ^ - $ | \ / [ ] ( ) { }。另外有的开发语言在使用时需要将正则表达式使用 / 符号抱起来，形如 /xxx/，这个了解下即可。 既然正则表达式由一系列规则组成，每个规则都描述了一套匹配的逻辑，那么学习正则表达式其实就是在学习这些匹配规则。让我们先从最直观的匹配字符开始入手。在开始之前，推荐大家两个网站，一个是用于测试的 正则表达式规则测试，一个正则表达式图形化工具，便于我们理解。 匹配字符精确匹配例如从 abcde 里寻找 abc，那么很明显，我们的匹配规则就是需要精确匹配 abc，其规则自然就是 abc。这个不多赘述。 模糊匹配除了精确匹配以外，我们可能还需要一些模糊的规则，以便于发现/容纳更多可能。比如我们需要某处的字符是可变的，或者我们对于某处的字符数量不确定。因此就产生了横向和纵向两种字符模糊匹配。 横向（字符次数匹配）某处的字符数量可变，可以使用次数匹配规则。 常见的次数匹配规则有： {n}：限定n次 {m,n}：上下限次数（闭区间） +：一次或多次，等效于 {1,} ？：零次或一次，等效于 {0,1} *：任意多次 这些规则跟在某个字符后面，代表规则前面的字符长度可变。 例如正则表达式： a{2,3}c，代表 a 字符出现2次或3次，例如 aac、aaac 都是可以匹配的。但是 ac 是无法匹配的。 纵向某处的字符可变，比如需要匹配 dog 和 log。第一个字符有多种可能。 常见的字符可变规则有： . ：点代表任意字符 | ：或匹配。可以配合 () ，将多个子表达式组合 []：区间里的字符都是允许的，例如 [123]，代表该处的字符可以是 1 或 2 或 3 -：区间里使用，表示范围，例如 [1-3] 等同于 [123]，[a-z] 代表所有小写英文字母 ^：区间里使用，表示取反，例如 [^1-3] 代表除了 1、2、3 以外的字符这些规则放在某处，代表某处的字符是可变的。 例如 [dl]og ，代表中括号处（第一个字符）可以是 d 或 l，因此 log、dog 都是可以匹配的 除此之外，还会有一些常用的简写： \d：数字 \D：非数字 \w：数字大小写下划线，等同于 [0-9a-zA-Z_]​ \W：非单词字符，等同于 [^0-9a-zA-Z_] \s：空白字符，包括空白、tab、换行 匹配位置一个字符串，除了我们最直观看到字符以外，其实还暗含了许许多多的位置。这也是正则匹配的另一大块。什么是位置？首先用一张图来表示： 如图所示，一个字符串 hello，除了五个字符以外，每个字符首尾都有一个位置，这些位置都可以被匹配规则所扫描到。 常用的匹配位置的符号有： ^ ：代表一行的开头 $ ：代表一行的结尾 \b：单词边界。具体就是单词字符和非单词字符之间的位置。包括非单词字符和开头、结尾之间的位置 \B：非单词边界 可能有人对匹配位置的用法不太了解，举个例子，有一个字符串 123123，这时候如果你使用精确匹配规则 123，那么会匹配到两个123。但是如果配合 ^ 使用，将规则修改为 ^123，那么就只会匹配到第一个开头的 123，后续的 123 则不会被匹配到。 除此之外，关于匹配位置还有一个很灵活的特性：前瞻后顾 相关的规则有： exp1(?=exp2)​：前瞻，查找后面是exp2的exp1 = 查找exp2前面的exp1​（exp1、exp2 代表一个表达式） (?&lt;=exp2)exp1：后顾，查找exp2后面的exp1​ exp1(?!exp2)：负前瞻，查找后面不是exp2的exp1​ (?&lt;!exp2)exp1：负后顾：查找前面不是exp2的exp1​ 这个在过滤日志时十分有用。例如有一些重复关键字的日志： 12345678receive some errorreceive yuvreceive yuvreceive yuvreceive yuv//receive(?! yuv)可以使用负前瞻过滤掉一些不想要的日志。只会匹配到 receive some error 这一行的 rece 实际应用在对正则表达式有个大致的认识后，让我们回到文章的开头，看一下文章开头的版本号验证正则表达式代表什么含义：^[0-9]+.[0-9].+[0-9]+$ 这里可以明显看出是有问题的，例如表达式里的 . 应该需要转义，否则就代表任意字符，这明显不符合版本号要求。经过确认后得知是前端显示问题，并了解到他们实际校验使用的正则表达式是：^\d+\.\d+\.(\d+\.)*\d+((-rc\.\d+)|(\d*))$ 在对正则规则有个大致了解后，借助图形化工具可以很方便地了解正则表达式规则所代表的含义。例如 1.1.1.1.1 这样的版本号也是允许的，经了解 CI 之前有特殊原因没限制版本号一定是 3 位。并且可以看到除了 rc 字符以外，不允许其他英文字母。但同时我们也会发现另一个小问题，那就是类似 01.1.1 这样的版本号也是被允许的：如果让你来优化会怎么做呢？我认为优化后的规则可以这么写：^(0\.|[1-9][0-9]*\.)\d+\.(\d+\.)*\d+((-rc\.\d+)|(\d*))$。使用(0\.|[1-9][0-9]*\.)限制要么是0，要么是非0的两位以上数字，即可过滤 01.1.1 这样的不合理版本号。 相信看到这里，大家都对正则表达式有了一个大致的了解。对于正则表达式还有一些特性（例如捕获、贪婪等）没有提及，这里抛砖引玉，感兴趣的小伙伴可以自行了解。有了正则表达式的帮助可以让我们少写很多字符串判断逻辑的代码，除了让代码更简洁以外，也会大大提高代码的可读性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android OpenGL ES 开发]]></title>
    <url>%2F2020%2F08%2F11%2FAndroid-OpenGL-ES-%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[OpenGL(Open Graphics Library) 是开放图形库，是一个跨平台的图形 API。OpenGL ES(OpenGL for Embedded System)是专为移动端提供的一个子集。目前主要版本有1.0/1.1/2.0/3.0/3.1： 1.0：Ａndroid 1.0和更高的版本支持这个API规范 2.0：不兼容 OpenGL ES 1.x。Android 2.2(API 8)和更高的版本支持这个API规范 3.0：向下兼容 OpenGL ES 2.x。Android 4.3(API 18)及更高的版本支持这个API规范 3.1：向下兼容 OpenGL ES3.0/2.0。Android 5.0（API 21）和更高的版本支持这个API规范 先了解一下 OpenGl 几个相关的概念 相关概念管线也称渲染管线，因为 OpenGL ES 在渲染处理过程中会顺序执行一系列操作，这一系列相关的处理阶段就被称为 OpenGL ES 渲染管线。OpenGL ES 渲染过程就如流水线作业一样，这样的实现极大地提高了渲染的效率。如图就是 OpenGL ES 的管线图，学习OpenGL ES 就是学习这张图中的每一个部分。 图中阴影部分的 Vertex Shader(顶点着色器) 和 Fragment Shader(片元着色器) 是可编程管线 。 顶点OpenGl 物体图形都由点、线、多边形组成，组成他们的关键就在于顶点数据。绘制时需要准备绘制的位置，这些位置就是顶点，顶点组合起来就是顶点坐标。 坐标系OpenGl 使用右手坐标系，手机屏幕中心坐标系（0，0，0），左上角坐标（-1, 1, 0），依此类推。 着色器语言着色器的编程语言是基于 C 语言开发的，被称为 GLSL（OpenGL Shading Language），和 C 语言最大的区别是它新增了许多适合图形处理的东西，比如定义了向量和矩阵两个数据类型，另外 GLSL 也对高并发进行了特殊优化。 GLSL 详细语法可见：GLSL 中文手册 顶点着色器（Vertex Shader）顶点着色器分为输入和输出两部分，负责的功能是把输入的数据进行矩阵变换位置，计算光照公式生成逐顶点颜⾊，⽣成/变换纹理坐标。并且把位置和纹理坐标这样的参数发送到片段着色器。 顶点着色器的输入数据由下面组成： Attributes：使用顶点数组封装每个顶点的数据，一般用于每个顶点都各不相同的变量，如顶点位置、颜色等。 Uniforms：顶点着色器使用的常量数据，不能被着色器修改，一般用于对同一组顶点组成的单个3D物体中所有顶点都相同的变量，如当前光源的位置。 Samplers：这个是可选的，一种特殊的 uniforms，表示顶点着色器使用的纹理。 Shader program：顶点着色器的源码或可执行文件，描述了将对顶点执行的操作。 顶点着色器对于 3D 模型网格的每个顶点执行一次，确定顶点的最终位置。顶点着色器取得一个位置及相关的颜色数据作为输入属性，用一个 4x4 矩阵变换位置，并输出变换后的位置和颜色。 顶点着色器是可编程渲染管道，例如一个简单的顶点着色器： 12345attribute vec4 aPosition;void main() &#123; gl_Position = aPosition;&#125; 上面例子里的 gl_Position 是顶点着色器的内建输出变量。 gl_Position： 顶点坐标gl_PositionSize：点的大小，默认值是 1 图元装配图元指的是点、直线和三角形。该过程还有两个重要操作：裁剪和淘汰。对不在屏幕可见的 3D 区域内的图元进行裁剪，根据图元面向前方或后方选择抛弃它们（比如物体内部的点）。 光栅化将图元转为片段的过程称为光栅化。片段可以理解为带有深度信息的像素点。屏幕上的一个像素点可能对应多个片段。 片段着色器（Fragment Shader）片段着色器用于对片段进行处理，例如纹理采样、颜色汇总等，将每个片段的颜色等属性计算出来并向后传输。编写片元着色器可以实现滤镜、美颜、图片处理、类似抖音的一些特效等效果。片段着色器对光栅化之后 2D 图像中的每个像素处理一次，3D 物体的表面最终显示成什么样子由片段着色器决定。 片段着色器也是可编程的，例如： 123void main() &#123; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0)&#125; gl_FragColor 是片段着色器的内建输出变量，指当前片元的颜色。 GLSurfaceView我们都知道 SurfaveView 最大的特点是可以在子线程中绘制图象，GLSurfaceView 继承自 SurfaceView，其实是对 SurfaceView 再做了一次封装，方便在 Android 中使用 OpenGL。 GLSurfaceView 的渲染被委托给渲染器在独立的渲染线程里进行，通过 setRender(Render) 设置渲染器。 HelloWorld了解相关概念后，先动手编写个简单的 Demo 实操一下。Android 上使用 OpenGl ES 流程如下： 在 AndroidMenifest 中设置 OpenGL 版本： 如果应用不指定 android:glEsVersion 属性，则系统默认使用 OpenGL ES 1.0，即所有 Android 设备都支持的版本。 1&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt; 自定义渲染器 新建类实现 GLSurfaceView.Renderer 接口，并在三个回调方法中做相应操作。 在 Surface 创建时，设置设置清除后的颜色预设值 在 Surface 变化时，更新视口矩形宽高、窗口位置 在每次绘制帧时，清空颜色缓冲并置为预设颜色 12345678910111213141516class CustomRender: GLSurfaceView.Renderer &#123; override fun onDrawFrame(gl: GL10?) &#123; //绘制当前帧 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); &#125; override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) &#123; //surface 变化时的回调，包括尺寸变化、设备屏幕方向变化等 GLES20.glViewport(0, 0, width, height); &#125; override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) &#123; //surface 创建时的回调 GLES20.glClearColor(0.0f, 0.0f, 1.0f, 1.0f) &#125;&#125; 自定义 GLSurfaceView 新建类继承自 GLSurfaceView，并在初始化时设置渲染器 12345class CustomGLSurfaceView(context: Context?) : GLSurfaceView(context) &#123; init &#123; setRenderer(CustomRender()) &#125;&#125; 展示 GLSurfaceView 将 GLSurfaceView 添加到布局 123456789class KotlinActivity : AppCompatActivity() &#123; private val glSurfaceView by lazy &#123; CustomGLSurfaceView(this) &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(glSurfaceView) &#125;&#125; 运行之后，页面会显示蓝色背景，这是 GLSurfaceView 最简单的运用，简单到我都不好意思放效果图。但千里之行始于足下，下一次我们接着深入 GLSurfaceView 的使用，动手编写着色器来实现图形绘制。 Comming soon :P]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 类型转换精度问题]]></title>
    <url>%2F2020%2F08%2F01%2FJava-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基本数据类型占用内存大小最近项目中修复了一个关于类型转换精度丢失的问题，以前对于类型转换会丢失精度只知其然，不知其所以然，这次了解了下相关原理，也分享给大家。先来回顾一下 Java 的基本数据类型中整型与浮点型及其所占用的内存大小： 整型： int：4 字节 32 位 long：8 字节 64 位 浮点型： float：4 字节 32 位 double：8 字节 64 位 Java 运算时，当两个不同类型的数进行基本运算符操作时，低精度会自动向高精度转换，字节短的会自动向字节长的转换。 《Java 核心技术》一书中这么归纳到： 如果两个操作数其中有一个是 double 类型，另一个操作就会转换为 double 类型。否则，如果其中一个操作数是 float 类型，另一个将会转换为 float 类型。否则，如果其中一个操作数是 long 类型，另一个会转换为 long 类型。否则，两个操作数都转换为 int 类型。 需要注意 Java 自动转换类型可能会带来精度的丢失，附上一张不会丢失精度的合法类型转换说明图： 图中实现箭头类型转换代表不会丢失精度，虚线箭头类型转换可能会丢失精度。 基本数据类型表示范围精度和数据类型可表示的数值大小范围息息相关，计算机中所有数值归根到底都是使用二进制 0、1 来组成，因此一个数据类型所占用的内存大小越大，就意味着可用的二进制位数越多，当然可表示的范围就越大。回顾一下几个常见的参与运算的基本数据类型的取值范围： int 二进制位数：32最小值：Integer.MIN_VALUE= -2147483648 （-2 的 31 次方）最大值：Integer.MAX_VALUE= 2147483647 （2 的 31 次方 -1） long 二进制位数：64最小值：Long.MIN_VALUE=-9223372036854775808 （-2 的 63 次方）最大值：Long.MAX_VALUE=9223372036854775807 （2 的 63 次方 -1） float 二进制位数：32最小值：Float.MIN_VALUE=1.4E-45 （2 的 -149 次方）最大值：Float.MAX_VALUE=3.4028235E38 （2 的 128 次方 -1） double 二进制位数：64最小值：Double.MIN_VALUE=4.9E-324 （2 的 -1074 次方）最大值：Double.MAX_VALUE=1.7976931348623157E308 （2 的 1024 次方 -1） 当 long 类型的数大于 Integer.MAX_VALUE 时，long 强制转换 int，就会出现丢失精度。转换过程是将 long 类型数值的二进制数从低位到高位截取 32 位，再将 32 位二进制数转为 int。 123long l3 = 24696061952L; //10111000000000000000000000000000000int c3 = (int)l3; //-1073741824System.out.println(Integer.toBinaryString(c3)); //1000000000000000000000000000000 上面的例子中，long 类型截取 32 位后转为 int，最高位作为符号位，1 代表负数，强转后的 int 值为 -1073741824。类似这种不合理的强制转换丢失的已经不仅仅是精度了。 不知道有没有人注意到，long 类型的二进制位数是 64，float 类型的二进制位数是 32，但是 float 类型可表示范围却远远大于 long 类型。更不用提一样是 32 位的 int 了，float 到底啥家庭啊？谜底就在内存结构中。 浮点类型数值的内存结构与整形类型的内存结构不同，float 在内存中是这样的： SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM S：最高位 S 代表符号位 E：后面 8 位 E 代表指数域，二进制中就是 2 的 n 次方，采用移位存储(127+指数)的二进制方式。 M：剩下的 23 位 M 代表小数域。规定小数点前的数必须为 1，因此只记录小数点后的数。（从左往右，低位补零） 以 7.8125 为例，整数十进制转二进制，除 2 取余，逆序排列，求得 7 二进制为 111。小数十进制转二进制，乘 2 取整，顺序排列，求得 0.8125 二进制为：0.1101，组合起来是 111.1101。 根据规范，小数点前的数只保留 1，因此将 111.1101 小数点左移两位得 1.111101 * 2^2。 符号位 0，指数位为 2+127=129，即二进制 10000001，小数域为 111101。因此 float 数 7.8125 在内存中存储的格式为：0 10000001 111101 低位补零补齐到 32 位，得：0100 0000 1111 1010 0000 0000 0000 0000。 可以使用 Java 提供的 API 验证一下： 1234int i = Float.floatToIntBits(7.8125F); //得到 7.8125F 底层数据（十进制）Integer.toBinaryString(i); //得到指定 int 值的二进制数//输出 1000000111110100000000000000000//补上最高位符号位 0，结果与上面计算的一样。 通过对浮点类型数值内存结构的了解，我们知道了 float 虽然可用于存储数值的位数没有 long 型多，但是 float 通过使用指数进行降维打击，可表示范围蹭蹭蹭往上涨。 double 的内存结构同理，只不过 double 二进制位数更多，总共 64 位分别分配给：符号位 1 位，指数位 11 位，小数位 52 位。 需要注意的是，虽然 float 因为有指数的概念，可表示范围变大了，但是其用于存储小数的位数却只有 23 位。这就意味着当一个整型类型数值的二进制位大于 24 位时，类型转换到 float 就会带来精度丢失了。 整型转换浮点型的精度丢失问题看到上图中的int 转 float、long 转 float 都是虚线表示，代表运算时自动类型转换可能会出现精度丢失的问题。经过上面对浮点型数据内存结构的学习，我们应该不难理解，float 能表示的数的大小靠指数位，但是表示的数的精度需要靠小数位。而 float 的小数位只有 23 位，而 int 是 32 位。 举个例子：int 值 16777217，二进制数 1 0000 0000 0000 0000 0000 0001，除去最高位符号位后，需要 25 位表示。 顺带提一下，计算某个数值除了符号位外需要多少位二进制位可以表示，除了挨个去数二进制数外，还可以直接计算 log2 的值： 123int i = 16777217;double num = Math.log(i) / Math.log(2.0);//num = 24.000000085991324，即需要 25 位二进制位表示 int 转 float，转换过程是先将 int 的数值由十进制转为二进制，再通过对二进制数左移小数点直到个位为 1，变为：1. 0000 0000 0000 0000 0000 0001 * 2 ^ 24，转换后的数小数点后有 24 位，对 float 来说只能舍弃掉无法表示的位数，只保留 23 位小数位，指数位 24 + 127 = 151，二进制为 10010111，因此转换后的 float 二进制数为 110010111 + 23个0，float 值为 1.6777216E7，已经丢失了精度。 同理，int 转 double，由于 double 有 52 位小数位，因此足以 hold 住 int 的精度，而 long 需要 64 位表示精度，因此 long 转 double 也可能出现精度丢失。另外需要注意的是，单位秒的时间戳，也需要 31 位来表示，用 int 表示是够的，但是转 float 也一样会丢失精度。 以上就是对 Java 类型转换精度问题的分析，希望对你有帮助 :P]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识 YUV]]></title>
    <url>%2F2020%2F06%2F20%2F%E8%AE%A4%E8%AF%86-YUV%2F</url>
    <content type="text"><![CDATA[什么是 YUVYUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。与RGB类似，但RGB更多的用于渲染时，而YUV则用在数据传输，因为它占用更少的频宽。当然，实时通讯为了降低带宽都会采用H264/H265编码。YUV的含义：Y代表亮度信息（灰度），UV分别代表色彩信息。YUV的常用名称有许多，例如YUV422、YUV420、YUV444等。 采样格式YUV 后面常带着三个数字，其含义代表 YUV 信息在像素点中的分布状况，也就是采样格式： YUV444 代表每个 Y 对应一组 UV，每个像素占3个字节。 存放码流：Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3 YUV422 代表每 2 个 Y 对应一组 UV 存放码流：Y0 U0 Y1 V1 Y2 U2 Y3 V3 YUV411 代表每 4 个 Y 对应一组 UI 存放码流：Y0 U0 Y1 Y2 V2 Y3 YUV420 代表每个像素独有一个 Y，每四个像素共享一个 U，每四个像素共享一个 V 以 YUV420 为例，Y 数据有效字节数为=Height×Width；U数据有效字节数=(Height/2)×(Width/2)；V数据有效字节数=(Height/2)×(Width/2)； YUV420 是一类格式的集合，包含 I420、NV21 等不同格式，格式不同，YUV 的排列顺序也不同（Y 的顺序是一样的，UV 不一样）。官方将 YUV 三个平面都称为颜色平面（color plane）。Android 中使用 ImageProxy 的 getPlanes() 方法可得三个平面。 NV21 是，planes[1] 是 UVU，planes[2] 是 VUV。 NV21 存储的 UV 数据是有冗余的，取 planes[1] 每一排的奇数字节可得所有 U 数据，取 planes[2] 每一排的偶数字节可得所有 V 数据。 存储方式上面提到的 planes 是平面的，YUV 存储在三个独立的数组中。还有另外一种存储方式：packed（打包的），YUV 是连续交错存储的。 例如 YUY2 就属于 packed 类型，数据以第一个字节存放 Y0，第二个字节存放 U0，再 Y1、V0、Y1 等等，每四个字节，Y0 和 Y1 共用 U0、V0 分量，依次类推。 YUV 图像显示显示 YUV 图像需要使用 OpenGl 库调用 GPU 资源。或者先将 YUV 图像转换为 RGB 图像。Android 提供了 YuvImage 将 YUV 数据转换成 jpeg 的方法，目前只支持 NV21 和 YUY2。这里编写一段测试代码眼见为实。 测试图片地址 先使用 ffmpeg 将 jpeg 图片转为 NV21 格式用于测试： ffmpeg -i icon.jpg -s 960x960 -pix_fmt nv12 nv12.yuv 得到 yuv 格式图片 后，存放到手机目录下，然后编写测试代码： 1234567891011121314151617181920212223val file = File(Environment.getExternalStorageDirectory().path + "/1dev/nv21.yuv")if (file.exists()) &#123; try &#123; //从本地读取 yuv 图片字节数据 val fileInputStream = FileInputStream(file) var data = ByteArray(fileInputStream.available()) fileInputStream.read(data) fileInputStream.close() //测试图片分辨率 val width = 960 val height = 960 //将 yuv 图片字节数据存放到 YuvImage 中 var yuvImage = YuvImage(data, ImageFormat.NV21, width, height, null) val out = ByteArrayOutputStream() //使用 compressToJpeg 将存储的 yuv 数据转化为 RGB 图像 yuvImage.compressToJpeg(Rect(0, 0, width, height), 50, out) val imageBytes = out.toByteArray() val bitmap = BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size) iv.setImageBitmap(bitmap) &#125; catch (e: FileNotFoundException) &#123; e.printStackTrace() &#125;&#125; 获得 bitmap 后就可以使用 ImageView 显示了。 到这里其实还只是 api 层面的使用，后续还应该深入了解 YUV 到 RGB 的转换原理。另外 YUV 视频渲染、OpenGL es 的使用等，后续再学习记录~]]></content>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 Git]]></title>
    <url>%2F2020%2F02%2F21%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Git%2F</url>
    <content type="text"><![CDATA[开篇你可能遇到过 如果你遇到这个场景，那你可能需要版本控制。 什么是版本控制 版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了已录下来。每一次文件的改变，文件的版本号都将增加。除了记录版本变更外，版本控制的另一个重要功能是并行开发。软件开发往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。并行开发中最常见的不同版本软件的错误(Bug)修正问题也可以通过版本控制中分支与合并的方法有效地解决。 —— 版本控制 from 百度百科) 版本控制分为集中式、本地式、分布式。 Git：分布式版本控制git 是一套以键值存储的文件寻址系统。 工作区 Workspace：工作区 Index：暂存区 Repository：仓库 Remote：远程仓库 数据存储原理SH1A 算法哈希算法的一种。对文件内容进行计算，可以得到一个哈希值，形如 5453545dccd33565a585ffe5f53fda3e067b84d8。对于内容不同的对象，会计算得到不同的SHA1哈希值。 几种类型文件Git 目录（.git/objects/）的几种（对象）类型文件： blob用来存储文件内容，或者说表示一个（完整的）文件，而不仅仅只是差异存储。Git 通过使用 zlib 压缩文件，可以有效地压缩文本文件的体积。因此 Git 比较适用于对文本文件的管理，对于二进制文件（比如音频、视频）则压缩比不大。每个 blob 对象都会通过 SHA1 算法生成哈希值作为指针（或者叫索引、Key等），指向该文件的压缩。两个一样内容只是名字不同的文件，会共享同一个 blob 对象。因为内容的 SHA1 是一样的。 index这里说的 index 就是上面说的暂存区的实体存在，其实是一个文件，位于 .git/index ，直接打开会乱码，可以使用命令 git ls-files --stage 查看： 1234git ls-files --stage----100644 92390d97e4159df5c7ef31baf03c8a3378c93395 0 a.txt100644 ff532afc325d8a07df0e2e3cb37bbee271d05840 0 dirb/b.txt 里面记录了所有跟踪文件的 blob 对象的哈希值，以及文件的路径。如果文件内容没有改变，index 里则一直指向旧的哈希值。 tree代表的是目录结构，或者简单理解为代表一个目录。tree 对象也会通过 SHA1 算法生成哈希值作为指针。tree 对象中包含一条或多条 blob 的指针。目录结构如果是一样的，会共享同一个 tree 对象。 commitcommit 存储一次提交的信息，包括 tree、blob，父节点（的 commit id），以及提交的作者是谁等信息。commit 的 ID 值就是对对象内容进行 SHA1 算法得到的哈希值。 如何存储数据git add，生成 blob 文件，同时 index 文件中记录。git commit 时，根据 index 文件中记录的内容，生成 tree 对象和 commit 对象。 一些概念分支体现在目录的 ./git/refs/heads/ 中，这里包含master和一些其他分支文件。每个分支文件保存的是一个 commitID。 标签其实就是保存了 commitID 常用命令了解了原理后，再回过头来看一些常用的 Git 命令： 12345git addgit commitgit pullgit push... 结语分享个小故事。大家应该都知道 Linux ——世界上最知名的开源操作系统，Android 系统就是基于 Linux 内核开发。它由 Linus Torvalds 在 1991 年发明，并最终经由开源社区的无数个开发者共同开发，至今仍然是最充满生命力的操作系统之一。 2005 年，Linux 开发团队一直使用的商业版本控制系统 BitKeeper 宣布不再免费授权社区使用，Linus 在各种交涉无果后，花了两周时间自己用 C 写了一个分布式版本控制系统并且开源了，一个月之内整个 Linux 系统的源码就交由 Git 管理了。至此之后 Git 迅速成为最流行的版本控制系统之一。2008 年，Github 网站上线，为开源项目免费提供 Git 存储，总多知名项目纷纷迁移至 Github，同时也造福了无数的个人开发者。 开源万岁！参考Git 是如何存储文件的Git底层原理]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机编码原理]]></title>
    <url>%2F2019%2F07%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[码表理解计算机保存的是二进制代码，使用码表使每个二进制代码代替十进制数。这张表中规定了字符和二进制的映射关系。计算机存储字符时将字符查询码表，然后存储对应的二进制。计算机取出字符时将二进制查询码表，然后转换成对应的字符显示。 ASCII美国码表，码表中只有英文大小写字母、数字、美式标点符号等。每个字符占用1个字节，所有字符映射的二进制都为正数，因此有128个字符映射关系。 GBK/GB18030GBK 编码是使用双字节来表示的，即不论中、英文字符均使用双字节来表示，为了区分中文，将其最高位都设定成1。GBK包含全部中文字符，是国家编码，通用性比UTF8差，不过UTF8占用的数据库比GBK大。 UnicodeUnicode 是一个很大的集合，是十六进制的，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。 Unicide 是一个符号集，规定了符号的二进制代码，却没有规定如何存储二进制代码。那么如何区别 unicode 和 ascii 呢？计算机怎么知道三个字节表示一个符号，而不是三个符号？于是就衍生了 UTF-8。 UTF-8UTF-8 是 unicode 的一种实现方式之一。它是一种可变长度字符集,每个字符编码最多四个字节。 UTF-8的编码规则很简单，只有二条： 对于单字节的符号，字节的第一位（字节的最高位）设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 Unicode符号范围 (十六进制) UTF-8编码方式 （二进制） 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 因此对于英语字母，使用 utf-8 与 ascii 是一样的。 UTF-8 存储的字符，除了第一个字节外，其余字节的头两个比特都是以”10”开始，使文字处理器能够较快地找出每个字符的开始位置。 举个栗子例如“严”，unicode 字符是 4E25（100111000100101），4e25 在第三行范围，因此需要三个字节，将二进制码以此替换掉上面的 x，得到最终的 utf-8 编码为：11100100 10111000 10100101。转换成十六进制就是E4B8A5 虽然 utf-8 具有良好的国际通用性，但是 utf-8 中的中文使用三个字节来编码，比 gbk 多占用了 50% 的存储空间。下面来介绍 gbk 编码方式。 Base64是基于 64 个可打印的字符来表示二进制的数据的一种方法，用于解决中文、日文等文字无法被服务器或网关有效处理。 64 个字符：A~Z、a~z、0~9、+、/，还会使用 = 做填充字符 转换步骤 三个字节分一组，每个字节 8 位，总共 24 位 将 24 位每 6 位分一组，共分为四组（如果不足6位则补0，如果 6 位全是空的，则使用 = 号代替） 每组前面添加 2 个 0，变为 8 位二进制位，共四个字节 使用每个字节的值作索引，获得对应的值 参考一篇文章彻底弄懂Base64编码原理]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Kotlin 核心编程》读书笔记]]></title>
    <url>%2F2019%2F07%2F17%2F%E3%80%8AKotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第四章密封类 sealed密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。 第五章 类型系统as 不安全的类型转换，转换失败会抛类型转换失败异常。使用 as？ 转换失败返回 null。 Int 等同于 int Int? 等同于 Integer 协变与不变java 中数组是协变的，意思就是任意 A 是 B 的父类，则 A[] 也是 B[] 的父类。 List 是不变的，只知道自己是一个 Lit，无法获取泛型参数的类型。Kotlin 中数值支持泛型，当然也不再协变。Any 是所有类的父类，但是你不能将任意一个对象数组赋值给 Array。 Kotlin 中 List 是协变的。因为 Kotlin 中 List 的定义是 publick interface List&lt;out E&gt; : Collection&lt;E&gt; {}，out 关键字，说明泛型类和泛型方法是协变的。为了保证类型安全，kotlin 中的 List 是无法添加元素的。 获取泛型类型 通过匿名内部类 泛型虽然是类型擦除的，但是类型信息是放在对应 class 的常量池中的。匿名内部类在初始化的时候会绑定父类或父接口的相应信息。 12val list = object: ArrayLisr&lt;String&gt;()print(list.javaClass.genericSuperclass) 使用内联函数 kotlin 内联函数在编译的时候编译期会将相应的字节码插入调用的地方，也就是说，参数类型也会被插入字节码中。 1234//在kotlin中一个内联函数（inline）可以被具体化（reified），这意味着我们可以得到使用泛型类型的Classinline fun &lt;reified T&gt; getType() &#123; return T::class.java&#125; 需要注意的是，Java 并不支持指定一个函数是否内联，所以 reified 来实例化的内联函数不能在 Java 中调用，因为它永远是需要内联的。 协变和逆变 -&gt; Java 中的 &lt;? extends T&gt; -&gt; Java 中的 &lt;? super T&gt; 第 6 章 Lambda 和集合序列 sequence序列是惰性求值（延时求值）的，普通集合进行链式操作是（例如 filter、map），每一步都会先产生新的集合，而序列则是将所有操作都应用在一个元素上，当第一个元素执行完 filter、map 后，第二个元素再继续执行 filter、map。 与 Java8 的流（Stream）不同，流是一次性的，只能遍历一次。 内联函数inline 修饰的函数，会被内联进调用它的地方。直接在字节码中生成相应的函数体实现 实现非局部返回123456789fun localReturn() &#123; return&#125;fun foo() &#123; print(&quot;1&quot;) localReturn() print(&quot;2&quot;)&#125;//打印出12 因为函数体中的 return 只会在该函数的局部生效 123456fun foo(returning: () -&gt; Unit) &#123; print(&quot;1&quot;) returning() print(&quot;2&quot;)&#125;//报错：Lambda 中不允许存在 return 这时可以使用内联函数， 12345inline fun foo(returning: () -&gt; Unit) &#123; print(&quot;1&quot;) returning() print(&quot;2&quot;)&#125; 还可以使用标签实现 Lambda 非局部返回 123fun main() &#123; foo &#123;return@foo&#125;&#125; 第七章 多态和扩展运算符重载operator 关键字叫上 Kotlin 规定的函数名：plus（加法），minus（减法），times（乘法），div（除法），mod（取余）等 123456789data class Area(val valus: Double)operator fun Area.plus(that: Area): Area &#123; return Area(this.value + that.value)&#125;fun main() &#123; print(Area(1.0) + Area(2.0))&#125; 扩展函数实现机制可以将扩展函数理解为静态方法。 使用扩展函数添加属性： 12val Mutablelist&lt;Int&gt;.sumIsEven: Boolean get() = this.sum() % 2 == 0 静态与动态调度调用重载方法时，调用变为静态并且取决于编译时类型 123456void foo(Base base) &#123;&#125;void foo(Extanded base) &#123;&#125;Base base = new Extended()foo(base) //调用的是 Base 参数类型的方法 第九章 设计模式装饰者模式 使用类委托减少样板代码 使用 by 关键字，将装饰类的所有方法委托给被装饰对象，然后只需要复写需要装饰的方法即可。 使用扩展函数代替装饰者 第十章 函数式编程惰性求值也称正则序，当用到时才求值 第十一章 异步和并发同步与异步同步指的是一个行为，当执行的时候，在代码层面需要我们主动去等待结果，直到结果返回。 多线程执行时看上去是同步执行，但是线程执行是通过 CPU 调度，CPU 在每个线程间快速切换，同一个时间片内只能执行一个线程。 协程协程是一个无优先级的子程序调度组件，允许子程序。线程包含于进程，协程包含于线程。只要内存只够， 一个线程中可以有任意多个协程，但某一个时刻只能有一个协程在运行，多个协程共享该线程分配到的计算机资源。 launch 和 runBlockingrunBloking 是最高级的协程，也就是主协程。launch 创建的线程能够在 runBlocking 中运行，反过来不行。runBlocking 会阻塞当前执行的线程。 join1234val job = launch &#123; search()&#125;job.join() join 后程序会一直等待，直到启动的协程结束。这里的等待是非阻塞式的等待，不会将当前线程挂起。 async会创建一个子协程，会和其他子协程一样并行工作。async 会返回一个 Deferred 对象。Deferred 值是一个非阻塞可取消的 future，是一个带有结果的 job。 future 的意思是，将来会返回一个结果，利用 await 方法可以等待这个值的结果。]]></content>
      <tags>
        <tag>Kotlin</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解 WindowManagerService]]></title>
    <url>%2F2019%2F04%2F15%2F%E7%90%86%E8%A7%A3%20WindowManagerService%20%2F</url>
    <content type="text"><![CDATA[相关概念Window是一个抽象类，唯一的实现类是 PhoneWindow 分类： 父 Window 子 Window，不能单独存在，需要依附在父 window 上，例如 dialog 系统 Window，例如 toast PhoneWindow在 Activity attach 时构造了 PhoneWindow 的实例对象。 WindowManager是一个接口，用于操作 Window，继承了 ViewManager。实现类是 WindowManagerImpl ViewManager 的方法： 123public void addView(View view, ViewGroup.LayoutParams params);public void updateViewLayout(View view, ViewGroup.LayoutParams params);public void removeView(View view); 可以看到三个操作方法都是针对 View 的，View 是 Window 的实体类 WindowManagerImpl没有直接操作 View，而是交个了 mGlobal（WindowManagerGlobal） 12345 @Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; WindowManagerGlobal保存了所有的 ViewRootImpl，在 addView 时会创建 ViewRootImpl 实例，并将要 add 的 View 设置给 ViewRootImpl（见源码 1.1） View 的绘制过程是由 ViewRootImpl 来完成的。在新建一个 Activity 时，这个要 add 的 View 就是 DecorView。 IWindowSession(AIDL)窗口令牌，描述了一个显示行为，并且WMS要求每一个窗口必须隶属于某一个显示令牌。 WindowState当向WMS添加一个窗口时，WMS会为其创建一个WindowState。 WindowManagerService（WMS）WMS为所有窗口分配Surface，掌管Surface的显示顺序（Z-order）以及位置尺寸，控制窗口动画，并且还是输入系统的一重要的中转站。 源码1.11234567891011//WindowManagerGlobal private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ViewRootImpl root; root = new ViewRootImpl(view.getContext(), display); mRoots.add(root); root.setView(view, wparams, panelParentView);&#125; 参考Android 带你彻底理解 Window 和 WindowManager 深入理解WindowManagerService WindowManagerService 分析]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HandlerThread、IntentService 理解]]></title>
    <url>%2F2019%2F04%2F02%2FHandlerThread%E3%80%81IntentService%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HandlerThreadHandlerThread 继承 Thread，HandlerThread 本质上就是一个普通 Thread，只不过内部建立了 Looper，因此拥有自己的消息队列。不适合频繁处理耗时操作，因为消息是串行处理的，某个人任务执行时间过长，会导致后续的任务被延迟处理 通过调用 Thread 的 start 方法开始运行结束消息轮询也是通过操作 Looper 实现的，退出 Looper 后，线程没有可执行代码，则会自动结束 源码在 run 方法内初始化12345678Looper.prepare();synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll();&#125;Process.setThreadPriority(mPriority);onLooperPrepared();Looper.loop(); //开启轮询，因此除非主动退出，否则线程不会结束 12345678public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false;&#125; 还有个 quitSafely 方法。二者的区别是调用了 MessageQueue 的 void quit(boolean safe) 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// MessageQueuevoid quit(boolean safe) &#123; ··· if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; ···&#125;// removeAllMessagesLocked 方法，将队列里的所有消息不经检查直接回收private void removeAllMessagesLocked() &#123; Message p = mMessages; while (p != null) &#123; Message n = p.next; p.recycleUnchecked(); p = n; &#125; mMessages = null;&#125;//removeAllFutureMessagesLocked 会将延时消息移除，非延迟消息会派发private void removeAllFutureMessagesLocked() &#123; final long now = SystemClock.uptimeMillis(); Message p = mMessages; if (p != null) &#123; if (p.when &gt; now) &#123; removeAllMessagesLocked(); &#125; else &#123; Message n; for (;;) &#123; n = p.next; if (n == null) &#123; return; &#125; if (n.when &gt; now) &#123; break; &#125; p = n; &#125; p.next = null; do &#123; p = n; n = p.next; p.recycleUnchecked(); &#125; while (n != null); &#125; &#125;&#125; IntentService四大组件是在主线程的，不可执行耗时操作。IntentService 是个抽象类，需要实现抽象方法 onHandleIntent（可在该方法内执行耗时操作）。IntentService 会拥有消息队列（内部使用了 HandlerThread 的 Looper），且会在回调 onHandleIntent 后自动 stopSelf，销毁 Service。 源码12345678910111213141516171819202122232425262728293031@Overridepublic void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); //创建 HandlerThread 实例，并开启线程（Looper 轮询） thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125;// ServiceHandler 收到消息后回调 onHandleIntent，执行用户的操作，执行完后销毁自身private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125;// 开启 Service 后就发送个消息@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 内存模型]]></title>
    <url>%2F2019%2F03%2F28%2FJava-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。 经典问题： 20 个线程，每个线程都对同一个 int 做自增操作 100 次，最后的结果 i 一定小余 2000。 Java中的运算操作，例如自增或自减，若没有进行额外的同步操作，在多线程环境下就是线程不安全的。num++解析为num=num+1，明显，这个操作不具备原子性，多线程并发共享这个变量时必然会出现问题。 原因： 普通变量的值在线程间传递都需要通过主内存来完成。例如，线程 A 修改了一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。 原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。 Java中的原子操作包括： 除long和double之外的基本类型的赋值操作（long和double占用的字节数都是8，在32位操作系统上对64位的数据的读写要分两步完成，虽然 volatile 只保证可见性，但 java 内存模型保证声明为 volatile 的long和double变量的get和set操作是原子的。） 所有引用reference的赋值操作 java.concurrent.Atomic.* 包中所有类的一切操作。 可见性一个线程对一个变量进行更改操作 其他线程获取会获得最新的值 sleep 方法并没有加锁，为什么能够保证可见性。sleep是阻塞线程并不释放锁，让出cpu调度。让出cpu调度后下次执行会刷新工作内存 指令重排在单线程中不影响最终结果，jvm 会对指令做优化排序 1234567891011//在线程A中执行:context = loadContext(); （1）contextReady = true; （2）//在线程B中执行:if(contextReady) &#123; context.xxx &#125; 1，2 的顺序可能因为指令重排做了调换。先执行2，再执行1。 因此在多线程中可能导致线程 B 中， context 还没有初始化，但 contextReady 已经是 true，就报空指针。 内存屏障1.阻止屏障两侧的指令重排序；2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。 volatile 内存屏障策略： 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障； 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障； 因此 volatile 可以做到： 线程的可见性 volatile 变量在各个线程的工作内存中不存在一致性问题。因为每次赋值后，都会通过内存屏障更新主存中的值。 禁止指令重排 因为每次读写前后都会插入内存屏障，而内存屏障前后的指令不可被重排。 但是需要注意的是 volatile 只保证可见性，并不保证原子性。为了实现上述 i++ 的原子性运算，需要用到实现线程安全的两个保障手段：阻塞同步和非阻塞同步都是。 阻塞同步 即加锁。但是会带来线程阻塞和唤醒的性能开销 非阻塞同步 对于阻塞同步而言主要解决了阻塞同步中线程阻塞和唤醒带来的性能问题。在并发环境下，某个线程对共享变量先进行操作，如果没有其他线程争用共享数据那操作就成功；如果存在数据的争用冲突，那就才去补偿措施，比如不断的重试机制，直到成功为止，因为这种乐观的并发策略不需要把线程挂起，也就把这种同步操作称为非阻塞同步（操作和冲突检测具备原子性）。Java 中实现 CAS 乐观锁的方式是使用 AtomicInteger。 CAS（Compare-And-Swap 比较并交换）CAS 操作包含三个操作数：内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。 Java 的 CAS 会使用 cpu 上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作。但 CAS 也存在一些问题： ABA 问题 如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 循环时间长开销大 只能保证一个共享变量的原子操作 AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 AtomicInteger依赖于 Unsafe 提供的一些底层能力，实现了 CAS 的乐观锁。如果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// AtomicIntegerprivate static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();private static final long VALUE;static &#123; try &#123; VALUE = U.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); //用于返回类定义的某个属性在主存中设定的偏移量 &#125; catch (ReflectiveOperationException e) &#123; throw new Error(e); &#125;&#125;private volatile int value; //使用 volatile 保证可见性public AtomicInteger(int initialValue) &#123; value = initialValue;&#125;//原子性的加法运算，依赖 Unsafe 类public final int addAndGet(int delta) &#123; return U.getAndAddInt(this, VALUE, delta) + delta;&#125;// Unsafepublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); //通过对象引用地址和 value 值的偏移量，获取 value 的值 &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;// natUnsafe.cc 底层实现jbooleansun::misc::Unsafe::compareAndSwapInt (jobject obj, jlong offset, jint expect, jint update)&#123; jint *addr = (jint *)((char *)obj + offset); return compareAndSwap (addr, expect, update);&#125;static inline boolcompareAndSwap (volatile jint *addr, jint old, jint new_val)&#123; jboolean result = false; spinlock lock; if ((result = (*addr == old))) //如果值不相等就什么也不做，返回 false *addr = new_val; return result;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析 Binder 机制]]></title>
    <url>%2F2019%2F03%2F15%2F%E6%B5%85%E6%9E%90-Binder-%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[几个概念 进程隔离 进程隔离，不同进程之间，不共享内存。而操作系统是多进程的，因此需要 IPC。 进程空间划分 Kernel 是操作系统的核心，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。因此把 Kernel 和上层的应用程序隔离，分为内核空间和用户空间。 Android 利用了 Linux 的动态可加载内核模块机制，使 Binder 驱动运行在内核空间，负责各个用户进程通信。 Binder 通信模型：C/S 模型通信过程： Server 向 ServiceManager 也是通过发送 Binder 消息注册。ServiceManager 是比较特殊的服务，所有应用都能直接使用，因为ServiceManager对于Client端来说Handle句柄是固定的，都是0，所以ServiceManager服务并不需要查询，可以直接使用。 client 通过 ServiceManager 获得一个 server 的 Binder 实体的代理，对 server 进行调用。代理接口中定义的方法与 server 中定义的方法时一一对应的。 client 调用某个代理接口中的方法时，代理接口的方法会将 client 传递的参数打包成 Parcel 对象。client 线程挂起。 代理接口将 Parcel 发送给内核中的 binder 驱动。驱动通过一系列调用，将请求派发给 server 的 Binder 本地对象的 onTransact 方法。 onTransact 方法解包 Parcel 对象，处理并将结果返回给 binder 驱动，驱动唤醒 client 线程，并将结果返回。 Android APP进程都是由Zygote进程孵化出来的。常见场景：点击桌面icon启动APP，或者startActivity启动一个新进程里面的Activity，最终都会由AMS去调用Process.start()方法去向Zygote进程发送请求，让Zygote去fork一个新进程，Zygote收到请求后会调用Zygote.forkAndSpecialize()来fork出新进程,之后会通过RuntimeInit.nativeZygoteInit来初始化Andriod APP运行需要的一些环境，而binder线程就是在这个时候新建启动的。 IPC 是一个概念，Binder 是一种 IPC 的具体实现；AIDL 是 Binder 机制向外提供的接口，目的就是为了方便对 Binder 的使用； Android 系统匿名共享内存 Ashmem，其作用之一即通过 Binder 进程间通信机制来实现进程间的内存共享。 Client 进程只不过是持有了 Server端的代理；代理对象协助驱动完成了跨进程通信。 对 Server 来说，Binder 就是 Binder 本地对象，对 Client 来说, Binder 是 Binder 本地对象的代理。在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册。 我们所持有的Binder引用(即服务端的类引用)并不是实际真实的远程Binder对象，我们的引用在Binder驱动里还要做一次映射。客户端要调用远程对象函数时，只需把数据写入到Parcel，在调用所持有的Binder引用的transact()函数，transact函数执行过程中会把参数、标识符（标记远程对象及其函数）等数据放入到Client的共享内存，Binder驱动从Client的共享内存中读取数据，根据这些数据找到对应的远程进程的共享内存，把数据拷贝到远程进程的共享内存中，并通知远程进程执行onTransact()函数。远程进程Binder对象执行完成后，将结果写入自己的共享内存中，Binder驱动再将远程进程的共享内存数据拷贝到客户端的共享内存，并唤醒客户端线程。 整个的调用过程是一个同步过程，在server处理的时候，client会block住。因此client调用过程不应在主线程。 区别于传统的 IPC 的两次拷贝， Binder 机制使用内存映射。 Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。只需要一次拷贝（用户内核到服务内核的拷贝）内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。 实现过程Client 连接 Server 时，需要创建一个 ServiceConnection 作为入参，ServiceConnection 的回调方法 onServiceConnected 中会通过 asInterface(IBinder binder) 拿到 IBinder 对象，如果 Client 和 Server 在同一个进出，binder 就是 Binder 本地对象，否则是一个代理对象。 参考写给 Android 应用工程师的 Binder 原理剖析 简单理解Binder机制的原理 https://blog.csdn.net/china0851/article/details/87945740 Binder系列5—注册服务(addService) 听说你Binder机制学的不错，来解决下这几个问题（一） 写给 Android 应用工程师的 Binder 原理剖析]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 焦点分发机制梳理]]></title>
    <url>%2F2019%2F03%2F13%2FAndroid-%E7%84%A6%E7%82%B9%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRootImpl连接 DecorView， Window DecorView -&gt; Activity -&gt; PhoneWindow -&gt; DecorView 的来回绕一圈。 既然触摸事件已经到了 Activity.dispatchTouchEvent() 中了，为什么不直接分发给 DecorView ，而是要通过PhoneWindow 来间接发送呢？因为 Activity 不知道有 DecorView 这种奇怪的东西存在啊！不知道！但是，Activity 持有 PhoneWindow ，而 PhoneWindow 当然知道自己的窗口里有些什么了，所以能够把事件派发给DecorView 。你看，在 Android 中，Activity 并不知道自己的 Window 中有些什么，这样耦合性就很低了。 1234567891011//Activitypublic boolean dispatchTouchEvent(MotionEvent ev) &#123; ... if (getWindow().superDispatchTouchEvent(ev)) &#123; //又把事件传到了Window中！ return true; &#125; return onTouchEvent(ev); //这就是为什么最后事件没有被消费的话，Activity会去处理的原因。&#125; InputStage 策略在 RootViewImpl 中的函数通道是各种策略（InputStage）的组合，各策略负责的任务不同，如SyntheticInputStage、ViewPostImeInputStage、NativePostImeInputStage 等等，这些策略以链表结构结构起来，当一个策略者没有消费事件时，就传递个下一个策略者。其中触摸和按键事件由 ViewPostImeInputStage 处理。 ViewPostImeInputStage 是 ViewRootImpl 的内部类， 分发 KeyEvent ViewPostImeInputStage -&gt; onProcess (KeyEvent) -&gt; processKeyEvent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private int processKeyEvent(QueuedInputEvent q) &#123; ... // Deliver the key to the view hierarchy. // mView 即 DecorView if (mView.dispatchKeyEvent(event)) &#123; return FINISH_HANDLED; &#125; ... // Handle automatic focus changes. if (performFocusNavigation(event)) &#123; return FINISH_HANDLED; &#125;&#125;private boolean performFocusNavigation(KeyEvent event) &#123; int direction = 0; switch (event.getKeyCode()) &#123; case KeyEvent.KEYCODE_DPAD_LEFT: if (event.hasNoModifiers()) &#123; direction = View.FOCUS_LEFT; &#125; break; case KeyEvent.KEYCODE_DPAD_RIGHT: if (event.hasNoModifiers()) &#123; direction = View.FOCUS_RIGHT; &#125; break; case KeyEvent.KEYCODE_DPAD_UP: if (event.hasNoModifiers()) &#123; direction = View.FOCUS_UP; &#125; break; case KeyEvent.KEYCODE_DPAD_DOWN: if (event.hasNoModifiers()) &#123; direction = View.FOCUS_DOWN; &#125; break; case KeyEvent.KEYCODE_TAB: if (event.hasNoModifiers()) &#123; direction = View.FOCUS_FORWARD; &#125; else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123; direction = View.FOCUS_BACKWARD; &#125; break; &#125; if (direction != 0) &#123; View focused = mView.findFocus(); if (focused != null) &#123; View v = focused.focusSearch(direction); if (v != null &amp;&amp; v != focused) &#123; // do the math the get the interesting rect // of previous focused into the coord system of // newly focused view focused.getFocusedRect(mTempRect); if (mView instanceof ViewGroup) &#123; ((ViewGroup) mView).offsetDescendantRectToMyCoords( focused, mTempRect); ((ViewGroup) mView).offsetRectIntoDescendantCoords( v, mTempRect); &#125; if (v.requestFocus(direction, mTempRect)) &#123; playSoundEffect(SoundEffectConstants .getContantForFocusDirection(direction)); return true; &#125; &#125; // Give the focused view a last chance to handle the dpad key. if (mView.dispatchUnhandledMove(focused, direction)) &#123; return true; &#125; &#125; else &#123; if (mView.restoreDefaultFocus()) &#123; return true; &#125; &#125; &#125;&#125; DecorView -&gt; dispatchKeyEvent 12345@Overridepublic boolean dispatchKeyEvent(KeyEvent event) &#123; // Let the focused view and/or our descendants get the key first return super.dispatchKeyEvent(event) || executeKeyEvent(event);&#125; ViewGroup -&gt; dispatchKeyEvent 12345678910111213141516@Overridepublic boolean dispatchKeyEvent(KeyEvent event) &#123; ... if ((mPrivateFlags &amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) &#123; if (super.dispatchKeyEvent(event)) &#123; return true; &#125; &#125; else if (mFocused != null &amp;&amp; (mFocused.mPrivateFlags &amp; PFLAG_HAS_BOUNDS) == PFLAG_HAS_BOUNDS) &#123; if (mFocused.dispatchKeyEvent(event)) &#123; return true; &#125; &#125; ...&#125; 如果父类（View）处理了（return true），则不往下传。或者 mFocused 不为空，先 mFocused 分发，如果 mFocused 没有处理（返回 true），则 DecorView 最终返回 false，交由 ViewRoomImpl 继续处理。 View -&gt; dispatchKeyEvent 123456789public boolean dispatchKeyEvent(KeyEvent event) &#123; ... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnKeyListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) &#123; return true; &#125; ...&#125; 这里可以看出，要拦截焦点分发，可以： 设置 OnKeyListener 监听 重写 dispatchKeyEvent 方法并返回 true mView 分发焦点之后没有被处理，会先根据 KeyCode 为 direction 赋值，用于后续的寻找焦点。View focused = mView.findFocus() 会一层一层往下直到返回当前持有焦点的 View，如果 DecorView 的子 view 持有焦点（focused），则调用 focused 的 focusSearch 方法寻找下一个焦点。 12345678910111213141516171819202122//ViewGroup@Overridepublic View focusSearch(View focused, int direction) &#123; if (isRootNamespace()) &#123; // root namespace means we should consider ourselves the top of the // tree for focus searching; otherwise we could be focus searching // into other tabs. see LocalActivityManager and TabHost for more info. return FocusFinder.getInstance().findNextFocus(this, focused, direction); &#125; else if (mParent != null) &#123; return mParent.focusSearch(focused, direction); &#125; return null;&#125;//Viewpublic View focusSearch(@FocusRealDirection int direction) &#123; if (mParent != null) &#123; return mParent.focusSearch(this, direction); &#125; else &#123; return null; &#125;&#125; 可以看到 focusSearch 方法最终调用 FocusFinder.getInstance().findNextFocus(this, focused, direction) 来寻找下一个获取焦点的 View。FocusFinder 会优先通过 View 在 XML 布局设置的下一个焦点的 ID 来查找焦点。 参考点击事件 InputStage Android 焦点事件分发与传递机制 焦点 inputStage 相关]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 启动模式]]></title>
    <url>%2F2019%2F03%2F13%2FAndroid-%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[相关的概念 ActivityStack 应用程序在一个单例的 ActivityStack 中，一个 ActivityStack 可能包含了多个 task TaskRecord 一个进程（程序）有一个默认的task affinity，默认为包名 Activity 会进入启动它的 Activity 所在的 Task 栈中 app 的切换实质上就是 task 栈的切换 ActivityRecord 包含了一个Activity的所有信息，例如所在 task、所在进程的信息 ProcessRecord 等 ProcessRecord 当前运行的进程信息 四种启动模式 standard Activity 会重新创建一个新的实例，不论原有实例是否存在。 singleTop 栈顶复用，要创建的 Activity 已经处于栈顶时，此时会直接复用栈顶的 Activity，不调用 onCreate、onStart，回调 onNewIntent 与使用 Intent.FLAG_ACTIVITY_SINGLE_TOP 等价 场景：消息推送界面。防止重复推送，多次打开某个页面 singleTask 要创建的 Activity 已经处于栈中时，此时不会创建新的 Activity，而是将存在栈中的 Activity 上面的其他 Activity 所有销毁，使它成为栈顶 与使用 Intent.FLAG_ACTIVITY_CLEAR_TOP 等价 场景：主页 singleInstance 会复用已有的 activity，且栈中只有一个 activity 场景：呼叫来电界面 FLAGFLAG_ACTIVITY_NEW_TASKFLAG_ACTIVITY_NEW_TASK 会先判断 activity 的 taskAffinity 指定的 task 是否已存在，如果已存在则不会新建 task，不存在则新建 task。如果配合 FLAG_ACTIVITY_MULTIPLE_TASK 一起使用，则不搜索是否已有 task，都会新建新的 task。 在 Service 中或使用 applicationContext 启动 Activity 必须要有该 flag。 FLAG_ACTIVITY_MULTIPLE_TASK(FLAG_ACTIVITY_MULTIPLE_TASK)[https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_MULTIPLE_TASK] This flag is used to create a new task and launch an activity into it. This flag is always paired with either FLAG_ACTIVITY_NEW_DOCUMENT or FLAG_ACTIVITY_NEW_TASK. In both cases these flags alone would search through existing tasks for ones matching this Intent. Only if no such task is found would a new task be created. When paired with FLAG_ACTIVITY_MULTIPLE_TASK both of these behaviors are modified to skip the search for a matching task and unconditionally start a new task. 举个栗子： KotlinActivity 中只是用 FLAG_ACTIVITY_NEW_TASK 启动 activity，两个 activity 会在同一个 task 中。如果使用 FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK 启动 Main2Activity。两个 activity 会在不同的 task 中，但是 taskAffinity 是一样的，没指定默认是包名。 在 Service 中启动结果是一样的。 123456789101112131415newTask+mutable 后，task 是什么样Task id #771TaskRecord&#123;750276f #771 A=com.andy.demo U=0 sz=1&#125;Intent &#123; flg=0x18000000 cmp=com.andy.demo/.Main2Activity &#125;Hist #0: ActivityRecord&#123;c6870ec u0 com.andy.demo/.Main2Activity t771&#125;Intent &#123; flg=0x18000000 cmp=com.andy.demo/.Main2Activity &#125;ProcessRecord&#123;c9f9567 32573:com.andy.demo/u0a251&#125;Task id #770TaskRecord&#123;4222f14 #770 A=com.andy.demo U=0 sz=1&#125;Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.andy.demo/.KotlinActivity &#125;Hist #0: ActivityRecord&#123;447e0c4 u0 com.andy.demo/.KotlinActivity t770&#125;Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.andy.demo/.KotlinActivity &#125;ProcessRecord&#123;c9f9567 32573:com.andy.demo/u0a251&#125; 附 adb 命令adb shell dumpsys activity activities 获取运行的 activity]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 类加载机制]]></title>
    <url>%2F2019%2F03%2F02%2FJava-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[类的生命周期 JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化 加载这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。 验证确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备正式为类变量分配内存并设置类变量初始值 解析虚拟机将常量池内的符号引用替换为直接引用。（虚拟机将运行时常量池中那些仅代表其他信息的符号引用（例如字节码中的 #1，#2 等）解析为直接指向所需信息所在地址的指针。） 初始化执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。 类加载器类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节码（.class 文件）。类加载器负责读取 Java 字节码，并转换成 java.lang.Class 类的一个实例。 关于类加载器需要了解： 类加载器的命名空间对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。也就是说，你现在要比较两个类是否相等，只有在这两个类是同一个类加载器加载的前提下才有意义。 双亲委派模型JVM中有三种系统提供的类加载器：启动类加载器，扩展类加载器、应用程序类加载器。某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 该机制最大的好处就是让 Java 类同其类加载器一起具备了一种带优先级的层次关系。这句话可能不好理解，我们举个例子。比如我们要加载顶层的 Java 类——java.lang.Object 类，无论我们用哪个类加载器去加载 Object 类，这个加载请求最终都会委托给 Bootstrap ClassLoader，这样就保证了所有加载器加载的 Object 类都是同一个类]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从字节码层面理解泛型]]></title>
    <url>%2F2019%2F02%2F12%2F%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[命令行12345//编译成 class 文件javac Test.java //反汇编 class 文件javap -V Test.class Android Studio 编译的 class文件位于 build/intermediates/clases/debug/包名 下 IDEA 插件 jclasslib Bytecode viewer ASM Bytecode Viewer 这两款插件都可以在 Android Studio Plugins 里直接下载安装 字节码的组成方法调用在JVM中转换成的是字节码执行，字节码指令执行的数据结构就是栈帧。 栈帧的数据结构主要分为四个部分：局部变量表、操作数栈、动态链接以及方法返回地址（包括正常调用和异常调用的完成结果）。 局部变量表（local variables）当方法被调用时，参数会传递到从0开始的连续的局部变量表的索引位置上。local variables的最大长度是在编译期间决定的。一个局部变量表的占用了32位的存储空间（一个存储单位称之为slot，槽），所以可以存储一个boolean、byte、char、short、float、int、refrence和returnAdress数据，long和double需要2个连续的局部变量表来保存，通过较小位置的索引来获取。如果被调用的是实例方法，那么第0个位置存储“this”关键字代表当前实例对象的引用。 操作数栈操作数栈同局部变量表一样，也是编译期间就能决定了其存储空间（最大的单位长度）。 操作数栈是在JVM字节码执行一些指令（第二部分会介绍一些指令集）时创建的，主要是把局部变量表中的变量压入操作数栈，在操作数栈中进行字节码指令的操作，再将变量出操作数栈，结果入操作数栈。 动态链接每个栈帧指向运行时常量池中该栈帧所属的方法的引用，也就是字节码的发放调用的引用。动态链接就是将符号引用所表示的方法，转换成方法的直接引用。加载阶段或第一次使用时转化为直接引用的（将变量的访问转化为访问这些变量的存储结构所在的运行时内存位置）就叫做静态解析。JVM的动态链接还支持运行期转化为直接引用。也可以叫做Late Binding,晚期绑定。 方法返回地址方法正常退出会把返回值压入调用者的栈帧的操作数栈，PC计数器的值就会调整到方法调用指令后面的一条指令。这样使得当前的栈帧能够和调用者连接起来，并且让调用者的栈帧的操作数栈继续往下执行。 方法的异常调用完成，主要是JVM抛出的异常，如果异常没有被捕获住，或者遇到athrow字节码指令显示抛出，那么就没有返回值给调用者。 Java 代码：1234567public class MyTest &#123; private int myNum = 20; public void func() &#123; myNum = 50; &#125;&#125; 编译后的 class 源文件：12345678910111213141516171819202122232425cafe babe 0000 0033 0015 0a00 0400 11090003 0012 0700 1307 0014 0100 056d 794e756d 0100 0149 0100 063c 696e 6974 3e010003 2829 5601 0004 436f 6465 0100 0f4c696e 654e 756d 6265 7254 6162 6c65 0100124c 6f63 616c 5661 7269 6162 6c65 5461626c 6501 0004 7468 6973 0100 1a4c 636f6d2f 7961 7a68 6964 6576 2f64 656d 6f2f4d79 5465 7374 3b01 0004 6675 6e63 01000a53 6f75 7263 6546 696c 6501 000b 4d795465 7374 2e6a 6176 610c 0007 0008 0c000500 0601 0018 636f 6d2f 7961 7a68 69646576 2f64 656d 6f2f 4d79 5465 7374 0100106a 6176 612f 6c61 6e67 2f4f 626a 65637400 2100 0300 0400 0000 0100 0200 05000600 0000 0200 0100 0700 0800 0100 09000000 3900 0200 0100 0000 0b2a b700 012a1014 b500 02b1 0000 0002 000a 0000 000a0002 0000 0007 0004 0008 000b 0000 000c0001 0000 000b 000c 000d 0000 0001 000e0008 0001 0009 0000 0035 0002 0001 00000007 2a10 32b5 0002 b100 0000 0200 0a000000 0a00 0200 0000 0b00 0600 0c00 0b000000 0c00 0100 0000 0700 0c00 0d00 00000100 0f00 0000 0200 10 javap 反汇编后的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Classfile /Users/zengyazhi/Documents/zyzdev/AndroidDemo/app/build/intermediates/classes/debug/com/yazhidev/demo/MyTest.class Last modified 2018-12-28; size 393 bytes MD5 checksum 2872209fbe3efb46c70b23bf85be75fd Compiled from &quot;MyTest.java&quot;public class com.yazhidev.demo.MyTest minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#17 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#18 // com/yazhidev/demo/MyTest.myNum:I #3 = Class #19 // com/yazhidev/demo/MyTest #4 = Class #20 // java/lang/Object #5 = Utf8 myNum #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/yazhidev/demo/MyTest; #14 = Utf8 func #15 = Utf8 SourceFile #16 = Utf8 MyTest.java #17 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #18 = NameAndType #5:#6 // myNum:I #19 = Utf8 com/yazhidev/demo/MyTest #20 = Utf8 java/lang/Object&#123; public com.yazhidev.demo.MyTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: bipush 20 7: putfield #2 // Field myNum:I 10: return LineNumberTable: line 7: 0 line 8: 4 LocalVariableTable: Start Length Slot Name Signature 0 11 0 this Lcom/yazhidev/demo/MyTest; public void func(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: bipush 50 3: putfield #2 // Field myNum:I 6: return LineNumberTable: line 11: 0 line 12: 6 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/yazhidev/demo/MyTest;&#125;SourceFile: &quot;MyTest.java&quot; 操作码opcode（指令） = 操作码 + 操作数 例如 bipush 10 这是一条指令，是由操作码 bipush 后跟一个操作数 10 组成，该指令的作用是将整型数 10 压到操作数栈中。 aload_0（指令码：0x2a） 从局部变量数组中加载一个对象引用到操作数栈的栈顶，最后的数字对应的是局部变量数组中的位置，只能是0，1，2，3。（第一个局部变量是this引用） invokespecial（0xb7） 只能调用三类方法：方法；私有方法；super.method()。因为这三类方法的调用对象在编译时就可以确定 invokevirtual（0xb6） 是一种动态分派的调用指令 bipush（0x10） 用来把一个字节作为整型压到操作数栈中 putfield（0xb5） 后面跟一个操作数（该操作数引用的是运行时常量池里的一个字段，在这里这个字段是 myNum），将栈顶的值赋给这个。赋给这个字段的值，以及包含这个字段的对象引用，在执行这条指令的时候，都会从操作数栈顶上 pop 出来 ldc（0x12） 常量池中的常量值入栈 CHECKCAST（0xc0） 类型强转 部分字节码指令集可见： 《Java二进制指令代码解析》 《JVM 虚拟机字节码指令表》 解析回到上面 MyTest 的构造函数里： 1234560: aload_01: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V4: aload_05: bipush 207: putfield #2 // Field myNum:I10: return ASM Bytecode viewer 显示的字节码为:1234567891011121314151617181920212223242526272829303132333435363738394041// class version 51.0 (51)// access flags 0x21public class com/yazhidev/demo/MyTest &#123; // compiled from: MyTest.java // access flags 0x2 private I myNum // access flags 0x1 public &lt;init&gt;()V L0 LINENUMBER 7 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V L1 LINENUMBER 8 L1 ALOAD 0 BIPUSH 20 PUTFIELD com/yazhidev/demo/MyTest.myNum : I RETURN L2 LOCALVARIABLE this Lcom/yazhidev/demo/MyTest; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x1 public func()V L0 LINENUMBER 11 L0 ALOAD 0 BIPUSH 50 PUTFIELD com/yazhidev/demo/MyTest.myNum : I L1 LINENUMBER 12 L1 RETURN L2 LOCALVARIABLE this Lcom/yazhidev/demo/MyTest; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1&#125; 从字节码看泛型Java 的泛型是完全在编译器中实现的，由编译器执行类型检查和类型推断，然后生成普通的非泛型的字节码，虚拟机完全不感知泛型的存在。编译器使用泛型类型信息保证类型安全，然后在生成字节码之前将其清除。 Java 代码： 123456789101112public class Generic&lt;T&gt; &#123; private T data; public T get() &#123; return data; &#125; public void set(T data) &#123; this.data = data; &#125;&#125; 从生成的字节码中可以看到，泛型 T 已经被擦除了： 12345private Ljava/lang/Object; datapublic getData()Ljava/lang/Object;public setData(Ljava/lang/Object;)V 类型擦除与多态冲突的问题子类 B，指定了泛型类型： 123456789101112public class B extends Generic&lt;Number&gt; &#123; private Number n; public Number get() &#123; return n; &#125; public void set(Number n) &#123; this.n = n; &#125;&#125; 子类 C，未指定泛型类型： 123456789101112public class C extends Generic &#123; private Number n; public Number get() &#123; return n; &#125; public void set(Number n) &#123; this.n = n; &#125;&#125; 我们在写 B 类时，指定了泛型类型为 Number，对于 B 类的方法 get()Number 和 set(Number)，我们的本意应该是对父类的 get()T 和 set(T) 方法进行重写。但上面我们知道了，父类的 get()T 和 set(T) 在字节码中实际上是 get()Object 和 set(Object)，与类 B 的方法 set(Number) 方法参数不一样，理论上应该算重载而不是重写。为了解决这一冲突，JVM 采用了一种特殊的方法：桥接。 我们先看 B 类的字节码： 12345678910111213141516171819202122232425262728public get()Ljava/lang/Number;public set(Ljava/lang/Number;)V// access flags 0x1041public synthetic bridge set(Ljava/lang/Object;)V L0 LINENUMBER 7 L0 ALOAD 0 ALOAD 1 CHECKCAST java/lang/Number INVOKEVIRTUAL com/yazhidev/demo/B.set (Ljava/lang/Number;)V RETURN L1 LOCALVARIABLE this Lcom/yazhidev/demo/B; L0 L1 0 MAXSTACK = 2 MAXLOCALS = 2// access flags 0x1041public synthetic bridge get()Ljava/lang/Object; L0 LINENUMBER 7 L0 ALOAD 0 INVOKEVIRTUAL com/yazhidev/demo/B.get ()Ljava/lang/Number; ARETURN L1 LOCALVARIABLE this Lcom/yazhidev/demo/B; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 可以发现编译器自动生成了 set(Object) 和 get()Object 两个桥接方法来重写父类方法，同时这两个桥接方法实际上调用了对应的 set(Number) 方法和 get()Number 方法。虚拟机通过使用桥接方法，来解决了类型擦除和多态的冲突。对于开发者来说，对于指定了泛型类型为 Number 的 B 类来说，其 set(Number) 方法就是对父类方法 set(T) 的重写，同理 get()Number 也是对父类方法 get()T 的重写。 但 C 类则有些不同，C 类未指定泛型类型，所以父类中的方法为 get()Object 和 set(Object)，C 类中的 set(Number) 与父类 set(Object) 方法参数不同，理所当然是重载，我们都知道，只有返回值不同不满足重载条件，所以对 C 类的 get()Number 方法来说，应该算是对父类方法 get()T 的重写。 我们来看 C 类的字节码： 1234567891011121314public get()Ljava/lang/String;public set(Ljava/lang/String;)V// access flags 0x1041public synthetic bridge get()Ljava/lang/Object; L0 LINENUMBER 7 L0 ALOAD 0 INVOKEVIRTUAL com/yazhidev/demo/C.get ()Ljava/lang/String; ARETURN L1 LOCALVARIABLE this Lcom/yazhidev/demo/C; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 可以发现编译期自动生成了 get()Object 桥接方法来重写父类方法。但我们发现字节码里却同时存在了两个只有返回值类型不同的同名方法，这是为什么呢？ 这里就需要提到方法特征签名，只有特征签名不同的方法才可以共存。 Java 层方法签名 = 方法名 + 参数类型 + 参数顺序 所以在 Java 语言里，重载一个方法需要两个同名方法的参数类型不同，或者参数顺序不同，只有返回值类型不同是无法通过编译的。 JVM 层方法签名 = 方法名 + 参数类型 + 参数顺序 + 返回值类型 + 可能抛出的异常 所以在 class 文件里，是可以存在两个只有返回值类型不同的同名方法。也就是上面的 get()Object 和 get()Number 参考《描述符与特征签名的区别》]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《C++ 程序设计》读书笔记]]></title>
    <url>%2F2018%2F12%2F16%2F%E3%80%8AC-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文联合编辑：小辣辣。向她致以最崇高的敬（爱）意 ❤ 第一章 C++的初步认识在程序进行编译时，先对所有的预处理命令进行处理，将头文件的具体内容代替 #include 指令，然后再对该程序单元进行整体编译。 对函数做声明，它的作用是通知 C++ 编译系统。 第二章 数据的存储、表示形式和基本运算C++ 没有规定每一种数据所占的字节数，只规定 int 型数据所占的字节数不大于 long 型，不小于 short 型。 符号常量1#define PRICE 30 符号常量虽有名字，但它不是变量。在进行编译预处理时，所有的 PRICE 都被置换为字符 30，在正式进行编译时已经没有 PRICE 这个标识符了。但 C++ 程序员一般更喜欢用 const 定义常变量。 运算符 / 除法运算符结果是整数，如果有一个是负数，则舍入方向是不固定的。多数编译系统采取向零取整的方法 % 模运算符两侧均应为整型数据，如 7%4 的值为 3 +，–，*，/ 运算中的两个数中有一个数为 float 型数据，则运算结果是 double 型，因为 C++ 在运算时对所有 float 型数据都按 double 型数据处理。 进行运算时，不同类型的数据都要先转换成同一类型，然后进行运算。 自增（减）运算符也用于指针变量，使指针指向下一个地址。 赋值运算符和赋值表达式赋值过程中的类型转换将浮点型数据赋值给整型变量时，舍弃其小数部分。 不同类型的整型数据间的赋值归根到底就是一条：按存储单元中的存储形式直接传送。 程序初步设计关系运算和逻辑运算运算符优先级： 算数运算符 ＞ 关系运算符 ＞赋值运算符 在 C 和 C++ 中都用数据 1 代表真，0 代表假。编译系统在处理逻辑型数据时，将 false 处理为 0，将 true 处理为 0。逻辑变量在内存中占 1 个字节，用来存放 0 或 1。 用 for 语句构成循环for（表达式1；表达式2；表达式3）语句 表达式 1 可以省略，但其后得分号不可省略。 如果表达式 2 省略，即不判断循环条件，循环无休止地进行下去。 第四章 利用函数实现指定的功能函数参数和函数的值在调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放，实参单元仍保留并维持原值。因此，在执行一个被调用函数时，形参的值如果发生改变，并不会改变主调用函数中实参的值。 对被调用函数的声明和函数原型在函数声明中可以不写形参名，只写形参类型 内置函数（内联函数）转去被调用函数前，要记下当时执行的指令的地址，还要记下当时有关的信息，以便在函数调用后继续执行，如果有的函数需要频繁使用，则所用时间会很长，从而降低执行效率。可以使用内置函数将所调用的函数的代码直接嵌入到主调函数中，而不是将流程转出去。使用关键字 inline。 函数模板1template &lt; typename T &gt; //类似 Java 的泛型 有默认参数的函数注意点：如果函数的定义在函数调用之前，则应在函数定义中给出默认值。如果函数的定义在函数调用之后，则在函数调用之前需要有函数声明，此时必须许多函数声明中给出默认值，函数定义时可以不给出默认值。 变量的存储类型 auto（默认） 自动变量，动态局部变量，函数调用结束后释放 static 静态局部变量在静态存储区内分配存储单元，在程序整个运行期间都不释放。 加上 static 声明，则该变量只能用于本文件 register 寄存器变量，如果有一些变量使用频繁，则为存取变量的值要花不少时间，为提高效率，C++ 允许将局部变量的值放在 cpu 的寄存器中 extern 全局变量（外部变量），作用域从变量的定义开始，到本程序文件的末尾 注意 extern 是用作变量声明，而不是变量定义。它只是对一个已定义的外部变量做声明，以扩展其作用域。 内部函数和外部函数外部函数如果在函数的首部的最左端冠以关键字 extern，则表示此函数是外部函数，可供其他文件调用。 第五章 利用数组处理批量数据一维数组的初始化 可以只给一部分元素赋值（后面的元素默认为 0） 对全部数组元素赋初值时，可以不指定数组长度 二维数组的初始化 可以对部分元素赋值 用数组作函数参数数组名作实参和形参，传递的是数组的起始地址。 数组名代表数组首元素的地址。 用数组名作实参，如果改变了形参数组元素的值将同时改变实参数组元素的值。 字符数组定义和初始化字符数组如果提供的初值个数大于数组长度，则按语法错误处理。如果小于数组长度，则只将字符赋值给数组中前面的元素，其余的元素自动定义为空字符 \0 字符数组的赋值和引用只能对字符数组的元素赋值，而不能用赋值语句对整个数组赋值。 结束标志遇到字符 \0 就表示字符串到此结束。对于一个字符串常量，系统会自动在所在字符的后面加一个 \0 作为结束符，然后再把它存在字符数组中。 可以用字符串常量来初始化字符数组。 字符数组的输入和输出 输出得字符不包含结束符 \0 字符串处理函数比较函数 strcmp 1strcmp（str1，str2） 对两个字符串自左至右逐个字符相比(按 ASCII 值大小比较) 两个字符串比较，不能用以下形式： 123if(str1 ＞ str2) &#123; ...&#125; 上面写法表示将两个数组的地址进行比较。 字符串变量的定义和引用和其他类型变量一样，字符串变量必须先定义后使用。 第六章 善于使用指针和引用i_pointer 是一个指针变量，* i_pointer 表示 i_pointer 所指向的变量。* 不是指针变量名的一部分，在变量名前加一个 * 表示该变量是指针变量。 不能用一个整数给指针变量赋值。 1int * pointer = 2000; 编译系统并不把 2000 认为是地址，而认为是整数。可以将一个已定义的变量的地址作为指针变量的初值。 一个指针只能指向同一个类型的变量。 引用指针变量&amp; ： 取地址运算符 &amp;a 为变量 a 的地址， *p 为指针变量 p 所指向的存储单元 1int * pointer = &amp; a //定义指针变量 pointer：指针变量 * pointer 等效于 a（对指针变量 pointer 做 * 运算，指向 pointer 指向的存储单元，即 a） &amp; 和 * 两个运算符的优先级别相同，但按自右而左方向结合。例如已知 pointer = &amp;a，&amp; * pointer的含义是：先进行 *pointer 的运算，它就是变量 a，再执行 &amp; 运算，因此 &amp; * pointer 与 &amp; a 相同，即变量 a 的地址。 用指针作函数参数1234567891011121314int main() &#123; void swap(int * p1, int * p2) int * pointer_1, * pointer_2, a, b; cin &gt;&gt; a &gt;&gt; b; pointer_1 = &amp;a; pointer_2 = &amp;b; swap(pointer_1, pointer_2)&#125;void swap(int * p1, int * p2) &#123; //定义指针变量 p1, p2，即 swap 的形参须是指针 int temp; temp = * p1; // * p1：对指针变量做 * 运算，指向值 ...&#125; 不能试图通过改变形参指针变量的值而使实参指针变量的值改变。实参和形参之间的数据传递是单向的“值传递”的方式，指针变量作函数参数也要遵循这一规则，调用函数时不会改变实参指针变量的值，但可以改变实参指针变量指向变量的值。 1234567891011121314151617181920212223242526272829303132333435363738int main(int argc, char* argv[]) &#123; void myswap(int * p1, int * p2); int * point1, * point2, a, b; a = 10, b = 20; point1 = &amp;a; point2 = &amp;b; cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl; if(a &lt; b) myswap(point1, point2); cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl; if(a &lt; b) realswap(point1, point2); cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl; return 0;&#125;//指针变量也是值传递，形参修改并不影响实参 point1 指针void myswap(int * p1, int * p2) &#123; int * temp; temp = p1; p1 = p2; p2 = temp;&#125;void realswap(int * p1, int * p2) &#123; int temp; temp = * p1; * p1 = * p2; //* p1，直接修改 p1 指向的值（a）的值 * p2 = temp;&#125;//输出 a10b20a10b20a20b10//分析point1 = &amp; a* point1 即 point1 所指向的变量 数组和指针指向数组元素的指针123int a[10]; //定义一个数组，有 10 个元素int *p;p = &amp;a[0] //将元素 a[0] 的地址赋给指针变量 p，使 p 指向 a[0] 在 C++ 中，数组名代表数组中的第 1 个元素（即序号为 0 的元素）的地址，因此以下语句等价： 12p = &amp;a[0];p = a; 数组名 a 不代表整个数组，p=a 的作用是把 a 数组的首元素的地址赋给指针变量 p。 如果指针变量 p 已指向数组中的一个元素，则 p + 1 指向同一个数组中的下一个元素。 如果 p 的初值为 &amp;a[0]，那么 p + i 和 a + i 就是 a[i] 的地址。 123*(p+5)*(a+5)a[5] 这三种表示方法等价。 可以看出，数组名后面的括号 []，实际上是变址运算符，指向数组元素的指针变量也可以带下标，如 p[i] 与 *(p+i) 等价。 效率比较： 下标法：a[i] 123456int a[10];int i;for(i = 0; i &lt; 10; i++)&#123; cout&lt;&lt;a[i]&lt;&lt;endl;&#125; 指针法：*(a + i) 123456int a[10];int i;for(i = 0; i &lt; 10; i++)&#123; cout&lt;&lt;*(a + i)&lt;&lt;endl;&#125; 用指针变量指向数组元素 123456int a[10];int i;for(p = a; p &lt; (a + 10); p++)&#123; cout&lt;&lt;*p&lt;&lt;endl;&#125; 1 和 2 的执行效率相同，C++ 编译系统是将 a[i] 转换为 *(a + 1) 处理的，对每个 a[i] 都分别计算地址 a + i x d，然后访问该元素。3 比 1 和 2 快，用指针变量直接指向元素，不必每次都重新计算地址。 在使用指针变量指向数组元素是，应切实保证指向数组中有效的元素。 C++ 编译系统将形参数组名一律作为指针变量来处理。 函数与指针只须将函数名 max 赋给 p，不能写成 p ＝ max(a,b) 1int * a(int x, int y); a 是函数名，调用它以后m能得到一个指向整型数据的指针（地址）。 指针数组和指向指针的指针指针数组1int * p[4] 由于 [] 比 * 优先级高，因此 p 先与 [4] 结合，形成 p[4] 形式，这显然是数组形式。不要写成 int 这是指向一维数组的指针变量。 1* (name + i ++) 表示先求 * 的值，即 name 它是一个地址。将它赋给 p，然后 i 加 1，最后输出以 p 地址开始的字符串。 指向指针的指针由于 name[i] 的值是地址(即指针)，因此 name + i 就是指向指针型数据的指针。 12345678// 指针变量（比如变量 a 的地址）char * p // 存储 a 的地址的指针的地址char *(* p) * p = &apos;C++&apos;** p 指向 ‘C++’ 的第一个字符元素的内容 const 指针用指向常量的指针变量只是限制了通过指针变量改变它指向的对象的值。 const 类型名 * p （指向常量的指针变量） p 的指向可变，但 p 指向的对象的值不可变。 1234567int a = 12;int b = 15;const int * p = &amp; a;p = &amp;b; //合法，p 的指向可变* p = 20; //非法，p 指向的对象的值不可变a = 15; //合法，a 不是 const 常量 如果想绝对保证 a 的值始终不变，应当把 a 定义为常变量。 int * const p （常指针变量） 指针变量的指向不可变，但指向变量的值可变 123456int a = 12;int b = 15;int * const p = &amp; a;p = &amp;b; //非法，p 的指向不可变* p = 20; //合法，p 指向变量的值可变 const int a a 的值不可变 123const int a = 12;a = 20; //非法 void 指针类型该空间尚未使用，其中没有数据，谈不上指向什么类型的数据，故返回一个 void * 类型的指针，表示它不指向确定的具有类型的数据。 指针运算指针变量可以有空值，即该指针变量不指向任何变量，它可以这样表示： 12// iostream 头文件中已定义了符号常量 NULL 代表整数 0p = NULL; 如果两个指针不指向同一个数组，则比较是无意义的。如果一定要对不同类型的指针变量赋值，可以用到强制类型转换。 引用在数据类型名后面出现的 &amp; 是引用声明符号，在其他场合出现的都是地址符： 12char &amp;d = c; // 引用的声明符int * p = &amp; a; //地址符 在声明一个引用后，不能再使之作为另一变量的引用。 123int a1, a2;int &amp;b = a1;int &amp;b = a2; //非法 引用其实就是一个指针常量，它的指向不可改变。 引用作为函数参数传递变量的地址：形参是指针变量，实参是一个变量的地址。调用函数时，形参（指针变量）得到实参变量的地址，因此指向实参变量单元。 实参不是地址而是整型变量名，由于形参是引用，系统会自动将实参的地址传递给形参，注意：此时传送的是实参变量的地址而不是实参变量的值。实参是地址，传递的是地址，故仍然是值传递。方式（3）中实参是变量名，而传递的是变量的地址，这才是传址方式。 第七章 用户自定义数据类型引用结构体变量. 是成员运算符，它在所有运算符中优先级最高，因此可以把 student.num 作为一个整体来看待。 指向结构体变量的指针C 和 C++ 提供了指向结构体变量的运算符 -&gt;,形象的表示“指向”关系。例如，p-&gt;num 表示指针 p 当前指向的结构体变量中的成员 num。 p-&gt;n++ 得到p指向的结构体变量中的成 员 n的值，用完该值后使它加 1。 ++p-&gt;n 得到 p 指向的结构体变量中的成员 n 的值，并使之加 1，然后再使用它。 用结构体变量和指向结构体变量的指针构成链表用结构体变量和指向结构体变量的指针构成链表，最有一个元素不再指向其他元素，它成为“表尾”，它的地址部分放到一个“NULL”（表示“空地址”），链表到此结束。 所有节点（结构体变量）都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表成为静态链表。 动态链表则是指个结点是可以随时插入和删除的，这些节点并没有变量名，只能先找到一个结点上，才能根据它提供的下一个结点的地址找到下一个结点。 结构体类型数据最为函数参数调用函数时形参要单独开辟内存单元，如果结构体变量占的存储空间很大，则在虚实结合时控件和时间的开销都比较大，效率是不高的。 用 new 和 delete 运算符进行动态分配和撤销存储空间new 运算符使用的一般格式： 1new 类型 [初值] 注意：用 new 分配数组空间时不能指定初始值 delete 运算符使用的一般格式为： 123delete 指针变量或delete [] 指针变量 在指针变量前面加一对方括号，表示是对数组空间的操作。 枚举类型枚举元素按常量处理，故称枚举常量，它们不是常量，不能对它们赋值，即枚举元素的值是固定的。 第八章 类和对象的特性声明类类型如果在类的定义中既不指定 private，也不指定 public，则系统就默认为是私有的。 除了 private 和 public之外，还有一种成员访问限定符 protect（受保护的），用protect声明的成员不能被类外访问（这点与私有成员类似），但可以被派生类的成员函数访问。 成员函数的性质:: 是作用域限定符（field qualifier）或称作用域运算符，用它声明函数是属于哪个子类的。 函数名前既无类名又无作用域运算符，表示函数不属于任何类，这个函数不是成员函数，而是全局函数。 内置成员函数在类体中定义的成员函数的规模一般都很小，而系统调用函数的过程所花费的时间开销相对是比较大的，为减少时间的开销，如果在类体中定义的成员函数中不包括循环等控制结构，C++ 系统就自动把它们作为内置（inline）函数来处理。 成员函数的存储方式每个对象所占用的存储空间只是该对象的数据成员所占的存储空间，而不包括函数代码所占用的存储空间。 第九章 怎样使用类和对象对象的初始化不能在类生命中对数据成员初始化，因为类并不是一个实体，而是一种抽象类型，并不占存储空间，显然误触容纳数据。 用构造函数实现数据成员的初始化在类外定义构造成员函数，要加上类名和域限定符。 在建立对象时系统为该对象分配存储单元，此时执行构造函数。 构造函数的重载无参构造函数应注意正确书写定义对象的语句 请记住：构造函数是不能被用户显式调用的 使用默认参数的构造函数由于不需要实参也可以调用构造函数，因此全部参数都指定了一个默认值的构造函数也属于默认的构造函数。 编译系统无法识别应该调用那个构造函数，出现歧义性 在一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数 析构函数如果用户没有定义析构函数，C++ 编译系统会自动生成一个析构函数，但它只是徒有析构函数的名称和形式，实际上什么操作都不进行。 调用构造函数和析构函数的顺序先构造的后析构，后构造的先析构。相当于一个栈，先进后出。 指向对象成员的指针12345678Time * pt; //定义 pt 是指向 Time 类对象的指针变量Time tl; //定义 tl 为 Time 类对象pt = &amp; tl; //将 tl 的起始地址赋给 pt* pt; //pt 所指向的对象，即 tl；//以下表示是等价的(* pt).hour; pt -&gt; hour; 指针变量的类型必须与赋值号右侧函数的类型相匹配，要求在以下3方面都要匹配：1.函数参数的类型和参数个数；2、函数返回值类型；3.所属的类 定义指向公用成员函数的指针变量的一般形式为： 1234数据类型名 （类名 :: * 指针变量名）（参数列表）;//形如：void(Time:: *p2)() 使指针变量指向一个公用成员函数的一般形式为： 123指针变量名 = &amp; 类名 :: 成员函数名//形如p2 = &amp;Time::get_time; 常对象常对象必须有初值，在常对象的生命周期中，对象中的所有数据成员的值都不能被修改 定义常对象的一般形式为： 1类名 const 对象名[(实参表)]； 也可以把const写在最左边： 1const 类名 对象名[(实参表)]； 与上面的格式是等价的。 在定义常对象时，必须同时对之初始化，之后不能再改变。 常对象成员 常成员函数 12//注意const的位置在函数名和括号之后viod get_time() const; 指向对象的常指针指向对象的常指针变量的值不能改变，即始终指向同一个对象，但可以改变其所指向的对象的值。 往往常指针作为函数的形参，目的是不允许在函数执行过程中改变指针变量的值，使其始终指向原来的对象。 指向常对象的指针变量一个对象已经被声明为常变量，只能用指向常变量的指针变量指向它。 指向常变量的指针变量除了可以指向常变量，还可以指向未被声明为const的变量。此时不能通过此指针变量来改变该变量的值。 指向常对象的指针最常用于函数的形参，目的是在白虎形参指针所指向的对象，使它在函数执行过程中不被修改。 以下是非法的： 形参：指向非 const 型变量的指针；实参 const 变量的地址； 因为参数传递本质是值传递/地址传递。过程：形参指向实参。因为非 const 型变量指针只能指向非 const 型变量。所以以上是非法的。 在函数调用时将建立一个新的对象，它是实参对象的拷贝 对象的动态建立和释放用new运算符动态地分配内存后，将返回一个指向新对象的指针。 对象的赋值对象的赋值只对其中数据成员赋值，而不对成员函数赋值。 不同对象的成员函数时同一个函数代码段，不需要，也无法对它赋值。 静态成员静态数据成员可初始化，但只能在类体外进行初始化。 公用静态数据成员与全局变量不同，静态数据成员的作用域只限于定义该类的作用域内（如果是在一个函数中定义类，那么其中静态数据成员的作用域就是在此函数内） 静态数据成员函数非静态成员函数有 this 指针，而静态成员函数没有this指针。由此决定了静态成员函数不能访问本类中的非静态成员。 在 C++ 程序中最好养成这样的习惯：只用静态成员函数引用静态数据成员，而不引用非静态数据成员。 友元函数在类外定义的且未用类最限定的函数，是非成员函数，不属于任何类。 友元类 友元的关系是单向的而不是双向的。 友元的关系不能传递。 类模板一般形式为： 1类模板名 &lt;实际类型名&gt; 对象名（参数表); 第十章 运算符重载重载运算符的规则重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象（或类对象的引用），参数不能全是 C++ 的标准类型 运算符重载函数作为类成员函数和友元函数将双目运算符重载为友元函数时，由于友元函数不是该类的成员函数，因此在函数的形参表中必须有两个参数，不能省略。 用转换构造函数进行不同类型数据的转换通常把有一个参数的构造函数作类型转换，所以，称为转换构造函数。 类型转换函数类型转换函数的作用是将一个类的对象转换成另一个类型的数据。形式如： 12operator 类型名（） &#123; ... &#125; 在函数名前不能指定函数类型，函数没有参数。类型转换函数只能作为成员函数，因为转换的主体是本类的对象，不能作为友元函数或普通函数。 如果运算符重载函数为成员函数，它的第一个参数必须是本类的对象。当第一个操作数不是类对象时，不能将运算符函数重载为成员函数，如果将运算符“+” 重载为类的成员函数，交换律不适用。 类型转换函数与运算符重载不共存。因为可能出现二义性。 第十一章 继承与派生派生类的声明方式基类名前有 public 的称为公用继承。如果不写此项，默认为 privite（私有的） 派生类成员的访问属性基类的成员函数只能访问基类的成员，而不能派生类的成员。 公用继承 基类的公用成员和保护成员在派生类中保持原有访问属性，私有成员仍为基类私有 私有继承 基类的公有成员和保护成员在派生类中成了私有成员，私有成员仍为基类私有 受保护继承 基类的公有成员和保护成员在派生类中成了保护成员，私有成员仍为基类私有 派生类的构造函数和析构函数基类的构造函数式不能继承的，对继承过来的基类成员初始化的工作也要由派生类的构造函数承担。解决这个问题的思路是：在执行派生类的构造函数时，调用基类的构造函数。 简单的派生类构造函数在类中对派生类构造函数作声明时，不包括上面给出的一般形式中的基类的构造函数名（参数表）部分 有子对象的派生类的构造函数应当在建立对象时对它的数据成员初始化。 派生类构造函数的任务应该包括： 对基类数据成员初始化 对子对象数据成员初始化 对派生类数据成员初始化 定义派生类构造函数的一般形式为： 12派生类构造函数名（总参数表）：基类构造函数名（参数表），子对象名（参数表）&#123; 派生类中新增数据成员初始化语句 &#125; 派生类构造函数的特殊形式如果在基类中没有定义构造函数，或定义了没有参数的构造函数，那么，在定义派生类构造函数时可以不写基类构造函数。因此此时派生类构造函数没有向基类构造函数传递参数的任务。在调用派生类构造函数时，系统会自动首先调用基类的默认构造函数。 派生类的析构函数在执行派生类的析构函数时，系统会自动调用基类的析构函数和子对象的析构函数。调用的顺序与构造函数相反：先执行派生类自己的析构函数，然后调用子对象的析构函数，最后调用基类的析构函数。 多重继承形式如： 12派生类构造函数名（总参数表）：基类 1 构造函数（参数表），基类 2 构造函数（参数表）, 基类 3 构造函数（参数表）&#123; 派生类中新增数据成员初始化语句 &#125; 声明基类的顺序决定了基类构造函数的调用顺序 多重继承引发的二义性问题基类的同名成员在派生类中被屏蔽。成为不可见的。因此如果在定义派生类对象的模块中通过对象名访问同名的成员，则访问的是派生类的成员。请注意：不同的成员函数，只有在函数名和参数个数相同、类型相匹配的情况下才发生同名覆盖。 虚基类虚基类使得在继间接共同基类时只保留一份成员。 需要注意，为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。 由于虚基类在派生类中只有一份数据成员，所以这份数据成员的初始化必须由派生类直接给出。 C++ 编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类对虚基类的构造函数的调用，这就保证了虚基类的数据成员不会被多次初始化。 基类与派生类的转换123A al; //定义基类 A 对象 alB bl; //B 是 A 的派生类A&amp; r = al; //定义基类 A 对象的引用 r，并引用 al 对其初始化 这时，r 是 al 的引用（别名），r 和 al 共享同一段存储单元。 1A&amp; r = bl; 此时 r 并不是 bl 的别名，也不是与 bl 共享同一段存储单元，它只是 bl 中基类部分的别名，r 与 bl 中基类部分共享同一段存储单元，r 与 bl 具有相同的其实地址。 即基类的引用类型，指向了派生类的变量。指向的也是派生类中从基类继承的部分。 继承与组合在一个类中以另一个类的对象作为数据成员的，称为类的组合。 第十二章 多态性与虚函数派生类对象可以替代基类对象向基类对象的引用初始化或赋值。调用的不是在 Circle 中声明的运算符重载函数，而是在 Point 中声明的运算符重载函数，输出的是“点”的信息，而不是“圆”的信息。 这两个 area 函数不是重载函数，它们不仅函数名相同，而且函数类型和参数个数都相同，两个同名函数不在同一个类中，而是分别在基类和派生类中，属于同名覆盖。 虚函数的作用编译系统按照同名覆盖的原则决定调用的对象。 C++ 的虚函数就是用来解决动态多态的问题的。所谓虚函数，就是在基类声明函数是虚拟的，并不是实际存在的函数，然后在派生类中才正式定义此函数。 本来，基类指针是用来指向基类对象的，如果用它指向派生类对象，则自动进行指针类型转换，将派生类的对象的指针先转换为基类的指针，这样，基类指针指向的是派生类中的基类部分。 有时在基类中定义的非虚函数会在派生类中被重新定义，如果用基类指针调用该成员函数，则系统会调用对象中基类部分的成员函数；如果用派生类指针调用该函数，则系统会调用派生类对象中的成员函数，这并不是多态性行为（使用的是不同类型的指针） 静态关联和动态关联确定调用的具体对象的过程称为关联。 函数重载和通过对象名调用的虚函数，在编译时即可确定其调用的虚函数属于哪一个类，其过程称为静态关联。 由于是在运行阶段把虚函数和类对象“绑定”在一起的，因此称为动态关联。 在什么情况下应当声明虚函数一个成员函数被声明为虚函数后，在同一类族中的类就不能定义一个非 virtual 的但与该虚函数具有相同的参数。 虚析构函数先调用了派生类的析构函数，再调用了基类的析构函数。当基类的析构函数为虚函数，无论指针指的是同一类族中的哪一个类对象。 如果将基类的析构函数声明为虚函数时，由该函数所派生的所有派生类的析构函数有都自动成为虚函数，即使派生类的析构函数与基类的析构函数名字不相同。 纯虚函数与抽象类1virtual 函数类型 函数名（参数类别） = 0; 纯虚函数只有函数的名字而不具备函数的功能，不能被调用。它只是通知编译系统：在这里声明一个虚函数，待派生类中定义。 抽象类凡是包含纯虚函数的类的都是抽象类。因为纯虚函数是不能被调用的，包含纯虚函数的类是无法建立对象的。抽象类的作用是作为一个类族的共同基类。 抽象基类不能也不必要定义对象。 区别静态关联和动态关联在编译阶段就能确定调用的是哪一个类的虚函数，所以属于静态关联。如果是通过基类指针调用虚函数，在编译阶段无法从语句本身确定调用哪一个类的虚函数，只有在运行时，指针指向某一类对象后，才能确定调用的是哪一个类的虚函数，故为动态关联。 第十三章 输入输出流istream 类的其他成员函数如果到达文件末尾（遇到文件结束符），eof 函数值为非零值（表示真），否则为 0（假）。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APK 的前世今生：从 Android 源码到 apk 的编译打包流程]]></title>
    <url>%2F2018%2F11%2F18%2FAPK-%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%9A%E4%BB%8E-Android-%E6%BA%90%E7%A0%81%E5%88%B0-apk-%E7%9A%84%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近想要研究热修复的原理，并自己实现一套简单的热修复框架（音视频的坑刚挖好就又挖另一个坑了2333），已经在看书入门 c++，方便后续查看业内一些知名热修复框架的源码，另外在涉及编译期/运行时修改代码之前，先了解一下 apk 是如何从项目源码被打包生成的，可能对后续的从思路上或实际操作都会所裨益。 文中涉及到的工具所在目录：Android/sdk/build-tools。下面开始分解并逐步实现对源码的打包。 编译流程1. 生成仅包含资源文件的 apk 包和 R.java 文件根据资源文件和 AndroidManifest.xml 由工具 AAPT 生成 R.java 文件。Android Gradle Plugin 3.0.0 以后默认使用 AAPT2，详见 AAPT2 官方文档。来看一下 AAPT2 的使用： 预编译编译所有 Android 支持的资源文件。可以通过编译语句将单个资源文件编译成 .flat 后缀的过渡二进制文件 AAPT 可以编译单个文件，例如编译 strings.xml，会生成 values_strings.arsc.flat 文件： 1aapt2 compile app/src/main/res/values/strings.xml -o test/ 但一个项目不可能只有一个资源文件，通常都是编译 整个 res 资源目录，会生成 zip 压缩包，包含了所有资源文件编译后的 flat 格式文件： 1aapt2 compile --dir app/src/main/res/ -o package/res.zip 参数含义： –dir：指定输入目录 -o： 指定输出目录（如果输入源是文件夹，则需要指定编译后的（zip）文件名） 链接（link）将预编译生成的过渡二进制文件合并并打包成单独的 APK 包，R 文件和 ProGuard 规则文件也是在这个时期生成的，生成的 APK 包不包含 DEX 字节码并且是未签名的（后续可使用 D8 编译工具将 Java 字节码编译成 DEX 字节码，使用 apksigner 对 APK 签名） 12345aapt2 link package/res.zip \-I ~/Library/Android/sdk/platforms/android-27/android.jar \--java package/ \--manifest app/src/main/AndroidManifest.xml \-o package/res.apk 参数含义： -I：必要参数，指定 android.jar 目录，因为 xml 中可能使用到了例如 android:id 等自带的 android 命名空间 o：指定输出 apk 路径 –java：指定生成的 R 文件的路径 –manifest：必要参数，Manifest 文件中包含了 app 的包名和 application id 执行上述命令后报错：style/Theme.AppCompat.Light.DarkActionBar not found. 以及 layout_constraintBottom_toBottomOf （新建的工程默认依赖了 constraint-layout库）等各种 not found。 报这些错是因为 link 时没有引入第三方库，在 Google 文档里没有找到相关的命令，所以先移除这些依赖，跑通整个流程后再回头看怎么解决。 123// AppTheme 暂时先移除对 Theme.Appcompat 的依赖 &lt;style name=&quot;AppTheme&quot; parent=&quot;android:Theme.Holo.Light.DarkActionBar&quot;&gt;&lt;/style&gt; 再执行一遍命令，可以看到指定的输出目录已经生成了 apk 包和 R 文件： 2. 处理aidl，生成对应的java文件因为 demo 没有涉及到 aidl，暂且跳过。 3. 编译 .java 文件为 .class 文件编译项目 src 目录下所有 .java 文件还有之前生成的 R.java 、aidl 生成的 java 文件为相应的的 class 文件 12345javac -encoding utf-8 \-target 1.8 \-bootclasspath ~/Library/Android/sdk/platforms/android-27/android.jar \app/src/main/java/com/yazhidev/demo/*.java package/com/yazhidev/demo/R.java \-d package/ 参数含义： -encoding: 指定编码方式为 uts-8 -target：指定 Java 版本号 -bootclasspath：引入 Android.jar 包内的类 -d：指定编译生成的字节码文件存放的路径 4. class 文件编译为 dex 文件dex 文件是 Android 虚拟机所能识别、解析并运行的文件。Java 源文件被编译为 class 文件后，需要通过 dex 编译器将多个 class 文件整合为一个 dex 文件，从 Android Studio 3.1 开始，已经使用 D8 替代原先的 DX 作为默认的 dex 编译器。D8 的使用很简单： 123d8 package/com/yazhidev/demo/*.class \--classpath ~/Library/Android/sdk/platforms/android-27/android.jar \--output ./ 参数含义： –classpath：指定编译需要引用到的类 –output：指定编译后生成的 .dex 文件的存放路径 5. 将 dex 文件添加进 apk 包原本这步是通过 apkbuilder 脚本来做的，现在改成用 aapt 命令来做。 1aapt add package/res.apk classes.dex 需要注意的是 dex 文件前不能加路径，否则会将路径带入 apk 包中。 6. 优化对齐 apk 文件apksigner 文档中提到，如果使用 apksigner 对 apk 签名，则需要在签名之前使用 zipalign 优化对齐。 zipalign 的使用很简单： 12345678910zipalign 4 package/res.apk package/app-unsigned-aligned.apk``` 4 代表 32 位对齐，zipalign 可以确保所有未压缩的数据的开头均相对于文件开头部分执行特定的字节对齐，这样可减少应用消耗的 RAM 量。### 7. 签名签名需要私钥，可以通过 Android Studio 生成，也可通过 JDK bin 目录下的 keytool 工具生成。keytool 以及 apksigner 的使用可参考：[从命令行构建和签署您的应用](https://developer.android.com/studio/publish/app-signing)我自己这么就直接使用现有的 key 签名，签名的命令很简单： //apk 签名apksigner sign –ks key.jks –out package/app-release.apk package/app-unsigned-aligned.apk1234参数含义：- --ks：指定私钥文件- --out：指定签名后的 apk 输出路径 //检查 apk 的签名apksigner verify app.apk` 至此，就完成了 Android 源码打包成 apk 的整个流程，当然以上只是最简单的情况，对于第三方库、多 module 等情景下的打包流程都没有涉及。将 apk 安装到手机上，可以正常打开: 一打开首页我的内心的拒绝的，这首页可以说是丑出天际。但起码从 0 到 1 了（化身阿 Q 疯狂自我安慰），一番操作算是对 apk 的打包流程有了个笼统的认识，后面要了解一下 app 启动流程，为热修复的学习打基础。（也许后面会回来填坑？）]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 音视频开发（一）：PCM 格式音频的播放与采集]]></title>
    <url>%2F2018%2F10%2F26%2FAndroid-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9APCM-%E6%A0%BC%E5%BC%8F%E9%9F%B3%E9%A2%91%E7%9A%84%E6%92%AD%E6%94%BE%E4%B8%8E%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[什么是 PCM 格式声音从模拟信号转化为数字信号的技术，经过采样、量化、编码三个过程将模拟信号数字化。 采样 顾名思义，对模拟信号采集样本，该过程是从时间上对信号进行数字化，例如每秒采集 44100 次，即采样频率 44.1 khz 量化 既然是将音频数字化，那就需要使用二进制来表示声音的每一个样本。例如每个样本使用 16 位长度来表示，即音频的位深度为 16 位 编码 编码就是按照一定的格式记录采样和量化后的数据，比如顺序存储或压缩存储等 编码后经由不同的算法，音频被保存为不同的格式，例如 MP3、AAC 等，而 PCM 就是最为原始的一种格式，PCM 数据是音频的裸数据格式，不经过任何压缩。 从零到一：使用 AudioTrack 支持 PCM 格式音频的播放AudioTrack 只支持播放 PCM 编码格式的音频流，平时使用的 MediaPlayer 支持 MP3、AAC 等多种音频格式，其内部也是将 MP3 格式文件使用 framework 层创建的解码器解码为 PCM 裸数据，再经由 AudioTrack 播放的。封装过的 Mediaplayer 的 API 是简单好用，但许多细节我们却无法掌控，而使用 AudioTrack，除了播放之外，我们还可以对数据源做许多有意思的操作，二者各有优劣之处。 先通过构造函数来了解 AudioTrack（版本为API26）： 123public AudioTrack(AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes, int mode, int sessionId) &#123; ... &#125; 几个参数介绍一下： AudioAttributes 定义音频的类型，包括音乐、通知、闹钟等，调节音量时也会根据不同的类型进行调节 AudioFormat 定义音频的格式，可配置声道数（单通道、多通道）、编码格式（每个采样数据位深度，8bit、16bit等）、采样率 bufferSizeInBytes AudioTrack 内部的音频缓冲区的大小，该缓冲区的值不能低于一帧“音频帧”（Frame）的大小，即：采样率 x 位深 x 采样时间 x 通道数，采样时间一般取 2.5ms~120ms 之间，AudioTrack 类提供了 getMinBufferSize() 方法来计算该值 mode AudioTrack 的两种播放模式，MODE_STATIC 和 MODE_STREAM，前者直接将数据加载进内存，后者是按照一定的间隔不断地写入数据 API26 下原有的两个构造函数已经被标为废弃，建议使用 Builder 来构造 AudioTrack 对象： 1234567891011private fun createAudioTrack(): AudioTrack &#123; val format = AudioFormat.Builder() .setChannelMask(AudioFormat.CHANNEL_OUT_STEREO) .setSampleRate(44100) .setEncoding(AudioFormat.ENCODING_PCM_16BIT) .build() return AudioTrack.Builder() .setAudioFormat(format) .build()&#125; 网上介绍 AudioTrack 时常见的如何构造 bufferSizeInBytes也不用关心了，Builder 类会替我们默认生成。 构造出对象后，在调用 play() 函数开启播放后，只要开启一个线程不断地从源文件中读取数据并调用 AudioTrack 的 write() 函数向手机端音频输出设备传输数据，即可播放 PCM 音频。 使用 ffmpeg 将 MP3 转为 PCMMac 下安装 ffmpeg：brew install ffmpeg 使用 ffmpeg 将 mp3 转换为 pcm：ffmpeg -i xxx.mp3 -f s16le -ar 44100 -ac 2 -acodec pcm_s16le xxx.pcm -i 制定输入文件 -f 指定输出编码格式为16byte小端格式 -ar 指定输出采样率 -ac 指定输出通道数 acodec 指定解码格式 xxx.pcm 为输出文件 这里也提供一下我使用的 PCM 文件：hurt-johnny cash.pcm 44.1khz 双通道 16位深 PCM 录制：AudioRecordMediaRecorder 录制集成了编码、压缩等功能，AudioRecord 录制的是 PCM 格式的音频文件。 同样的，先从构造函数来认识 AudioRecord： 123public AudioRecord(AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes, int sessionId) &#123; ...&#125; 接触过 AudioTrack，对 AudioRecord 一定不会感到陌生，其构造函数参数与 AudioTrack 几乎如出一辙，这里就不多说了。 AudioRecord 的 API 与 AudioTrack 也是遥相呼应的，在调用函数 startRecording() 开启录制后，只要开启一个后台线程不断地调用 read() 函数从手机端的音频输入设备（麦克风等）读取音频数据，并写入本地文件，即可实现音频的录制。 扩展支持的音频格式： WAV最开始提到过音频会被编码成不同的格式，而常见的压缩编码格式 WAV 格式可能是与 PCM 数据最为接近的一种格式。WAV 编码不会进行压缩操作，它只在 PCM 数据格式前加上 44 字节（并不一定严格是 44 字节）来描述音频的基本信息，例如采样率、声道数、数据格式等。来看看 WAV 文件头的格式： WAV 文件头格式 长度（字节） 内容 4 “RIFF” 字符串 4 从下个地址开始到文件尾的总字节数（音频 data 数据长度 + 44 -8） 4 “WAVE” 4 “fmt “（最后有一个空格） 4 过渡字节（一般为00000010H），若为00000012H则说明数据头携带附加信息（见“附加信息”） 2 格式种类，1 表示为PCM形式的声音数据 2 通道数，单声道为1，双声道为2 4 采样率 4 波形音频数据传送速率，其值为通道数×每秒数据位数×每样本的数据位数／8。播放软件利用此值可以估计缓冲区的大小。 2 每个采样需要的字节数，其值为通道数×位深度／8。播放软件需要一次处理多个该值大小的字节数据，以便将其值用于缓冲区的调整。 2 位深度 4 “data” 4 DATA数据长度 了解了 WAV 文件头的格式，我们可以尝试自己写一个解析 WAV 文件头的方法，结合上文的 AudioTrack 播放 PCM 的内容来看，只要获取到音频的采样率、位深度与声道数就可以播放该音频。自然也就可以播放内容是 PCM 格式的 WAV 文件。 在此之前需要一个 WAV 文件用作测试，可以使用 ffmpeg 将之前转换的 PCM 格式音频转码成 WAV 格式。 使用 ffmpeg 将 PCM 转为 WAV1ffmpeg -i xxx.pcm -f s16le -ar 44100 -ac 2 xxx.wav 也分享一下我使用的 WAV 文件：hurt-johnny cash.wav 44.1khz 双通道 16位深 解析 WAV 文件头根据上面提到的 WAV 文件头格式，定义一个类用于存放文件头数据： 1234567891011121314151617public class WaveHeader &#123; private String riff; // &quot;RIFF&quot; private int totalLength; //音频 data 数据长度 + 44 -8 private String wave; // &quot;WAVE&quot; private String fmt; // &quot;fmt &quot; private int transition; //过渡字节，一般为0x00000010 private short type; // PCM：1 private short channelMask; // 单声道：1，双声道：2 private int sampleRate; //采样率 private int rate; // 波形音频数据传送速率，其值为通道数×每秒数据位数×每样本的数据位数／8 private short sampleLength; // 每个采样需要的字节数，其值为通道数×位深度／8 private short deepness; //位深度 private String data; // &quot;data&quot; private int dataLength; //data数据长度 ...&#125; 定义好文件头后，我们使用 BufferedInputStream 从本地文件输入流中挨个字节读取数据即可。 byte 字节转字符串12345678910private static String readString(InputStream inputStream, int length) &#123; byte[] bytes = new byte[length]; try &#123; inputStream.read(bytes); return new String(bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125;&#125; byte 字节转 short、int需要注意的是 WAV 头中的字节数组是经过反转的，例如表示单通道的字节数组为{1, 0}，其中 1 为低位字节，即原始的字节为 [0, 1]，转换为二进制为 0000 0000 0000 0001，即十进制的 1，代表单通道。 123456789101112//从输入流中读取 2 个字节并转换为 shortprivate static short readShort(InputStream inputStream) &#123; byte[] bytes = new byte[2]; try &#123; inputStream.read(bytes); //&#123;1, 0&#125; return (short) ((bytes[0] &amp; 0xff) | ((bytes[1] &amp; 0xff) &lt;&lt; 8)); &#125; catch (IOException e) &#123; e.printStackTrace(); return 0; &#125;&#125; 1234567891011//从输入流中读取 4 个字节并转换为 intprivate static int readInt(InputStream inputStream) &#123; byte[] bytes = new byte[4]; try &#123; inputStream.read(bytes); return (int) ((bytes[0] &amp; 0xff) | ((bytes[1] &amp; 0xff) &lt;&lt; 8) | ((bytes[2] &amp; 0xff) &lt;&lt; 16) | ((bytes[3] &amp; 0xff) &lt;&lt; 24)); &#125; catch (IOException e) &#123; e.printStackTrace(); return 0; &#125;&#125; 从代码中可以看到，字节转换为整型数据类型（short、int 等）时，需要先与 0xff 做与（&amp;）操作，这是为什么呢？ 类型转换时 byte &amp; 0xff 的原因要究其原因，首先需要搞清楚计算机中的原码、反码和补码，这个在之前的文章《Bitmap 图像灰度变换原理浅析》中计算 int 数据类型的值范围时也提到过。下面举个栗子来验证一下，类型转换前 &amp; 0xff 到底有什么用： 假定有一个 byte 数组：[0, 0, -1, 0]，想求得这 4 个字节代表的 int 值得大小，重点看第三个字节，其值为 -1，byte 占一个字节 8 位，易得： 原码：1000 0001 反码：1111 1110 补码：1111 1111 显而易见，这个 byte 数组代表的 int 值的二进制值为： 0000 0000 0000 0000 1000 0001 0000 0000 只要对 -1 左移 8 位即可。so easy！ 12byte a = -1;int b = a &lt;&lt; 8; //结果是 -256 值为负数就说明以上转换必然是错的。因为我们想要的结果是 0000 0000 0000 0000 1000 0001 0000 0000，该二进制最高位符号位为 0，结果必然是一个正数。 我们知道计算机在运算时使用的是补码，则 （byte）-1 &lt;&lt; 8 运算时，计算机会对 -1 的补码 1111 1111 做位移操作，结果为 1111 1111 0000 0000，其原码为 1000 0001 0000 0000，先记作 16位原码A，当该值赋值给 int 类型的变量时，int 类型占 4 个字节 32 位，则需要对原因的 16 位值做位扩展，负数在位扩展时会对多出的高位补 1（正数补 0），则扩展后的值为 1111 1111 1111 1111 1111 1111 0000 0000，转为原码为 1000 0000 0000 0000 0000 0001 0000 0000，记作 32位原码B，与上面的 16 位原码做比较可以发现，二者最高位都是 1，低位的值也相同，两个二进制的值在十进制上是一致的，这就是负数补码高位补 1 的原因：为了保持十进制的一致性。不难理解这样做的原因，否则 short 类型强制为 int 类型后值就发生变化了，这明显是不可接受的。 回到我们的需求，我们这里并不需要保持十进制的一致性，所以要先与 0xff 做与运算，因为 0xff 是十六进制 32 位，二进制值为 32 个 1，-1 &amp; 0xff 时，8 位与 32 位运算时，8 位的需要先在高位补 0 补齐到 32 位才会做运算，所以-1 &amp; 0xff 的结果为补码：1111 1111 前面带 24 个 0，最高位为正数，再对结果做位移操作，得到的二进制值补码为：0000 0000 0000 0000 1111 1111 0000 0000，因为是正数，原码与补码相同，该二进制值为 65280。可以验证下： 12byte a = -1;int c = (a &amp; 0xff) &lt;&lt; 8; //结果是 65280 概括一下就是： 类型转换时补码位扩展（例如 2 个字节转 4 个字节，即 short 转 int）的规则：正数高位补 0，负数高位补1，以此保持十进制的一致性 运算时，补码高位统一补 0 这里也附上将 byte 转二进制（补码）的方法： 12345public static String binary(byte bytes, int radix)&#123; byte[] bytes1 = new byte[1]; bytes1[0] = bytes; return new BigInteger(1, bytes1).toString(radix);// 这里的1代表正数&#125; 顺序读取，构造 WavHeader接着只要使用 InputStream 从目标音频中顺序读取各个参数的值并构造 WavHeader 即可，因为 Header 成员变量众多，所以考虑用建造者模式来构建 Header： 123456WaveHeader.Builder builder = new WaveHeader.Builder() .setRiff(readString(dis, 4)) .setTotalLength(readInt(dis)) .setWave(readString(dis, 4)) .setFmt(readString(dis, 4)) ... 另外上面提到过，并非所以 WAV 文件头都是标准的 44 个字节，例如我上面提供的 ffmpeg 转码后的 WAV 文件，其文件头的长度就是 78 个字节。对于文件头长度不一致的问题，我的解决方法是从 37 个字节开始，2 个 2 个字节地读取，直到读取到“da”和“ta”，之后再往后读取 4 个字节的 int 值作为 data 数据长度。读取到 header 后，后面播放的就不用说了，复用上面播放 PCM 的代码即可。 需要说明的是我只是从网上随机下载了几个 wav 格式音频测试了下是可以正常播放的，并没有经过广泛验证和对常见的 WAV 文件头格式的考证，所以可能还存在兼容问题。 经过这些以上的学习以及众多资料的查阅，对 Android 端音频开发有了一些小小的认识。后面还会学习一下使用 LAME 将 PCM 转码为 MP3，并实现一些真正意义上的音频播放器的基础功能等。再后面会学习一些视频方面的知识，包括 MediaExtractor、MediaMuxer 解析、封装 MP4 文件、OpenGL ES 渲染图像、MediaCodec 对音视频的硬编、硬解等，并使用一些流行的开源项目例如 ffmpeg 实现一些炫酷的视频处理功能，希望可以在 Android 音视频开发这一块能有所深入，学习过程中的一些收获和困惑也会坚持记录下来。 此路迢迢，与君共勉。 以上源码见 Github]]></content>
      <tags>
        <tag>Android</tag>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解 Java 虚拟机》读书笔记]]></title>
    <url>%2F2018%2F10%2F19%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第二章 Java 内存区域与内存溢出溢出程序计数器程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。每条线程都有独立的程序计数器，各条线程之间计数器互不影响，独立存储。 Java 虚拟机栈Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建的一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中的入栈到出栈的过程。 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。 本地方法栈与虚拟机栈的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，本地方法栈则为虚拟机使用到的 Native 方法服务。 Java 堆Java 堆是被所有线程共享的一块内存区域，此内存区域的唯一目的就是存放对象实例。 如果堆中没有内存完成实例分配，且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。 方法区方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池是方法区的一部分，存放编译器生成的各种字面量和符号引用。运行期间也可能将新的常量放入池中。 直接内存在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方法，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 对象的创建Java 堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。 除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针指向的位置。有两种方案： 多线程同步分配 每个线程分配缓冲区，当缓冲区完成时才需要同步锁定，分配新的缓冲区 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。 执行 new 指令之后会接着执行 &lt;init&gt; 方法，把对象按照程序员的意义进行初始化。 对象的访问定位reference 类型再 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置。目前主流的访问方式有使用句柄和直接指针两种 使用句柄访问，句柄中包含了对象实例数据与类型数据各自具体的地址信息。 使用直接指针访问，那么 Java 堆对象中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。 第三章 垃圾收集器与内存分配策略引用计数算法主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，主要原因是它很难解决对象之间循环引用的问题。 可达性分析算法基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。 再谈引用强 软 弱 虚 强引用 软引用 在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。 弱引用 只能生存到下一次垃圾收集发生之前。 虚引用 也成为幽灵引用，是最弱的一种引用关系。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 生存还是死亡要真正宣告一个对象死亡，至少要经历两次标记过程。如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，条件是此对象是否有必要执行 finalize() 方法（对象没有覆盖 finalize() 或者 finalize() 已经被虚拟机调用过，这两种情况视为没有必要执行）。（注：任何一个对象的 finalize() 方法都只会被系统自动调用一次） 如果这个对象被判定为有必要执行 finalize() 方法，则对象会被放置在一个叫做 F-Quene 的队列之中，在稍后有一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。（执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，以防对象在 finalize() 方法中执行缓慢，或发生死循环） 垃圾收集算法标记-清除算法先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 它主要有两个不足：一个效率问题，标记和清除两个过程效率都不高。另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发一次垃圾收集动作。 复制算法为了解决效率问题，复制算法出现了。它将可用内存按容量划分为大小相等的两块（新生代中大多数人对象时朝生夕死的，所以并不需要按照1：1的比例来划分内存空间），每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 标记-整理算法复制收集算法在对象存活率较高时就有进行较多的复杂操作，效率将会变低。根据老年代的特点，就有了标记-整理算法。过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存货的对象都向一端移动，然后直接清理掉端边界以为的内存。 分代收集算法HotSpot 的算法实现安全点可达性分析对执行时间的敏感还体现在 GC 停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行（即不可以出现引用分析过程中对象引用关系还在不断变化的情况，Sun 将这件事情称为 “Stop The World”）。目前主流 Java 虚拟机都是准确是 GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的，在类加载完成的时候，就把对象内什么偏移量上是什么类型的数据计算处理，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用的。但是没有为每条指令都生成 OopMap，只在特定位置记录这些信息，这些位置称为安全点（SafePoint）。方法调用、循环跳转、异常跳转等，所有具有这些功能的指令才会产生 SafePoint。 对于 SafePoint，另一个要考虑的问题是如何在 GC 发生时让所有线程都跑到安全点再停顿下来，有两种方案：抢断式中断和主动式中断。 主动式中断的思想是设置一个标志位，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。 内存分配与回收策略对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 GC。 新生代 GC，指发生在新生代的垃圾收集动作。因为 Java 对象大多都具备朝生夕灭的特性，所以该 GC 非常频繁，一般回收速度也比较快。 大对象直接进入老年代大对象，指需要大量连续内存空间的 Java 对象。可配置大对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制 长期存活的对象将进入老年代虚拟机采用分代收集的思想来管理内存。为了内存回收时必须能识别哪些对象放在新生代，哪些放在老年代，为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在 Eden 出生并经过第一次新生代 GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1.对象在 Survivor 区中每“熬过”一次新生代 GC，年龄就加 1 岁，当年龄增加到一定程度，将会被晋升到老年代中。 动态对象年龄判定如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。 空间分配担保在发生新生代 GC 前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，并由结果判断是都进行一次 Full GC。 一共有多少对象会存活下来在实际完成内存回收之前是无法明确知道的，所有只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值。但这种手段仍然是一种动态概率的收到，依然会导致担保失败，那就会在失败后重新发起一次 Full GC。 第五章 调优案例分析与实战高性能硬件上的程序部署策略访问文档时要把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象。 控制 Full GC 频率的关键是看应用中大多数对象能否符合“朝生夕灭”的原则，这样才能保障老年代空间的稳定。 相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK 大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。 32 位 Windows 平台中每个进程只能使用 2 GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到 1.5 GB。 集群间同步导致的内存溢出更重要的缺陷是这一类被集群共享的数据要使用集群缓存来同步的话，可以允许读操作频繁，但不应当有过于频繁的写操作，那样会带来很大的网络同步的开销 堆外内存导致的溢出错误32 位 Windows 平台的限制是 2GB，其中划了 1.6 GB 给 Java 堆，而 Direct Memory 内存并不算 1.6 GB 的堆之内，因为它最大也只能在剩余的 0.4 GB 空间中分出一部分。Direct Memory 却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后 FullGC，然后“顺便地”帮它清理掉内存的废弃对象。 类文件结构无关性的基石各种不同平台的虚拟机玉所有平台的统一使用的程序存储格式——字节码是构成平台无关性的基石。 Class 类文件的结构Class 文件格式采用一种类似 C 语言结构体的伪结构来存储数据，其只有两种数据类型：无符号数和表。 无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。 由于常量池中的常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据代表常量池计数值，这个容量计数是从 1 而不是 0 开始。目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为 0 来表示。 在 Class 文件中不会保存各个方法、字段的最终内存布局信息。 常量池中每一项常量都是一个表。 u2 类型能表达的最大值是 65535。所以 Java 程序中如果定义了超过 64 kb 英文字符的变量或方法名，将会无法编译。 方法表集合方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里。 要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。特征签名是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此 Java 语言里无法仅仅依靠返回值得不同来对一个方法进行重载（但是在 Class 文件格式中，特征签名的范围更大点，只要描述符不是完全一致的两个方法也可以共存，也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，也可以合法共存在同一个 Class 文件中） 属性表集合对应的指令为 return，含义是返回此方法，并且返回值为 void，这条指令执行后，当前方法结束。 在任何实例方法里，都可以通过 this 关键字访问到方法所属的对象，因此在实例方法的局部变量表中至少会有一个指向当前对象实例的局部变量。 ConstantValue 属性对于非 static 类型的变量的赋值是在实例构造器 方法中进行的，而对于类变量，则有两种方式可选:在类构造器方法中或使用 ConstantValue 属性。 Signature 属性该属性会记录泛型类型，因为 Java 的泛型采用类型擦除实现的伪泛型。这个属性就是为了弥补运行期做反射时无法获得泛型信息这个缺陷而增设的。 字节码与数据类型由于 Java 虚拟机的操作码长度只有一个字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力。 第七章 虚拟机类加载机制虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。 对于初始化阶段，虚拟机规范则是严格规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）。 对于静态字段，只有直接定义这个字段的类才会被初始化，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。 编译阶段通过常量传播优化，会将常量的值存储到类的常量池中。对常量的引用实际都被转化为类对自身常量池带引用。 接口与类真正有所区别的地方是:当一个类在初始化时，要求其父类全部都已初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候才会初始化。 类加载的过程加载相对于类加载过程的其他阶段，一个非数组类的加载阶段是可控性最强的，开发人员可以通过自定义的类加载器去控制字节流的获取方式（即重写一个类加载器的 loadClass() 方法）。 对于数组类而言，情况有所不同，数组类本事不通过类加载器创建。 验证验证大致会完成下面 4 个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 第一阶段的注意目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合一个 Java 类型信息的要求。 第二阶段主要目的是对元数据信息进行语义校验。 第三阶段主要目的是确认语义是合法的、符合逻辑的。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，变量所使用的内存都将在方法区中进行分配。需要强调一下，首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。 变量在准备阶段的初始值是 0，把值赋值的 putstatic 指令是程序被编译后，存放与类构造器 方法中，在初始化阶段才会进行。 会存的特殊情况如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段就会赋值。 解析符号引用：以一组符号来描述所引用的目标。 直接引用：直接指向目标的指针、偏移量或是一个能间接定位到目标的句柄。 对一个符号引用进行多次解析请求是很常见的，虚拟机会对第一次解析的结果进行缓存，从而避免解析动作重复进行。 初始化类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。准备阶段，变量已经赋过一次系统要求的初始值，在初始化阶段，则根据程序的主观计划去初始化类变量和其他资源。初始化阶段是执行类构造器 () 方法的过程。 () 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现顺序所决定的，静态语句块中只能访问到定义在静态语句块从之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。 () 方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 () 方法执行之前，父类的 () 方法已经执行完毕。 () 方法对于类或接口来说并不是必须得的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成()方法。 虚拟机会保证一个类的 () 方法在多线程中被正确地使用，只会有一个线程去执行这个类的 () 方法。 类加载器类与加载器比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。即使是来源于同一个 Class 文件，如果加载它们的类加载器不同，那这两个类必定不相等。 双亲委派模型如果应用程序中没有自定义过自己的类加载器，一般情况下就是使用系统类加载器。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 双亲委派模型得工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。 无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各个类加载器环境中都是一个类。 第九章 类加载器及执行子系统的案例与实战OSGI：灵魂的类加载器架构一个 Bundle 可以声明它所依赖的 Java Package（通过 Import 描述），也可以声明它允许导出发布的 Java Package（通过 Export 描述），且会严格控制访问范围，如果一个类存在于 Bundle 的类库中但是没有被 Export，那么这个 Bundle 的类加载器能找到这个类，但不会提供给其他 Bundle 使用。 字节码生成技术与动态代理的实现优势在于实现了可以在原始类和接口还未知时，就确定了代理类的代理行为。 第十章 早期（编译期）优化字节码生成是 Javac 编译过程的最后一个阶段。 Java 的语法糖的味道泛型与类型擦除Java 的泛型只在程序源码中存在，编译后的字节码文件中，已经替换为原来的原生类型（Raw Type），并且相应的地方插入了强制转型代码，因此对于运行期的 Java 语言来说，ArrayList 与 ArrayList 是同一个类。因为参数编译之后都被擦除了，擦除动作导致这两种方法的特征签名变得一模一样。 方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名之中，所以返回值不参与重载选择。 擦除法所谓的擦除，仅仅是对方法的 Code 属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。 自动装箱、拆箱与遍历循环变长参数编译后使用数组实现。 遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历得类实现 Iterable 接口的原因。 包装类的“==”运算在不遇到算数运算的情况下不会自动拆箱。 条件编译根据布尔值常量的真假，编译器将会把分支中：是成立的代码块消除掉，这一工作将在编译器解除语法糖阶段完成。 第十一章 晚期（运行期）优化方法内联的重要性要高于其他优化措施，它的主要目的有两个，一是去除方法调用的成本（如建立栈帧等），二是为其他优化建立良好的基础，方法内联膨胀后可以便于在更大范围上采取后续的优化手段，从而获得更好的优化效果。 公共分子表达式消除如果一个表达式 E 已经计算过了，并且从先前的计算的现在 E 中所有变量的值都没有发生变化，那么 E 的这次就成为了公共分子表达式。 数组边界检查消除Java 语言中访问数组元素 foo[i] 的时候系统将会自动进行上下界的范围检查。 但数组边界检查是不是必须一次不漏地检查呢？常见的情况是数组访问发生在循环之中，如果循环变量的取值范围永远在区间 [0, foo.length] 之内，那么整个循环中就可以把数组的上下界检查消除。 方法内联方法内联的优化行为看起来很简单，不过是把目标方法的代码“复制”到发起调用的方法区之中，避免发生真实的方法调用而已。但实际上远远没有那么简单，因为多态，编译器无法确定运行版本。 编译器在进行内联时，如果是非虚方法，那么直接进行内联就可以了。如果遇到虚方法，则会查询此方法是否有多个目标版本可以选择，如果查询结果只有一个版本，也可以进行内联。后续的执行过程中，如果一直没有加载到会令这个方法的接受者的继承关系发生变化的类，则这个内联代码就可以一直使用下去。否则就需要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。 如果查询结果有多个版本的目标方法可供选择，则使用内联缓存来完成方法内联。其大致原理是：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接受者的版本信息，并且每次进行方法调用时都比较接受者版本，如果都是一样的，那这个内联还可以一直用下去，如果不一致，才会取消内联，查找虚方法进行方法分派。 逃逸分析如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。 第十二章 Java 内存模型与线程硬件的效率与一致性由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 但它引入了一个新的问题：缓存一致性。 内存模型，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。 Java 内存模型主内存与工作内存Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成。 程序运行时主要访问读写的是工作内存。 内存间交互操作Java 内存模型定义了一下 8 种操作，虚拟机实现时必须保证每一种操作都是原子的、不可再分的： lock（锁定） unlock（解锁） read（读取） load（载入） use（使用） assign（赋值） store（存储） write（写入） 对于 volatile 型变量的特殊规则当一个变量定义为 volatile 之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新指对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递都需要通过主内存来完成。例如，线程 A 修改了一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。 volatile 变量在各个线程的工作内存中不存在一致性问题，但是 Java 里的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。 volatile 只能保证可见性，除了以下两种情况下仍然要通过加锁来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量，的值。 变量不需要和其他得状态变量共同参与不变约束。 使用 volatile 的第二个语义是禁止指令重排。 关键变化在于有 volatile 修饰的变量，赋值后多执行了一个“lock addl $0x0”，这个操作相当于一个内存屏障。这种操作相当于对 cache 中的变量做了一次前面介绍 Java 内存模型中所说的 store 和write 操作，通过这样一个空操作，可让 volatile 变量的修改对其他 cpu 立即可见。 原子性、可见性与有序性Java 内存模型是围绕着并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。 原子性：由 Java 内存模型来直接保证的原型性变化包括 read、load、assign、use、store 和 write，我们大致认为基本数据类型的访问读写是具备原子性的。 如果应用场景需要更大范围的原子性操作，Java 内存模型还提供了 lock 和 unlock 操作，这两个指令反映到 Java 代码中就是同步块——synchronize 关键字，因此 synchronize 块之间的操作也具备原子性。 可见性：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 有序性：Java 内存模型的有序性可以总结为：如果在本线程内观察，所有操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指线程内表现为串行。后半句是指指令重排现象和工作内存与主内存的同步延迟想象。 第十三章 线程安全与锁优化线程安全的实现方法 互斥同步 synchronize 关键字经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。 synchronize 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。Java 线程是映射到操作系统的原生线程之上的，如果阻塞或唤醒一个线程，都需要从用户态转换到核心态中，需要耗费很多处理器时间。除了 synchronize 之外，还可以使用 reentrantLock 重入锁来实现同步。 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，非公平锁则是靠抢占的。 可重入代码如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也是线程安全的。 自旋锁与自适应锁共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这就是所谓的自旋锁。 锁消除锁消除是指虚拟机即时编译在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机监测到有这样一段零碎的操作都对同一对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。 偏向锁偏向锁可以提高带有同步但无竞争的程序性能。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点名小辣辣，带你入门 JMeter (｡･∀･)ﾉﾞ]]></title>
    <url>%2F2018%2F10%2F12%2F%E7%82%B9%E5%90%8D%E5%B0%8F%E8%BE%A3%E8%BE%A3%EF%BC%8C%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-JMeter-%EF%BD%A1%EF%BD%A5%E2%88%80%EF%BD%A5-%EF%BE%89%EF%BE%9E%2F</url>
    <content type="text"><![CDATA[什么是 JMeterApache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测 试但后来扩展到其他测试领域。 它可以用于测试静态和动态资源例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、 数据库， FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来在不同压力类别下测试它们的 强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。 搭建环境因为 JMeter 是基于 Java 开发的，所以首先要用 Java 环境。Java 的环境配置这里就不展开了。 JMeter 官网地址 下载 JMeter 5.0 (Requires Java 8 or 9.) / Binaries /apache-jmeter-5.0.tgz 下载完成后解压，进入 bin 目录，运行命令 sh jmeter 即可打开图形页面。 顺便提一下，从上面的命令可以看出，jmeter 文件本质上是一个 shell 脚本，我们使用文本编辑器打开可以看到，其最后执行了 &quot;$JAVA_HOME/bin/java&quot; $ARGS $JVM_ARGS $JMETER_OPTS -jar &quot;$PRGDIR/ApacheJMeter.jar&quot; &quot;$@&quot;，所以该脚本的作用只是一个预置的配置文件，真正打开的是 ApacheJMeter.jar 这个 jar 包。 接下来通过一个简单的测试项目来进一步了解一下 JMeter。 首先不深入到具体的细节，先宏观了解一下 JMeter 里定义任务的结构。 目录结构 TestPlan最外层的 Test Plan（测试计划），右键可以看到可添加的配置： 可以看到 TestPlan 里包含了 ThreadGroup（线程组）、Config（用户自定义的配置）。另外还可以添加例如 Listener（测试结果报告等），以及我还没接触过的，但是从名字上看可能是轮询/计时器、以及对测试任务的前置后置处理等等，这些也是其他几种目录都可以添加的功能。 ThreadGroup 线程组里可以添加 Sampler（我将其理解为具体的测试用例，比如下面会介绍到的 HTTP 测试，就是添加 HTTP request Sampler）。一个线程组可以包含多个测试用例，并且可以自定义（同时运行的）线程数量、运行间隔等，这些配置也是压力/疲劳测试必不可少的组成部分。 Sampler 具体的用例里则可以添加断言，来获取期望测试结果等。 接下来在具体的业务中上手试一下 JMeter 吧~ HTTP 接口测试线程组配置 添加一个线程组 右键 TestPlan，如下添加线程组 简单解释一下各个参数： Number of Thread 线程（用户）的数量 ramp-up period(in second) 使用多长的时间启动所有线程（比如 10 个线程，这里填了 10 秒，即每秒启动一个线程），默认为 0，即立即启动所以线程 Loop count 循环次数（勾选 Forever 即为无限循环） 在线程组中添加一个用例（http 请求） 配置 http 接口 添加结果报告 Result Tree 中可以看到每次运行的请求、响应的数据等。 Summary Report 可以查看运行结果报告，包括平均响应时间（Avarage）、最快响应时间（Min）、最大响应时间（Max）、错误率、吞吐量（Throughput）等等 以上配置后，点击工具栏的绿色运行按钮，可以在结果报告中看到用例的执行结果了。 以上的配置，请求中携带的参数是我们预先配置好的，但是一般登录接口中携带的参数，例如用户名、密码等不可能是固定的。那么如何配置多个用户的参数，然后在运行测试时自动填入呢？ 多用户配置首先创建一个用户列表的文本，内容如： 1215659828000,12345615654545454,123456 每行都代表了一位用户，用户名、密码以英文逗号分隔。然后在 JMeter 中生成函数读取该文本的内容。点击如下图圈中的图标打开函数助手： Choose a function 选择 –CSVRead，第一行 CSV file to get values from | *alias 后面填入用户账号列表的文件地址，第二行 Column number of CSV file | next | *alias 后面先填 0（即获取每行的第一个参数，即用户名），然后点击下方的按钮 Generate &amp; copy to clipboard，就会看到按钮左侧生成了一串形如 ${__CSVRead(/Users/zengyazhi/Downloads/apache-jmeter-5.0/backups/users.txt,0)} 的函数（并且已自动复制到剪贴板），下方也显示出了该函数所取到的值。接下来只要在 http 接口配置的地方填入该函数即可。 需要注意的是：该函数看起来很好理解，无非就是去读取某个文件里的第几个值，我在测试的时候只生成了一次，后续密码的那栏我直接将 0 改成 1，结果却读不到对应的值。所以记得有几个值就要使用函数助手生成几次。 另外还有人提到了使用 badboy 来配置多用户。 使用 badboy 录制 Jmeter 脚本，badboy 录制的脚本比 Jmeter 自己运行的 Http 请求要有更多的参数，比如图形验证码、服务器名称或 IP 会自动加载，无需手写。另外自动加载 Http Cookie 管理器、用户定义的变量、HTTP信息头管理器，以及 Http 请求。 除此之外，Badboy 还可以模拟浏览器操作，记录操作脚本，再配合 JMeter 做压测等等，这里就不展开了。 更多介绍见官网文档 Badboy software 全局变量配置Http 接口一般都存在环境的区别，例如线下环境、生产环境等，如果直接把对应的 host 直接填在上述的 http 配置中，当需要切换环境时岂不是要改到怀疑人生？所以配置全局变量是必不可少的。 也很简单，添加对应的 key-value 即可。例如定义了 host = “dev.test.cn”，在配置 http 接口时，域名一栏填入 ${host} 就可以了。 以上只是简单上手试用下 JMeter，更多功能可能要在对应的业务中才会接触到。 差不多就是这样啦。nana 你在看吗？ ღ( ´･ᴗ･` )比心~]]></content>
      <tags>
        <tag>JMeter</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmap 图像灰度变换原理浅析]]></title>
    <url>%2F2018%2F09%2F02%2FBitmap%20%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[上篇文章《拥抱 C/C++ : Android JNI 的使用》)里提到调用 native 方法直接修改 bitmap 像素缓冲区，从而实现将彩色图片显示为灰度图片的方法。这篇文章将介绍该操作的实现原理。 开始先不讲关于 Bitmap 的相关细节，先从计算机底层存储与运算原理讲起。总所周知，计算机只识别 0 和 1，无论是八进制、十进制、十六进制，在底层都会被转换为二进制。有几个单位与概念要提及一下： 计量单位bit（位）计算机表示信息的最小单位，也是最小的存储单位，只有两种状态：0 和 1。即二进制位。 平时常见的 32 位处理器就是一次最多能处理 32 位的数据，也就是 4 个 byte（字节）。同理，64 位处理器一次最多能处理 64 位的数据，即 8 个字节。 byte（字节） 1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 通常一个字节由 8 个二进制位（bit）组成。 一个十六进制数需要由 4 个二进制组成，即一个字节可以标识 2 个十六进制数。 基本数据类型的长度对 C/C++ 而言，不同的操作平台分配给基本数据类型的长度（字节）是不一样的，比如 char* 指针变量在 32 位编译器里是 4 个字节（32 位的寻址空间是 2^32, 即 32 个 bit，也就是 4 个字节。64 位编译器同理），在 64 位编译器里是 8 个字节。 而 Java 是跨平台语言，JVM 里的基础数据类型的字节长度是一致的。各基本数据类型长度如下： int：4 个字节short：2 个字节。long：8 个字节。byte：1 个字节。float：4 个字节。double：8 个字节。char：2 个字节。boolean：boolean 属于布尔类型，在存储的时候不使用字节，仅使用 1 位来存储，范围仅为 0 和 1，其字面量为 true 和 false。 基本数据类型的取值范围以最常见的 int 为例，Java 中 int 是 4 个字节，那 int 的取值范围是多少呢？熟悉 api 的同学都知道，Integer 类里定义了 MAX_VALUE = 0x7fffffff，那就来推算一下 Java 定义的这个值对不对（大雾 int 占 4 个字节 32 位，因此就是 8 位数的十六进制。因为 int 值有正负之分，所以最高位表示符号，0 代表正数，1 代表负数。显而易见，int 能表示的最大值的二进制为 0111 1111 1111 1111 1111 1111 1111 1111 ，最高位 0，后面跟 31 个 1。换算成十六进制就是 0x7FFFFFFF，该值与 Jdk 中定义的相同，可见 Jdk 还是很严谨的（2333），Java 大法好！同理，最小值的二进制为 1111 1111 1111 1111 1111 1111 1111，换算成十六进制就是 0xFFFFFFFF，再对照一下 Jdk 中定义的最小值 MIN_VALUE = 0x80000000。纳尼？Jdk 有 bug！（2333） 想都不用想，肯定是我自己有 bug，那为什么推算出的和 Jdk 中定义的不符呢。其实是二进制表示方法不对而已。二进制除了上述可直观计算得出的逢二进一的原码外，另外还有几种表示方法。 原码 反码 补码原码很直观易懂，但也有其缺点，就比如最高位为符号位为这个槽点，就诞生了 0000 ~ 0000，1000 ~ 000，分别代表 +0 和 -0。至于数学里有没有 +0 和 -0，二者参与运算是怎么个计算法，我读书少我也不清楚。但这说明了一个问题，使用原码存储和运算会存在二义性。计算机在运算时使用的并非原码而是补码。补码和反码的计算公式如下： 正数 原码、反码、补码都相同 负数 反码：原码保留符号位，其他位取反 补码：反码+1 补码转原码如果符号位为1，其余各位取反，然后再整个数加1。 上面提到的 +0 （0000 ~ 0000），其补码也为 000 ~ 0000，而 -0（1000 ~ 0000），其反码为 1111 ~ 1111，补码为反码 + 1 ，为 0000 ~ 0000，可见补码消除了关于 0 的二义性，使用补码并不会存在两个 0。 回到上面推算的 int 值得最小值 1111 ~ 1111，其反码为 1000 ~ 0000，补码为 1000 ~ 0001，转换为十六进制为 0x80000001。而这与 Jdk 规定的最小值 MIN_VALUE = 0x80000000 并不相同，说明还遗漏了什么。再回看补码，除了消除二义性，还有个好处是可以把减法当做加法。都知道 01111 ~ 1111 代表正数的最大值，最高位只代表符号，那么将其由 0 变 1，用 1111 ~ 1111 来代表负数的最大值从某种角度上也说得通，补码（1111 ~ 1111） = 十进制（-1），将 补码（1111 ~ 1111） 往前迭代 1 位（做 + 1 的运算），舍弃溢出位，得到 补码（0000 ~ 0000） = 十进制（0），符合 -1 + 1 = 0 的运算结果。将 补码（1111 ~ 1111） 往后迭代 1 位，得到 补码（1111 ~ 1110） = 原码（1000~ 0010） = 十进制（-2），符合 -1 - 1 = -2 的运算结果。则同理，将负数最大值 补码（1111 ~ 1111） 一直往后迭代，直到无法再小，则最小值应为 补码（1000 ~ 000） = 原码（1000 ~ 000） = 十进制（-0） = 十六进制（0x80000000）。也就是原码空出来的那个代表 -0 的数，被计算机用来表示 int 的最小值。 Bitmap 像素提及 Bitmap ，先介绍一下 Android 中Bitmap 类中定义的枚举类 Config 里的几个值，也是比较多见的 Android 中的 Biamap 显示参数。 Bitmap 参数 ARGB_4444 四个通道 A（透明度）、R（红色）、G（绿色）、B（蓝色）各占 4 位，总共 16 位，即每个像素占用 2 个字节。 ARGB_8888 四个通道各占 8 位，总共 32 位，每个像素占用 4 个字节。因为 RGB 通道精度更高，所以颜色显示更丰富，同时占用内存也更大。 RGB_565 没有透明度信息，RGB 通道各占用 5 位、6 位、5 位，总共 16 位，每个像素占用 2 个字节。 知道了每个像素占用的字节长度，就可以计算一张图片显示时所占用的内存大小，以 ARGB_8888 为例，一张像素为 16 16 的图片占用的内存为：16 16 * 4 = 1024 byte，即 1 KB。 轻松愉快又简单！可梦想很美好，显示很骨感。在 Android 中，在不压缩计算的情况下（例如显示 assets 目录下的图片），内存大小就是上面计算所得，但因为 Android 中的图片一般存放在不同的资源目录: 资源目录对应的 dpimdpi -&gt; 120 dpimdpi -&gt; 160 dpihdpi -&gt; 240 dpixdpi -&gt; 320 dpixxdpi -&gt; 480 dpixxxdpi -&gt; 640 dpi Android 中显示不同的资源目录图片时，会对图片做缩放处理，缩放比例为 设备dpi / 资源目录对应 dpi，以 小米8SE 为例，设备屏幕密度为 440 dpi，该设备显示存放在 xxdpi（480dpi）目录中的像素为 300 300 的图片时，实际显示图片的宽和高将换算为 `440 / 480 300 ` （结果四舍五入），计算得到图片在手机显示的宽高为 275，再根据计算所得实际的图片宽高计算所占内存： 1275 * 275 * 4 = 302500（byte） 可以调用 Bitmap 类自带的方法 getByteCount() 方法验证一下。 顺带提一下，Android 中 Bitmap 的占用内存大小与显示图片的容器（例如 Android 上的 ImageView）尺寸无关。 Bitmap 像素的定义介绍完 Bitmap 内存占用大小后，回到 Bitmap 本身来。Bitmap 将图像定义为由像素组成，以 ARGB_8888 为例，上面提到过，A/R/G/B 各占 8 位，各由两个十六进制数表示，依次排列，比如常见的色值 #FF234567，即各通道值为：透明度 alpha 0xFF，红色 red 0x23，绿色 green 0x45，蓝色 blue 0x67。 因此一张分辨率 100 100 的彩色图片，无非就是 100 100 个像素，每个像素显示对应的颜色，所有像素组合在一起便成了彩色的图片。所以只要拿到了 Bitmap，想要如何修改图像的显示，只要对各个像素显示的颜色做相应的处理就好了。 彩色转换为灰色的计算方式暂且不提。要改变图像的显示，首要任务是获取到各像素点的颜色。 Android 中可以调用 Bitmap 类自带的方法获取到具体某个点的像素颜色： 1int color = bitmap.getPixel(200, 300); 那么问题来了，如何才能从一个 int 值中获取各个通道（RGB）的颜色呢？ 从像素中提取各通道色值老司机们可能秒懂，这个简单，Color 类自带的方法就可以做到： 1int redColor = Color.red(color); 再看一下该方法的实现: 1234@IntRange(from = 0, to = 255)public static int red(int color) &#123; return (color &gt;&gt; 16) &amp; 0xFF;&#125; 其实计算方法也很简单，用到了位运算，那就顺带回顾一下位运算。 位运算符从最低位到最高位一一对齐，每一位都做运算（也是对补码做运算），各运算符含义如下： &amp; 与都是 1，则结果为1。否则为 0。 | 或都是 0，则结果为0。否则为 1。 ~ 取反对数的每一位取反。 ^ 异或数值相同，则结果为 0，不为 1。 &gt;&gt;右移从 0 位起整体向右移动，空出的高位正数补 0，负数补1。 &gt;&gt;&gt; 无符号右移从 0 位起（连符号位）整体向右移动，空出的高位一律补 0。对于正数而言，&gt;&gt;和&gt;&gt;&gt;没区别。 &lt;&lt; 左移整体向左移动，右边的空位一律补 0。 现在再来回看上面提到的取色方法：1234// Colorpublic static int red(int color) &#123; return (color &gt;&gt; 16) &amp; 0xFF;&#125; 还以 #FF234567 为例，转换为二进制为1111 1111 | 0010 0011 | 0100 0101 | 0110 0111 （这里我用了 | 符号方便划分），其中 第二阵列 0010 0011，即右起第 17 ~25 位代表红色色值。将二进制右移 16位，等同于舍弃了红色右边 的 16 位用于存储绿色、蓝色的色值，得到 0000 0000 | 0000 0000 | 1111 1111 | 0010 0011，再与 0xFF 即二进制 1111 1111 做与运算，运算时高位为空则补0，与 0 做 &amp;与运算结果必为0，等同于与舍弃了右边代表透明度的高八位，最终得到红色的色值 0010 0011。 取红色色值也还有另一种解法： 1(color &amp; 0x00FF0000) &gt;&gt; 16 先和 0x00FF0000 做与运算，舍弃除红色外所有色值，再右移 16 位得到该值。这种解法与上述的只不过是运算顺序不同，殊途同归。 至此，获取到了色值，想要怎么改变图片的显示就是算法上的事了，各凭本事各显神通。 今天的分享就到这，如有纰漏欢迎指正，下篇博客见。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拥抱 C/C++ : Android JNI 的使用]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%8B%A5%E6%8A%B1-C-C-Android-JNI-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[编译工具 CMake 以及 Android 上 JNI 的使用介绍。 编译工具 CMake在Android Studio 2.2 之后，工具中增加了 CMake 的支持，于是我们有两种选择来编译 c/c++ 代码。一个是 ndk-build + Android.mk + Application.mk 组合，另一个是 CMake + CMakeLists.txt 组合。这2个组合与 Android 代码和 c/c++ 代码无关，只是不同的构建脚本和构建命令。 环境配置Android Studio 的 SDK Tools 安装 CMake LLDB NDK Hello World先新建一个项目，记得要勾选 C++ support，看一下 Android Studio 自动生成的使用了 JNI 的项目是什么样子的。 可以看到，与普通 Android 项目不同的是，支持 C++ 的项目在 app 目录下多了一个 .externalNativeBuild 编译目录与 CMakeLists.txt，main 目录下多了 cpp 目录。 CMakeLists 文件关于 CMakeLists 文件的作用，我的理解是它指定了编译 c++ 库时所用到的一些配置，先来看看项目里 CMakeList.txt 文件： 12345// 去掉注释cmake_minimum_required(VERSION 3.4.1)add_library(native-lib SHARED src/main/cpp/native-lib.cpp )find_library(log-lib log)target_link_libraries(native-lib $&#123;log-lib&#125; ) cmake_minimum_required(VERSION 3.4.1)允许构建的最低版本 add_library(name path)生成链接库，SHARED 表示生成动态库， STATIC表示生成静态库。并指定了参与编译的文件路径 find_library(log-lib log)添加在编译本地文件时依赖的库（log），并指定别名（log-lib） target_link_libraries(lib1 lib2 …)链接库，这里链接了我们自己的库 native-lib 与 log 库 默认的 so 库输出目录为 app/build/intermediates/cmake/debug/obj/${abi} 下，可以在 CMakeLists 中指定输出目录 12#设置生成的so动态库最后输出的路径set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;) 再来看 cpp 目录下的 native-lib.cpp 文件： 12345678910111213#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot;JNIEXPORT jstringJNICALLJava_com_yazhidev_cmakedemo_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; 第一次看到 .cpp 格式的源文件肯定有点摸不着头脑，Java 与 C++ 是如何通信的呢？答案就是 JNI。 JNI 规范 JNI (Java Native Interface,Java本地接口)是一种编程框架,使得 Java 虚拟机中的 Java 程序可以调用本地应用/或库,也可以被其他程序调用。 从上面的 native-lib.cpp 文件我们可以一窥 JNI 中 C/C++ 的使用规范： #includeC 语音中使用 #include &lt;&gt; 直接到系统指定的目录下查找文件，我将其理解为类似 Java 中的导包。JNI 中首先头部需要引入 &lt;jni.h&gt; ，由于使用到了字符串，还导入了 &lt;string&gt;。 JNIEXPORTJNIEXPORT 和 JNICALL 都是 JNI 的关键字，表示此函数是要被 JNI 调用的。 jstring是 JNI 中作为中介使 JAVA 的 String 与 C/C++ 的 String 交互的数据类型，JNI的数据类型包含两种，分别是基本类型和引用类型。 jobject指代调用该方法的对象。如果 Java 中该 native 方法是静态的，则指代该类，即 XXX.class。 JNIEnv这个env可以看做是 JNI 接口本身的一个对象，在头部引入的 jni.h 头文件中存在着大量被封装好的函数，这些函数也是 JNI 编程中经常被使用到的，要想调用这些函数就需要使用JNIEnv这个对象。除了上面使用到的传递返回值给 Java，还有获取类的 class 类型：evn-&gt;GetObjectClass()，改变 Java 中对象的某个变量的值 evn-&gt; SetIntField(...) 等方法。 命名方式Java_com_yazhidev_cmakedemo_MainActivity_stringFromJNI()，JNI 中对命名有规定，命名规范为：Java_包名_class_函数名，包名中的 . 也要改为 _，对应的，在 Java 中引用 Native 函数也需要声明关键字 native。 std::string、NewStringUTF这是 C++ 中字符串的一些写法，需要用时去翻一下语法，不多延伸。 以上只提到了项目里使用到的一些规范和注意点。下面通过写个 demo 实际操作一下。 实战通过 JNI 对图片做变色处理。 jnigraphics 库这里要使用到 NDK 里提供的 jnigraphics 库，该库提供了基于 C/C++ 的接口，可以访问 Android 中的 Bitmap 的像素缓冲区（bitmap buffers）。 头文件中引入 android/bitmap.h，其典型用法如下（摘至 android/bitmap.h 详解）： a) 用 AndroidBitmap_getInfo() 函数从位图句柄（从JNI得到）获得信息（宽度、高度、像素格式）b) 用 AndroidBitmap_lockPixels() 对像素缓存上锁，即获得该缓存的指针。c) 用C/C++ 对这个缓冲区进行读写d) 用 AndroidBitmap_unlockPixels() 解锁 我们利用该用法对 bitmap 做处理。 新建 Module首先新建个 module，并新建类 BitmapUtil： 12345678static &#123; // 不要忘记加载库 System.loadLibrary(&quot;bitmap-util&quot;);&#125;public class BitmapUtil &#123; public static native void processBitmap(Bitmap bitmap;&#125; 并在 main 目录下新建 cpp 目录，新建类 bitmap-util.cpp： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;jni.h&gt;#include &lt;android/bitmap.h&gt;extern &quot;C&quot;JNIEXPORT void JNICALLJava_com_yazhidev_ndkdemo_BitmapUtil_processBitmap(JNIEnv *env, jobject /* this */, jobject bitmap) &#123; //构造 AndroidBitmapInfo AndroidBitmapInfo info = &#123;0&#125;; //将 bitmp 的信息填充给 info AndroidBitmap_getInfo(env, bitmap, &amp;info); int *buf=NULL; //对 bitmap 解码并获取解码后的像素保存在内存中的地址指针，赋值给 srcBuf AndroidBitmap_lockPixels(env, bitmap, (void **) &amp;buf); //处理像素 int w = info.width; int h = info.height; int32_t *srcPixs = (int32_t *) buf; int alpha = 0xFF &lt;&lt; 24; int i, j; int color; int red; int green; int blue; for (i = 0; i &lt; h; i++) &#123; for (j = 0; j &lt; w; j++) &#123; // get the color of per pixel color = srcPixs[w * i + j]; red = ((color &amp; 0x00FF0000) &gt;&gt; 16); green = ((color &amp; 0x0000FF00) &gt;&gt; 8); blue = color &amp; 0x000000FF; color = (red + green + blue) / 3; color = alpha | (color &lt;&lt; 16) | (color &lt;&lt; 8) | color; srcPixs[w * i + j] = color; &#125; &#125; //释放锁定，显示出被修改的像素数据 AndroidBitmap_unlockPixels(env, bitmap);&#125; module 根目录下新建 CMakeLists.txt 文件： 1234cmake_minimum_required(VERSION 3.4.1)add_library(bitmap-util SHARED src/main/cpp/bitmap-util.cpp )# 链接 jnigraphics 库target_link_libraries(native-lib jnigraphics) 在 module 的 build.gradle 中引用 CMakeLists 文件： 12345678android &#123; ... externalNativeBuild &#123; cmake &#123; path &quot;CMakeLists.txt&quot; &#125; &#125;&#125; Java 中调用： 12345// Kotlin image -&gt; ImageView(android:id=&quot;@+id/image&quot;)val drawable = resources.getDrawable(R.mipmap.google) as BitmapDrawableval bitmap = drawable.bitmapBitmapUtil.processBitmap(bitmap)image.setImageBitmap(bitmap) 遇到的问题java.lang.UnsatisfiedLinkError: No implementation found extern “C” 扩展项目中导入 so 库在使用 JNI 时有时可能只有编译好的 so 库，那么如何在项目中使用 so 库呢？ 右键 app 目录，选择 new - Folder -JNI Folder，新建一个 JNI 目录用于存放 so 文件。 so 库（CPU）的兼容使用 CMake 编译 so 库时，可通过配置 gradle 文件指定编译的 so 库架构 1234567891011android &#123; defaultConfig &#123; externalNativeBuild &#123; cmake &#123; cppFlags &quot;&quot; // 生成.so库的目标平台 abiFilters &quot;armeabi-v7a&quot;, &quot;armeabi&quot;, &quot;x86&quot; &#125; &#125; &#125;&#125; 对于CPU来说，不同的架构并不意味着一定互不兼容，根据目前Android共支持七种不同类型的CPU架构，其兼容特点可总结如下： armeabi设备只兼容armeabi；armeabi-v7a设备兼容armeabi-v7a、armeabi；arm64-v8a设备兼容arm64-v8a、armeabi-v7a、armeabi；X86设备兼容X86、armeabi；X86_64设备兼容X86_64、X86、armeabi；mips64设备兼容mips64、mips；mips只兼容mips； 根据以上的兼容总结，我们还可以得到一些规律：armeabi的SO文件基本上可以说是万金油，它能运行在除了mips和mips64的设备上，但在非armeabi设备上运行性能还是有所损耗；64位的CPU架构总能向下兼容其对应的32位指令集，如：x86_64兼容X86，arm64-v8a兼容armeabi-v7a，mips64兼容mips。 更多 so 文件的信息可参考：Android SO文件的兼容和适配 参考AndroidStudio项目CMakeLists解析JNI技术规范Android NDK之旅——图片高斯模糊Jni接口-深入研究参数的传递（一）android/bitmap.h 详解]]></content>
      <tags>
        <tag>Android</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 入门]]></title>
    <url>%2F2018%2F08%2F18%2FNginx%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Docker 部署 Nginx，以及 Nginx 反向代理的配置。 Docker 部署 Nginx12345docker container run \ -d \ -p 8099:80 \ --name mynginx \ nginx 以上命令会部署一个 nginx 容器， 各参数含义： -d后台运行 -p 8099:80容器的 80 端口映射宿主的 8099 的端口 --name mynginx指定容器的名字为 mynginx 部署成功后，访问 IP:8099 ，即可看到 nginx 的默然欢迎页。 挂载宿主目录Nginx 容器的默认配置文件位于 /etc/nginx/conf.d/default.conf，其默认配置的地址为 /usr/share/nginx/html/index.html 为了更加直观地看到是否成功挂载目录，我们新建一个 html 文件代替 Nginx 的默然欢迎页。 首先在宿主中新建目录 mkdir /nginx-demo/html/，并在该目录下新建一个 html 文件 vim index.html，输入 &lt;h1&gt;Hello World&lt;/h1&gt; 并保存。重新运行一下容器：1234567docker container run \ -d \ -p 8099:80 \ -v /nginx-demo/html/:/usr/share/nginx/html \ --rm \ --name mynginx \ nginx 现在访问 IP:8099 应该就可以看到 hello world 了。 -v 宿主目录:容器目录 命令即可实现目录挂载。 映射配置目录把容器 mynginx 的 /etc/nginx 拷贝到宿主 /nginx-demo/conf 目录1docker cp mynginx:/etc/nginx /nginx-demo/conf 可以把配置修改后再挂载到容器中，已解决 Nginx 容器中无法使用 vim 命令的问题。 代理其他容器连接容器 --link tomcat001:t01 -–link 表示当前命令启动的容器要和另一个名叫 tomcat001 的容器建立连接，tomcat001:t01 中的 t01 表示 t01 是连接建立后 tomcat001 的别名，或者可以理解为容器启动后，在容器的 /etc/hosts 文件中加入了一条记录，ip 是 tomcat001 的 ip，name 是 t01。 我们输入 docke exec -it mynginx /bin/bash 登录 mynginx，再输入 cat /etc/hosts 即可看到 t01 指代的 ip 地址。 另外在容器内使用 env 可查看环境变量 1T01_PORT_8080_TCP_PORT=8080 //可以看到容器t01端口为8080 反向代理，负载均衡修改 /etc/nginx/con.f/default.conf 配置文件 12345678910111213upstream mytomcat&#123; //如果代理多个容器可以配置 weight 权重实现负载均衡 server t01:8080 weight=1; &#125;server &#123; ... location / &#123; # 注释之前的 root、index # 添加 proxy_pass http://mytomcat; &#125; &#125; 重新运行一下容器 123456789docker container run \ -d \ -p 8099:80 \ -v /nginx-demo/html/:/usr/share/nginx/html \ -v /nginx-demo/conf/:/etc/nginx \ --rm \ --name mynginx \ --link tomcat001:t01 \ nginx 这时访问 IP:8099 已不再指向原来的 hello world 页面，而是反向代理到了 tomcat 的主页。 其他docker 已关闭，却依然可以访问 nginx 页面？可能是浏览器缓存 代理宿主机一番操作后突然想到，直接在部署 nginx 时映射主机的 80 端口不就可以了 (:з」∠) 。 参考阮一峰 Nginx 容器教程 等等]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义构建类型 BuildType]]></title>
    <url>%2F2017%2F12%2F21%2FAndroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B-BuildType%2F</url>
    <content type="text"><![CDATA[简单介绍了 BuildType 定义在 app 项目与 module 项目的区别，以及在 Gradle 2.x 与 3.x 版本的区别。 最近接触到自定义构建类型 BuildType，发现这一块有些地方稍不注意的话会被绕进去浪费点时间，既然我这边已经花费时间了，如果正好你也需要接触到 BuildType，也许接下来分享的 tips 可能会帮你节省些时间。 缘起BuildType 相信许多开发者都不陌生，很常见的一种使用场景是线上、线下的后台接口 BaseUrl 不同，许多人会选择在 build.gradle 文件的 buildTypes 中定义全局变量来实现线上线下环境的定义(Gradle 2.x 版本)，例如： 12345678buildTypes &#123; debug &#123; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://debug.api/\&quot;&quot; &#125; release &#123; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://release.api/\&quot;&quot; &#125;&#125; 在开发过程中，除了默认的 Debug 和 Release 版本，我们可能还需要为程序自定义一些东西。比如在上线 release 版本前，还需要一个预发布版本，该版本除了后台接口的 BaseUrl 与线上版本不同外，其他资源（包括数据库环境）都与线上相同，该版本用来做发布前的最后测试，最大程度避免线上环境出问题。如果每次打预发版本都去直接修改代码中的 BaseUrl 很明显不是最优解。有一种解决方案是自定义 BuildType，在 app 模块下的 build.gradle 的 buildTypes 中自定义新的构建版本： 12345678910111213141516buildTypes &#123; debug &#123; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://debug.api/\&quot;&quot; &#125; release &#123; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://release.api/\&quot;&quot; &#125; pre.initWith(release) pre &#123; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://pre.api/\&quot;&quot; &#125;&#125;//java 类中调用 BuildConfig.BASE_URL 获取定义的变量 initWith() 是 BuildType 的一项配置项，我们还可以看到上文中提到的buildConfigField其实也是一项配置项。该配置可以理解成initWith(release) 可以理解成拷贝了 release 这一构建类型的所有变量，因为我们知道，每一个构建类型都有一些默认的变量，例如debuggable、zipAlignEnabled等，使用该配置就免去为新增的构建类型定义所有的变量。定义了新的构建类型后，gradle会自动生成新的task，使用gradle assemblePre即可打包新定义的预发包。这里需要稍微注意的地方就是，必须在 app 模块下的 build.gradle 中定义新的构建类型，gradle 才会生成新的task。 Moduel 中自定义 BuildType 的问题随着现在模块化开发越来越流行，许多项目都会将一些业务无关的模块独立出去，作为 Moduel 在项目中依赖使用，以此达到复用的效果。很常见的例如网络库可能就会被独立出来，那么上文中的关于就会被定义在子 Module 中。这里不注意的话就会浪费一些时间。假设你在 app 模块与子模块的 build.gradle 的 buildTypes 中都如上文定义了三种类型 debug 、release、pre 版本的BASE_URL，请注意： 如果你执行了gradle assemblePre，没错是构建了 pre 版本，但是打印出日志你会发现： 12app.BuildConfig.BASE_URL = &quot;https://pre.api/&quot;module.BuildConfig.BASE_URL = &quot;https://release.api/&quot; 子模块中如果没有特别指定构建版本，无论你执行的是gradle assemblePre还是gradle assembleDebug，构建的都是 release 版本。可以使用defaultPublishConfig配置指定需要构建的版本，例如在子模块的 build.gradle 中指定： 123456android &#123; ... //指定构建版本 defaultPublishConfig &quot;pre&quot; ...&#125; 当然最好设置个变量，否则如果有许多子模块，不可能修改构建版本时一个一个改过去，常用的是在项目最外层的 build.gradle 中设置变量供子模块调用： 12345678910111213buildscript &#123; ... dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.3&apos; &#125; ...&#125;ext &#123; projectBuildType = &quot;debug&quot;&#125;//子模块中引用变量defaultPublishConfig rootProject.ext.projectBuildType 这里需要注意，一旦子模块中指定了构建类型，例如 pre 版本，则该模块的 buildTypes 中必须也要有对应的构建类型 pre，否则编译不通过。并且，一旦指定了构建类型，则该模块的构建类型就只会是指定的类型。举个栗子：子模块中指定了defaultPublishConfig &quot;pre&quot;,执行gradle assembleRelease，打印日志： 12app.BuildConfig.BASE_URL = &quot;https://release.api/&quot;module.BuildConfig.BASE_URL = &quot;https://pre.api/&quot; 所以这里就会比较烦人，每次打不同的包都需要去修改projectBuildType的值，还是需要手动修改。 分支名决定构建的版本类型想要隔离手动修改，网上看到过一种解决方案：子模块的 build.gradle 中设置： 123android &#123; publishNonDefault true&#125; 然后在模块的依赖处，例如 app 模块的 build.gradle 中改进依赖的写法： 12releaseCompile project(path: &apos;:module&apos;, configuration: &apos;release&apos;)debugCompile project(path: &apos;:module&apos;, configuration: &apos;debug&apos;) 这样就可以实现构建时子模块与 app 模块的类型一致。但这种写法太烦了，如果你有十来个依赖，还得一个一个写过去，又如果你还自定义了不止一种构建类型，且没新增一个新的 buildType 都得修改所有的依赖，我认为也不是最优解。 这里提供一个方案仅供参考。先介绍一下我们的开发流程，例如新开发1.0版本。首先从 master 切出一条 devel1.0 分支用于前期开发阶段，开发完毕达到上线标准后，切出一条 pre1.0 预发分支，打预发包做最后测试并做最后的 bug 修复，最后测试通过，合并代码到 master 分支，打线上包发布至应用商店。不同阶段对应不同的分支，所以不同的构建版本可以通过分支名来决定，git 肯定可以获取当前分支名，而 grale 中则可以执行 cmd 命令，二者结合即可达到想要的效果。有这个思路后实现起来就很简单： 1234567891011ext &#123; projectBuildType = &quot;debug&quot; def gitBranchName = &quot;git rev-parse --abbrev-ref HEAD&quot;.execute().text.trim() if(gitBranchName.contains(&quot;master&quot;)) &#123; projectBuildType = &quot;release&quot; &#125; else if(gitBranchName.contains(&quot;pre&quot;)) &#123; projectBuildType = &quot;pre&quot; &#125;&#125; Gradle 3.0.0 带来的问题Android Studio 3.0 + Gradle 3.0 相信许多人都跃跃欲试。升级到 Gradle 3.0 可能需要做一些改动，详情可见Migrate to Android Plugin for Gradle 3.0.0。Gradle3.0 中自定义 BuildType 有需要注意的地方 Cause of build error Your app includes a build type that a library dependency does not. 在 Gradle 2.x 时代，如果 app 中定义了 pre 类型，而子模块中没有定义，是不会报错的。但在 Gradle 3.0 下，如果你的 app 包含了新的自定义的 buildType，而依赖库中却没有相应的自定义 buildType，则编译阶段就会报错。 一种解决方案是在子模块里也定义 app 中的所有 buildType，当然，项目里依赖多的同学肯定要吐槽了：我懒！不想修改辣么多东西！这里 Gradle 也提供了比 2.x 时代更智能的兼容方案：matchingFallbacks 在 buildTypes 中定义 matchingFallbacks，可以指定在子模块中没找到对应的构建类型时要加载哪个类型 12345678910111213141516//app 模块下的 build.gradle 中buildTypes &#123; debug &#123; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://debug.api/\&quot;&quot; &#125; release &#123; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://release.api/\&quot;&quot; &#125; pre.initWith(release) pre &#123; buildConfigField &quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://pre.api/\&quot;&quot; matchingFallbacks = [&apos;pre&apos;, &apos;debug&apos;, &apos;release&apos;] &#125;&#125; matchingFallbacks 可以定义多个构建类型，当执行gradle assemblePre 构建 Pre 版本时，而恰巧某个子模块又没有定义 pre 版本，则会一一按照你指定的 matchingFallbacks 从前往后依次寻找，直到类型匹配。这种匹配方案比 Gradle 2.x 时代默认为你构建 release 版本要智能的多，至少我们还可以根据变量来在构建不同类型时定义不同的匹配顺序。并且我们也可以抛弃掉前文提到的defaultPublishConfig配置了，因为 Gradle 3.x 中，只要 gradle 构建时，子模块的构建类型变成了与 app 构建类型一致了（前提是子模块中也定义了该类型），变得更加灵活。 技术终归是在向前发展的。关于自定义 BuildType 的一些使用小贴士就是这些了，至于更多的关于构建类型相关的知识，例如 buildTypes 结合 productFlavors，或是定义 sourceSets 属性指定不同的代码目录、资源文件目录等知识以后有机会再开一篇聊吧（又挖坑2333）。 啰嗦了一堆，权且算是抛砖引玉。吼啦，下篇博客见~]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins 持续集成实现 Android 自动化打包]]></title>
    <url>%2F2017%2F10%2F29%2FJenkins-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E7%8E%B0-Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[打 debug 包流程： git pull 分支最新代码 Android Studio：Build - Generate Signed APK 从 IDE 里可以看到，实际上该操作是执行了 assembleDebug，在打包完成后再将编译目录下的 apk 包安装到调试的手机上并运行。 拷贝了工作目录下 app/build/outputs/apk 文件夹下的 apk 安装包交付测试 显而易见这些是很枯燥、重复且浪费时间的工作，而一切重复的工作皆可自动化。我们选择使用 Jenkins 这一已经很成熟的持续集成方案来实现自动化打包。 初识 Jenkins What is Jenkins?Jenkins is a self-contained, open source automation server which can be used to automate all sorts of tasks related to building, testing, and deploying software. Jenkins 说白了其实就是后台服务加上 web 管理配置页面。Jenkins 里，每个任务称为 Job，所以简单的说，持续集成的实质就是通过 web 页面构建一个或多个任务，然后通过后台服务持续、自动地执行这些任务。 安装教程因为 Jenkins 是基于 Java 开发的（但不仅限于构建基于 Java 开发的软件），所以运行 Jenkins 需要配置 Java 环境。 下载 Jenkins 安装包。Jenkins 下载地址。虽然官方也提供了各个平台的安装包（例如 Mac 端 的 pkg 文件，但个人认为直接下载 war 包自行使用命令安装更为方便） 在安装包所在目录运行命令：12345678//默认运行在8080端口java -jar jenkins.war //如果报错误为端口号已被占用，先查看端口号（例如8081端口）被什么程序占用lsof -i tcp:8081//记住服务的 PID 号（例如8123），强制 kill 相应服务sudo kill 8123//或直接指定未被占用端口运行java -jar jenkins.war --httpPort=2333 Jenkins 就启动成功了。 浏览器中进入 Jenkins web 配置页面：http://localhost:8081。 第一次启动时在控制台会输出一串密钥用于首次登陆验证。当然，如果懒得翻控制台打印出的命令，也可以直接到本地的 Jenkins 安装目录去找（Mac 上一般为 用户目录下的/.jenkins/secrets/initialAdminPassword）。该密钥同时也是 Jenkins 初始账号 admin 的密码。 输入密钥之后会出现如下让用户选择安装插件的选项。如果是第一次接触的同学可能会有点懵。所以这里建议点击右上角关闭，直接进入 Jenkins。后续再根据需求安装插件。 构建 Job准备工作成功进入 Jenkins 后，我们就可以开始构建任务啦。但是在此之前，还需要为 Jenkins 配置相应的环境，以及安装需要用到的插件。 安装插件左侧选择系统管理 - 插件管理 - 可选插件，搜索并安装插件。 必装插件： Gradle Plugin GitLab Plugin 建议安装的插件： build-name-setter （用于自定义每次构建的名字） Build Timestamp Plugin （比较好用的时间戳插件） tips：如果插件管理里显示可更新、可选插件都为空，前往插件管理 - 高级 - 滑动到最下方的升级站点，将地址替换为http://mirror.xmission.com/jenkins/updates/update-center.json。 配置环境还需要配置一下环境变量，在系统设置 - 全局变量里添加一个 Android Sdk 的目录。 ANDROID_HOME = android sdk 所在目录 配置 GitLab 服务器在配置服务器之前，需要先配置一下证书。 左侧菜单 Credentials - System - Add domain 添加一个证书，Domain Name 输入名字后点击 OK，再点击 adding some credentials 添加有访问代码权限的账户的 token，Kind 栏选择 GitLab API Token，Api token 一栏填入账户的 token，token 的获取方式为 GitLab - User Settings - Private Token。 接着配置一下服务器。左侧 系统管理 - 系统设置，安装 GitLab 插件之后会看到新增了一栏 GitLab，在这里配置一下源码服务器。 Host Url 填写服务器地址：http://xxx.xx.xx.xxx:9000/。 Credentials 选择刚才添加的证书。然后点击右下方的 Test Connection，不出意外的话就可以连接成功了。 添加 SSH配置好服务器后，还需要配置用于访问服务器的私钥 。SSH 协议规定远程主机在用户发起请求后，会发送一串随机字符串回来，用户使用本地存储的私钥对字符串进行加密后又发送回来，远程主机再使用用户事先配置的公钥比对加密后的字符串，以此来鉴定本次访问是否可信。因此，用于获取源码的服务器上必须配置用于远程登录服务器的 SSH 私钥。 左侧菜单 Credentials - System - Add domain 添加一个证书，Domain Name 输入名字后点击 OK，再点击 adding some credentials 添加有访问代码权限的账户的私钥，Kind 栏选择 SSH username with private key，Private Key 栏有多种方式可选，这里选择直接输入私钥，选择 Enter directly，直接复制私钥内容到输入框中（私钥位置：用户目录/.ssh/ 下的 id_rsa 文件，直接复制文件的所有内容），其他都不用填，点击保存。 构建第一个任务点击左侧菜单栏 - 新建，新建一个任务 这里看到了两个选项。多配置项目，顾名思义，更适用于有上下游任务、多个项目联动的任务，该项目相比自由风格的软件项目新增了些可选配置，例如上游项目正在构建时阻止该项目构建、使用自定义工作空间等。 我们先选择自由风格的软件项目来试试手。输入项目名后可以看到整个配置页面了。最上方 GitLab connection 一栏选择刚配置的 GitLab。源码管理一栏选择 Git，配置一下项目地址。 Repository URL 填写项目地址：git@git.xxxx.com:xxx/xxxx.。 Credentials 一栏选择之前添加的 SSH。 Branches to build 一栏填写从哪个分支获取，例如从主分支：*/master 配置好之后，滑到最下方应有并保存。之后点击左侧菜单 - 立刻构建试一下吧。如果看到任务被成功构建那就说明已经成功从服务器拉取源码啦。 编译项目进入 Job，左侧菜单 - 配置，在构建一栏增加构建步骤，选择 Invoke Gradle Script - 选择 Invoke Gradle，并在下方的 Tasks 中配置要执行的命令。比如打测试包命令： 12cleanassembleDebug //如果项目中配置了 productFlavors，打包命令需要相应地更换为你需要打包的版本 配置完成后，一样的进入到项目的 app/build/outputs/apk 目录下就可以看到打好的 debug 包。项目位置位于：用户目录/.jenkins/workspace/xxx 。 当然，你也可以自己执行项目的工作目录。在 Job 的编辑页，滑动到最上方， General 选项卡最顶端点击 高级 按钮，可以看到选项：使用自定义的工作空间，例如： 12目录：workspace/work/testProject显示名称：testProject 实现自动化常见的自动化执行配置方法：进入 Job，左侧菜单 - 配置 - 构建触发器： 定时执行有两个比较相似的行为： Build periodically ：周期性地执行构建 Poll SCM ：检查源码变更，如果有变更则拉取源码并执行构建 二者都需要在下方的日程表中填写定时规则。 日程表编写规则简要介绍一下定时编写规则： 规则由5个参数组成，每个参数之间以空格间隔（单个参数里不可以包含空格），例如： 。 号代表忽略该参数。 五个参数从左起分别代表：分（范围0 ~ 59）、时（范围0 ~ 23）、天（范围1 ~ 31）、月（范围1 ~ 12）、星期（范围0 ~ 7，0/7均代表周日） 同个参数可以指定多个数，以英文逗号分隔（注意不要带空格），例如：2,3,5 ；可以指定连续数：2-5（等同于 2,3,4,5） 举几个例子直观地看一下： 123H 10 * * * //每天10点整点。等同于 0 10 * * * ，如果分的参数输入0，会建议你使用 H 替代。20 8,10,18 * 11,12 1-4 //11、12两个月的周一到周四的每天8点20、10点20、18点20。 GitLab Hook构建触发器选择：Build when a change is pushed to GitLab. GitLab CI Service URL: http://localhost:8081/xxx/xxx 这个需要在 GitLab 的源码项目里配置一下上面提到的地址，这样源码在接收到 push 事件时会通知 Jenkins 执行构建。因为没有将 Jenkins 发布到外网，所以可以看到上面提供的 hook 的地址也只是个本地的 localhost 的地址，填写这个地址外网是无法通知到的。这里暂时没有测试该特性。 基于上游项目的构建构建触发器选择：Build after other projects are built。并填写上游项目的 Job 名称。还可以基于上游项目的构建情况，是否成功、失败来构建自身。 基本上这些操作已经可以使整个自动化打包流程运行起来了。 关闭服务采用 Jenkins CLI的方式来关闭Jenkins。 左侧菜单 - 系统设置 - Jenkins CLI。下载 jenkins-cli.jar 之后，通过使用命令控制 Jenkins，例如： 1java -jar jenkins-cli.jar -s http://localhost:8081/ shutdown //关闭 Jenkins 服务 如果执行该命令时报没有权限的错误，则需要为 admin 账号配置一下权限。 另外网络上很多提到直接在链接后加上相应的操作，例如 exit、restart、reload等，例如访问 http://localhost:8081/exit 代表退出 Jenkins，但估计很多人会遇到一下问题： 此类跳转失败的错误原因是 Jenkins 在 http 请求头部中放置了一个名为.crumb的token，在使用了反向代理，并且在设置中勾选了“防止跨站点请求伪造”之后此 token 会被转发服务器认为是不合法头部而去掉，导致跳转失败。解决方法就是左侧菜单 - 系统管理 - Configure Global Security 中取消勾选 防止跨站点请求伪造 权限配置问题如果因为设置错误而收回了配置权限，导致 admin 账号连主页都无法进入，解决的方法就是直接到 Jenkins 安装目录里修改配置文件。 进入安装目录（用户目录/.jenkins）/config.xml，修改 useSecurity 栏目，修改为任何用户可以做任何事： 123456&lt;useSecurity&gt;true&lt;/useSecurity&gt; &lt;authorizationStrategy class=&quot;hudson.security.AuthorizationStrategy$Unsecured&quot;/&gt; &lt;securityRealm class=&quot;hudson.security.HudsonPrivateSecurityRealm&quot;&gt; &lt;disableSignup&gt;true&lt;/disableSignup&gt; &lt;enableCaptcha&gt;false&lt;/enableCaptcha&gt; &lt;/securityRealm&gt; 展望以上的自动化打包流程实际上还有可以改进的地方，例如每次测试人员都需要从 Jenkins 服务器上拷贝 apk 安装包，这一流程也应该自动化实现，比如使用脚本自动将 apk 安装包上传至公司 FTP 服务器，或者上传至第三方软件分发服务商，例如蒲公英、Fir 等，还可以将下载地址转换为二维码显示在相应的 Job 页，测试人员直接扫码安装即可。 以及 Jenkins 的其他功能的扩展，例如构建发生错误时自动将日志发送至相关开发人员的邮箱，使开发人员可以更快更及时地响应问题。 以及如果项目有编写单元测试，可以使用 Jenkins 周期性地自动运行单元测试，及早发现新引入的问题。 Jenkins 是一个工具，同时也代表着一种思想，它告诉了我们： 懒是第一生产力 ：P。 以上。]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 沉浸式状态栏的实现]]></title>
    <url>%2F2017%2F08%2F22%2FAndroid-%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一提到沉浸式状态栏，第一个浮现在脑海里的词就是“碎片化”。碎片化是让 Android 开发者很头疼的问题，相信没有哪位开发者会不喜欢“write once, run anywhere”的感觉，碎片化让我们不得不耗费精力去校验代码在各个系统版本、各个机型上是否有效。因此以前我一直把沉浸式状态栏看作一块难啃的骨头，但是该面对的问题迟早还是要面对，所以，不如就此开始吧。 沉浸式状态栏的实现方法一：通过设置 Theme 主题设置状态栏透明因为 API21 之后（也就是 android 5.0 之后）的状态栏，会默认覆盖一层半透明遮罩。且为了保持4.4以前系统正常使用，故需要三份 style 文件，即默认的values（不设置状态栏透明）、values-v19、values-v21（解决半透明遮罩问题）。 1234567891011121314151617//valuse&lt;style name=&quot;TranslucentTheme&quot; parent=&quot;AppTheme&quot;&gt;&lt;/style&gt;// values-v19。v19 开始有 android:windowTranslucentStatus 这个属性&lt;style name=&quot;TranslucentTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;&lt;/style&gt;// values-v21。5.0 以上提供了 setStatusBarColor() 方法设置状态栏颜色。&lt;style name=&quot;TranslucentTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt; &lt;!--Android 5.x开始需要把颜色设置透明，否则导航栏会呈现系统默认的浅灰色--&gt; &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 由图可见，设置之后布局的内容延伸到了状态栏。但有些场景下，我们还是需要状态栏那块位置存在的（然而不存在的）。有三种解决方法： 法一：设置 fitsSystemWindows 属性引用一下官方对该属性的解释吧： android:fitsSystemWindows Boolean internal attribute to adjust view layout based on system windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity. 当该属性设置 true 时，会在屏幕最上方预留出状态栏高度的 padding。 在布局的最外层设置 android:fitsSystemWindows=&quot;true&quot; 属性。当然，也可以通过代码设置： 123456789101112/** * 设置页面最外层布局 FitsSystemWindows 属性 * @param activity * @param value */public static void setFitsSystemWindows(Activity activity, boolean value) &#123; ViewGroup contentFrameLayout = (ViewGroup) activity.findViewById(android.R.id.content); View parentView = contentFrameLayout.getChildAt(0); if (parentView != null &amp;&amp; Build.VERSION.SDK_INT &gt;= 14) &#123; parentView.setFitsSystemWindows(value); &#125;&#125; 通过该设置保留状态栏高度的 paddingTop 后，再设置状态栏的颜色。就可以达到设想的效果。但这种方式实现有些问题，例如我们想设置状态栏为蓝色，只能通过设置最外层布局的背景为蓝色来实现，然而一旦设置后，整个布局就都变成了蓝色，只能在下方的布局内容里另外再设置白色背景，而这样就存在过度绘制了。而且设置了 fitsSystemWindows=true 属性的页面，在点击 EditText 调出 软键盘时，整个视图都会被顶上去。 法二：布局里添加占位状态栏法一：在根布局加入一个占位状态栏，这样虽然整个内容页面时顶到头的，但是因为在内容布局里添加了一个占位状态栏，所以效果与设想的一致。 12345&lt;View android:id=&quot;@+id/statusBarView&quot; android:background=&quot;@color/blue&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt;&lt;/View&gt; 通过反射获取状态栏高度： 12345678910111213/** * 利用反射获取状态栏高度 * @return */public int getStatusBarHeight() &#123; int result = 0; //获取状态栏高度的资源id int resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; result = getResources().getDimensionPixelSize(resourceId); &#125; return result;&#125; 设置占位视图高度 123View statusBar = findViewById(R.id.statusBarView);ViewGroup.LayoutParams layoutParams = statusBar.getLayoutParams();layoutParams.height = getStatusBarHeight(); 当然，除了从布局文件中添加这一方式之外，一样可以在代码中添加。比较推荐使用代码添加的方式，方便封装使用。 12345678910111213/** * 添加状态栏占位视图 * * @param activity */private void addStatusViewWithColor(Activity activity, int color) &#123; ViewGroup contentView = (ViewGroup) activity.findViewById(android.R.id.content); View statusBarView = new View(activity); ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity)); statusBarView.setBackgroundColor(color); contentView.addView(statusBarView, lp);&#125; 法三：代码中设置 paddingTop 并添加占位状态栏手动给根视图设置一个 paddingTop ，高度为状态栏高度，相当于手动实现了 fitsSystemWindows=true 的效果，然后再在根视图加入一个占位视图，其高度也设置为状态栏高度。 123456789101112131415//设置 paddingTopViewGroup rootView = (ViewGroup) mActivity.getWindow().getDecorView().findViewById(android.R.id.content);rootView.setPadding(0, getStatusBarHeight(mActivity), 0, 0);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; //5.0 以上直接设置状态栏颜色 activity.getWindow().setStatusBarColor(color);&#125; else &#123; //根布局添加占位状态栏 ViewGroup decorView = (ViewGroup) mActivity.getWindow().getDecorView(); View statusBarView = new View(activity); ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity)); statusBarView.setBackgroundColor(color); decorView.addView(statusBarView, lp);&#125; 个人认为最优解应该是第三种方法，通过这种方法达到沉浸式的效果后面也可以很方便地拓展出渐变色的状态栏。 方法二：代码中设置通过在代码中设置，实现方法一中在 Theme 主题样式里设置的属性，便于封装。 12345678910111213141516 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; int flagTranslucentStatus = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS; int flagTranslucentNavigation = WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; Window window = getWindow(); WindowManager.LayoutParams attributes = window.getAttributes(); attributes.flags |= flagTranslucentNavigation; window.setAttributes(attributes); getWindow().setStatusBarColor(Color.TRANSPARENT); &#125; else &#123; Window window = getWindow(); WindowManager.LayoutParams attributes = window.getAttributes(); attributes.flags |= flagTranslucentStatus | flagTranslucentNavigation; window.setAttributes(attributes); &#125;&#125; 但是从图片中也看到了，该方案会导致一个问题就是导航栏颜色变灰。经测试，在 5.x 以下导航栏透明是可以生效的，但 5.x 以上导航栏会变灰色（正常情况下我们期望导航栏保持默认颜色黑色不变），但因为设置了FLAG_TRANSLUCENT_NAVIGATION，所以即使代码中设置 getWindow().setNavigationBarColor(Color.BLACK); 也是不起作用的。但如果不设置该 FLAG ，状态栏又无法被置为隐藏和设置透明。 方案二：全屏模式的延伸通过设置 FLAG ，让应用内容占用系统状态栏的空间，经测试该方式不会影响对导航栏的设置。 123456789101112131415161718192021222324252627282930/** * 通过设置全屏，设置状态栏透明 * * @param activity */private void fullScreen(Activity activity) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; //5.x开始需要把颜色设置透明，否则导航栏会呈现系统默认的浅灰色 Window window = activity.getWindow(); View decorView = window.getDecorView(); //两个 flag 要结合使用，表示让应用的主体内容占用系统状态栏的空间 int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE; decorView.setSystemUiVisibility(option); window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.setStatusBarColor(Color.TRANSPARENT); //导航栏颜色也可以正常设置// window.setNavigationBarColor(Color.TRANSPARENT); &#125; else &#123; Window window = activity.getWindow(); WindowManager.LayoutParams attributes = window.getAttributes(); int flagTranslucentStatus = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS; int flagTranslucentNavigation = WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION; attributes.flags |= flagTranslucentStatus;// attributes.flags |= flagTranslucentNavigation; window.setAttributes(attributes); &#125; &#125;&#125; 验证其他使用场景侧滑菜单使用 AS 自动创建 Navigation Drawer Activity ，布局结构为： DrawerLayout include ：内容布局，默认使用 ToolBar NavigationView ：侧滑布局 这里只调用了 fullScreen()， 测试一下运行结果如何： 可以看到都有不尽如人意的地方，4.4 系统中内容视图是可以正常延伸到状态栏中，但侧滑菜单中却在上方出现了白条，而在 6.0 中侧滑菜单上会有半透明遮罩。针对 6.0 侧滑菜单半透明遮罩问题，通过设置为 NavigationView 设置属性 app:insetForeground=&quot;#00000000&quot; 即可解决。针对 4.4 侧滑菜单白条问题，经过测试，通过对最外层布局设置 setFitsSystemWindows(true) 和 setClipToPadding(false) 可以解决，所以这里对之前的 fitsSystemWindows 方法稍加修改： 123456789101112131415161718 /** * 设置页面最外层布局 FitsSystemWindows 属性 * * @param activity */private void fitsSystemWindows(Activity activity) &#123; ViewGroup contentFrameLayout = (ViewGroup) activity.findViewById(android.R.id.content); View parentView = contentFrameLayout.getChildAt(0); if (parentView != null &amp;&amp; Build.VERSION.SDK_INT &gt;= 14) &#123; //布局预留状态栏高度的 padding parentView.setFitsSystemWindows(true); if (parentView instanceof DrawerLayout) &#123; DrawerLayout drawer = (DrawerLayout) parentView; //将主页面顶部延伸至status bar;虽默认为false,但经测试,DrawerLayout需显示设置 drawer.setClipToPadding(false); &#125; &#125;&#125; 这样是解决了上述的问题，既然延伸内容没问题了，那就开开心心地像上面一样调用 addStatusViewWithColor() 方法增加个占位状态栏，解决一下内容顶到头的问题吧： 可以看到，效果依然不是我们想要的，虽然占位状态栏是有了，但是却也覆盖到了侧滑菜单上，并且即使设置了 android:fitsSystemWindows=&quot;true&quot; 也并没有什么卵用，内容布局依然顶到了头部。这里有两种解决方法：1. 第一种方案是网上提到比较多的，改变 ToolBar 的高度，并增加状态栏高度的 paddingTop，这也是 ImmersionBar 库采用的方案。2. 第二种方案其实思路与第一种差不多，就是将原有的内容布局从 DrawerLayout 中移除，并添加到线性布局（布局中已有占位状态栏），之后再将这个线性布局添加到 DrawerLayout 中成为新的内容布局，此谓狸猫换太子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 是否是最外层布局为 DrawerLayout 的侧滑菜单 * @param drawerLayout 是否最外层布局为 DrawerLayout * @param contentId 内容视图的 id * @return */public StatusBarUtils setIsDrawerLayout(boolean drawerLayout, int contentId) &#123; mIsDrawerLayout = drawerLayout; mContentResourseIdInDrawer = contentId; return this;&#125;/** * 添加状态栏占位视图 * * @param activity */private void addStatusViewWithColor(Activity activity, int color) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; if (isDrawerLayout()) &#123; //要在内容布局增加状态栏，否则会盖在侧滑菜单上 ViewGroup rootView = (ViewGroup) activity.findViewById(android.R.id.content); //DrawerLayout 则需要在第一个子视图即内容试图中添加padding View parentView = rootView.getChildAt(0); LinearLayout linearLayout = new LinearLayout(activity); linearLayout.setOrientation(LinearLayout.VERTICAL); View statusBarView = new View(activity); ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity)); statusBarView.setBackgroundColor(color); //添加占位状态栏到线性布局中 linearLayout.addView(statusBarView, lp); //侧滑菜单 DrawerLayout drawer = (DrawerLayout) parentView; //内容视图 View content = activity.findViewById(mContentResourseIdInDrawer); //将内容视图从 DrawerLayout 中移除 drawer.removeView(content); //添加内容视图 linearLayout.addView(content, content.getLayoutParams()); //将带有占位状态栏的新的内容视图设置给 DrawerLayout drawer.addView(linearLayout, 0); &#125; else &#123; //设置 paddingTop ViewGroup rootView = (ViewGroup) mActivity.getWindow().getDecorView().findViewById(android.R.id.content); rootView.setPadding(0, getStatusBarHeight(mActivity), 0, 0); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; //直接设置状态栏颜色 activity.getWindow().setStatusBarColor(color); &#125; else &#123; //增加占位状态栏 ViewGroup decorView = (ViewGroup) mActivity.getWindow().getDecorView(); View statusBarView = new View(activity); ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity)); statusBarView.setBackgroundColor(color); decorView.addView(statusBarView, lp); &#125; &#125; &#125;&#125; 一番操作后，效果如下： 对于内容视图未使用到 ToolBar 的情况方案二依然可以适用。 ActionBar上述代码在使用 ActionBar 时可以完美适配吗？测试后效果如下图所示 可以看到，通过添加指定颜色的占位状态来达到沉浸效果的方案，在 4.4 系统上效果是正常的，但是在 6.0 上，在状态栏和 Actionbar 之间会有阴影，这个阴影是主题的效果。不知道大家还记不记得 Theme 主题里的几个设计颜色的属性： colorPrimary 指定 ActionBar 的颜色，colorPrimaryDark 指定状态栏颜色，经过测试，在主题里将二者设为统一颜色，状态栏和 ActionBar 之间不会有黑边。自然，我们除了在 Theme 主题里设置，还可以直接在代码里通过上文提到过的代码修改 5.x 以上系统的状态栏颜色： 123Window window = activity.getWindow();window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);window.setStatusBarColor(Color.BLUE); 但是因为 setStatusBarColor() 方法的参数无法传入 Drawble ，所以这种方式是无法实现渐变色状态栏的效果的。所以还是应该聚焦在怎么解决 ActionBar 阴影的问题，上面说了，既然这个阴影是 Theme 的效果，那就肯定有移除这种效果的方法，一种解决方法是更改主题为 ActionBar 不带阴影的主题样式： 1234567891011121314&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; //更改 ActionBar 风格样式 &lt;item name=&quot;actionBarStyle&quot;&gt;@style/ActionBarStyleWithoutShadow&lt;/item&gt;&lt;/style&gt;//ActionBar 不带阴影的主题样式&lt;style name=&quot;ActionBarStyleWithoutShadow&quot; parent=&quot;android:Theme.Holo.ActionBar&quot;&gt; &lt;item name=&quot;background&quot;&gt;@color/blue&lt;/item&gt;&lt;/style&gt; 还有第二种更简单的方式，那就是直接在代码里设置去除阴影： 123456789101112/** * 去除 ActionBar 阴影 */public StatusBarUtils clearActionBarShadow() &#123; if (Build.VERSION.SDK_INT &gt;= 21) &#123; ActionBar supportActionBar = ((AppCompatActivity) mActivity).getSupportActionBar(); if (supportActionBar != null) &#123; supportActionBar.setElevation(0); &#125; &#125; return this;&#125; 并且因为内容是位于 ActionBar 之下的，我们还必须给内容视图是指一个 paddingTop，高度为状态栏高度+ActionBar 高度，才可以使内容正常显示。我们给 ActionBar 设置一个渐变色试试看： 12345678910111213141516171819202122232425262728//drawble 文件夹内新建 shape 渐变色&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;gradient android:angle=&quot;0&quot; android:centerX=&quot;0.7&quot; android:endColor=&quot;@color/shape2&quot; android:startColor=&quot;@color/shape1&quot; android:centerColor=&quot;@color/shape3&quot; android:type=&quot;linear&quot; /&gt;&lt;/shape&gt;//ActionBar 设置渐变背景色getSupportActionBar().setBackgroundDrawable(getResources().getDrawable(R.drawable.shape));//占位状态栏 设置渐变背景色View statusBarView = new View(activity);...//增加占位状态栏方法同上，只是在设置 statusBarView 背景上有 color 和 drawble 之分statusBarView.setBackground(drawable);if (isActionBar()) &#123; //要增加内容视图的 paddingTop,否则内容被 ActionBar 遮盖 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; ViewGroup rootView = (ViewGroup) mActivity.getWindow().getDecorView().findViewById(android.R.id.content); rootView.setPadding(0, getStatusBarHeight(mActivity) + getActionBarHeight(mActivity), 0, 0); &#125;&#125; 至此，尝试适配了几种比较常见的使用场景的沉浸式状态栏，效果也都还比较符合预期。真正去处理这个问题时会发现其实问题也没有想象中的那么复杂。最后附上 Github 源码。 Stay hungry. Stay foolish. 下篇博客再见。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JIRA 知多少：聊一聊 Android Studio 、工作流相关设置]]></title>
    <url>%2F2017%2F08%2F03%2FJIRA-%E7%9F%A5%E5%A4%9A%E5%B0%91%EF%BC%9A%E8%81%8A%E4%B8%80%E8%81%8A-Android-Studio-%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Android Studio 相关配置 JIRA 服务器 如果细心的话会发现有一个选项卡：Commit Message。这一段代码是不是有点熟悉呢？你没有猜错，这段代码就是 commit 模板，当你切换 task 后在git commit 时会自动将任务的id 和 简介配置到 commit 信息里。 切换到某个 JIRA 任务点击工具栏上的 Default task ，下方显示的是最近打开的任务。点击 open Task 会显示出指派给你的任务，点击可以切换到对应的任务： 这里要记得勾选 create changelist。另外建议不要使用默认勾选的 create branch，否则每一次切换任务后本地都会新建对应的分支，到后面分支茫茫多的时候看得蓝廋~ 可以看到，切换到该任务后，使用 AS 自带的 git commit 时，会自动将任务 id 和简介显示出来，结合 JIRA 的 Smart Commits，只要在 commit 信息中添加对应的标识（例如我设置了 finishDev 为从“开发中”状态转换为“测试中”状态的标识，文章下面会介绍如何设置对应的状态转换标识），然后 push 这条 commit 到远程，就可以自动更改 JIRA 任务状态，so easy~ Smart Commit 配置看了上面的示例是不是开始觉得 JIRA 有点意思了？要使用 Smart Commit 你需要先在项目里配置一下 git 项目里添加 git 仓库 在关联完 git 仓库后，你需要进行一次索引的操作。那么问题来了，难道每次在 git 上提交 commit 都得通知 JIRA 更新索引吗？答案既是肯定的也是否定的，要使得 JIRA 可以根据 git commit 修改任务状态，必然要在 git 每次提交 commit 时更新索引，但这个动作当然不是由我们手动来触发，而是使用 webhooks。 github/gitlab 里配置 webhooks右上角小齿轮 - 应用程序 - 选择左下方 webhooks，获取那一串 http 开头的 url 再到 github/gitlab 中配置 url，此处 Secret Token 不用填 webhooks 配置好后，每次 git 接收到 commit 时都会自动通知 JIRA，JIRA 根据 commit 内容识别是否为与任务操作相关的提交，并更新任务状态。 JIRA 配置相关编辑视图 创建工作流 创建转换状态该状态的命名即为 Smart Commit 时的标识符 例如 ‘‘Bug-5 #finishDev 修复###问题’’ 编辑转换状态编辑转换状态之前记得点击右上角的编辑按钮将工作流置于编辑状态 点击编辑按钮，可以为工作流状态转换配置编辑视图（例如需要填写备注、解决结果等），该视图在右侧 界面 - 添加屏幕 中编辑。 不得不提的是上图中另外勾红的两处，其实不止两处，转换状态的处理有四大块，这里简要介绍一下我使用到的两块内容： 条件顾名思义，为转换状态前置某些条件判断，只有符合条件才允许做状态的转换，否则在任务里直接不可见该转换状态。 举个栗子，如果任务 A 下有子任务 b 和子任务 c，正常来说我们肯定不希望在b, c 完成前就可以将 A 完成，故可以对工作流中 close 转换状态做一个限制，如图： 构造子任务阻止条件 构造该条件后，建个 demo 试试看： 可以看到，父任务已经在开发中状态了，但转换状态只有 back（回退这一个操作了），因为其子任务还是启动状态，不符合转换条件。 后处理功能后处理功能的功能非常多，这里简要提几种功能与场景抛装引玉： 场景一：开发完成测试，经办人自动分配为测试负责人 这里有个需要注意的地方，这里我选择的是 Raw Value， 经过测试填写名字和邮箱都是无法生效的，要填写用户的 id，例如在用户选择器里可以看到每个用户的 id，填写这个 id 就可以成功分配值了。 场景二：现在用户A创建了一个任务，项目的负责人B将其分配给了经办人C，C在处理完成后将任务自动分配给了报告人A，A在进行确认时发现不符合要求，执行一个自定义工作流动作“退回”时，希望可以将任务退回给C。但是问题是，C在处理完成时将任务分配给了报告人A，此时经办人和报告人都是A了，所以无论在工作流动作的处理结果中选择分配当前用户、分配给报告人、分配给项目负责人都无法实现退回给C的需求。 这个需求是在搜索资料的过程中看到的，Kenny Jin 提供了这样的解决方案：copy value from field to field。该操作也是在后处理设置里。 场景三：状态转换为 close 时，自动将问题解决结果置为完成（否则即使状态已切换为完成，但解决结果未改变，则任务会一直在打开的问题里展现）同样是后处理功能的设置： 场景四：记录任务参与者，便于统计工作报表JIRA 的经办人一次只能指定一个用户，为了实现这种功能，我的想法是创建一个自定义字段（类型为多用户选择器），在每次开发者参与到任务中时（或者上游切换状态时就将经办人分配下一个开发者），将经办人添加到该字段内，最后在报表中选择以该字段为筛选值即可。 右上角小齿轮 - 问题 - 左侧 通知方案：自动邮件通知执行者右上角小齿轮-问题-下方选择通知方案，自定义一个通知方案。 在这之前要先配置一下邮箱，这里提供一下网易企业邮箱的 SMTP 服务器地址：smtp.ym.163.com 默认端口为：25 （如勾选ssl安全链接，端口号为994），详见客户端的设置方法。 配置好后，点击右上角小齿轮 - 项目，进入项目主页，将通知方案设置上去 to be continued…]]></content>
  </entry>
  <entry>
    <title><![CDATA[[译] 使用 Espresso 隔离测试视图]]></title>
    <url>%2F2017%2F05%2F02%2F%E8%AF%91-%E4%BD%BF%E7%94%A8-Espresso-%E9%9A%94%E7%A6%BB%E6%B5%8B%E8%AF%95%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[原文地址：Testing Views in Isolation with Espresso 原文作者：Ataul Munim 译文出自：掘金翻译计划 译者：yazhi1992 校对者：lovexiaov, Phoenix 使用 Espresso 隔离测试视图在这篇文章里，我将会告诉你为何并且如何使用 Espresso 在 Android 设备上测试你的自定义视图。 你可以使用 Espresso 来一次性测试所有界面或流程。这些测试用例会启动某个页面，并像用户一般执行操作，包括等待数据的加载或跳转到其他页面。 这样做是非常有用的，因为你需要端到端的测试用例来验证常见的用户使用流程。这些自动化测试应该定期地执行，从而可以节约手工 QA 的时间来进行探索性测试。 即便如此，这些不是可以频繁运行的测试。运行一整套可能会花费数小时的时间（想象一下验证媒体内容的脱机同步），所以你可以选择在夜间运行它们。 这很困难，因为这些类型的测试包含了多个潜在的故障点。理想情况是，当某个测试失败时，你会希望它是由于单个逻辑断言而导致的。 大多数（或者说很多）可以引入的回归测试点都在 UI 上。这些问题很可能是十分细微的，以至于我们在添加新特性时并不会注意到，但是敏锐的 QA 团队却往往可以。 这样就浪费太多时间了。 你能做些什么？让我们来看下如何使用 Espresso 来测试正确地绑定了数据的视图。 在 Novoda 里，我们编写的大多数视图都是继承自 Android 已有的 View 和 ViewGroup 类。这些视图一般只会暴露了一到两个方法用来绑定回调函数和数据对象/视图模型，如下所示： 123456789101112131415161718public class MovieItemView extends RelativeLayout &#123; private TextView titleTextView; private Callback callback; public void attach(Callback callback) &#123; this.callback = callback; &#125; public void bind(Movie movie) &#123; titleTextView.setText(movie.name()); setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; callback.onClick(movie); &#125; &#125;); &#125;&#125; 他们将 UI 的逻辑部分组合在一起，并且通常还包含来自业务领域的命名规范。在 Novoda 的页面布局中你很少会看到“原始”的 Android 视图。 让我们使用 BDD 风格来编写这些视图测试，比如“当 MovieItemView 被绑定到 Edward Scissorhands 上，标题就被设置成 Edward Scissorhands”或者“MovieItemView 被绑定到 Edward Scissorhands 上，当点击视图时，onClick(Edward Scissorhands) 就会被调用”，等等。（译者注：BDD（Behaviour Driven Development），倾向于断言被测对象的行为特征而非输入输出。一个典型的 BDD 的测试用例包活完整的三段式上下文，测试大多可以翻译为 Given-When-Then 的格式，即某种场景下，发生了事件，导致了什么结果。） 难道不能使用单元测试来捕获这些问题吗？如果你正在使用像 MVP 或者 MVVM 这样可被单元测试的表现模式，为什么还需要 Espresso 来运行这些测试呢？ 首先，让我们来看一下展示信息的流程并且描述一下目前所能做的测试，然后再看看使用 Espresso 测试能多做些什么。 Presenters 订阅发送事件的数据生成器 事件可以处于加载中，空闲或错误状态，并且可能带有要展示的数据 Presenters 将使用 display(List&lt;Movie&gt;)，displayCachedDataWhileLoading(List&lt;Movie&gt;) 或 displayEmptyScreen() 等方法将这些事件转发给“displayers”（MVP 中的“View”）。 displayers 的具体实现类将显示/隐藏 Android 视图，并执行诸如 moviesView.bind(List&lt;Movie&gt;) 之类的操作 你可以对 presenters 进行单元测试，验证是否调用了 displayers 正确的方法并且带有正确的参数。 你可以用相同的方式测试 displayers 吗？是的，你是可以模拟 Android 视图，并验证是否调用了正确的方法。但这样的粒度并不是我们想要的： displayer 可能确实构建或更新了 RecyclerView 或 ViewPager 适配器，但这并不代表显示了正确的内容。 Android 视图是通过在代码中加载 XML（布局和样式）设置的；验证方法的调用不足以断言显示的内容是否正确 设置测试用例就从使用 espresso-support 这个库开始吧。 在你的 build.gradle（JCenter 可用）里添加依赖 12debugCompile &apos;com.novoda:espresso-support-extras:0.0.3&apos; androidTestCompile &apos;com.novoda:espresso-support:0.0.3&apos; extras 依赖包中包含了 ViewActivity，在测试时需要将其添加到你的应用中。你可以在该 Activity 持有想要使用 Espresso 测试的单一视图。 核心部分（包含自定义测试规则）只需要作为 androidTest 依赖中的一部分。 ViewTestRule 使用方法与 ActivityTestRule 类似。只不过是将传递的参数从想要启动的 Activity 类替换成了包含你想要测试的视图的布局文件： 1234@RunWith(AndroidJUnit4.class)publicclassMovieItemViewTest&#123; @Rule public ViewTestRule&lt;MovieItemView&gt; viewTestRule=newViewTestRule&lt;&gt;(R.layout.test_movie_item_view); ... 你可以使用 ViewTestRule&lt;MovieItemView&gt; 指定根布局的视图类型。 ViewTestRule 继承了 ActivityTestRule&lt;ViewActivity&gt;，所以它总会打开 ViewActivity。 getActivityIntent() 被重写了，所以你可以将 R.layout.test_movie_item_view 作为 Intent 的附加数据传递给 ViewActivity。 你可以在测试中使用 Mockito 代替回调函数。 123456789101112@Rulepublic MockitoRule mockitoRule = MockitoJUnit.rule();@MockMovieItemView.Listener movieItemListener;@BeforepublicvoidsetUp()&#123; MovieItemView view = viewTestRule.getView(); view.attachListener(movieItemListener); ... &#125; ViewTestRule 有一个 bindViewUsing(Binder) 方法，该方法会返回视图的引用，以便你与之进行交互。当你使用 viewTestRule.getView() 直接访问视图时，你会希望与视图的所有交互都是在主线程上执行的，而非测试线程。 1234567891011@Beforepublic void setUp() &#123; MovieItemView view = viewTestRule.getView(); view.attachListener(movieItemListener); viewTestRule.bindViewUsing(new ViewTestRule.Binder&lt;MovieItemView&gt;() &#123; @Override public void bind(MovieItemView view) &#123; view.bind(EDWARD_SCISSORHANDS); &#125; &#125;);&#125; 准备测试从用户的角度上来看，应用其实只做了两件事情： 展示信息 响应用户的操作 要为这两种情况编写测试，你可以先从使用标准的 Espresso ViewMatchers 和 ViewAssertions 语句断言是否显示正确的信息开始： 12345@Testpublic void titleSetToMovieName() &#123; onView(withId(R.id.movie_item_text_name)) .check(matches(withText(EDWARD_SCISSORHANDS.name)));&#125; 接着，你应该确保用户的操作触发了正确的点击事件，并且具有正确的参数： 12345678@Testpublic void clickMovieItemView() &#123; onView(withClassName(is(MovieItemView.class.getName()))) .perform(click()); verify(movieItemListener) .onClick(eq(EDWARD_SCISSORHANDS));&#125; 到这里就完成了，希望这些知识对你有用。 在接下来的文章里，我会介绍如何使用 Espresso 测试视图时支持 TalkBack 服务（译者注：Talkback 是一款由谷歌官方开发的系统工具软件，它的定位是帮助盲人或者有视力障碍的用户提供语言辅助）。 掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、React、前端、后端、产品、设计 等领域，想要查看更多优质译文请持续关注 掘金翻译计划。]]></content>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 上使用 Shell 脚本 + adb shell 实现简单的 Android 模拟点击自动化测试]]></title>
    <url>%2F2017%2F04%2F29%2FMac-%E4%B8%8A%E4%BD%BF%E7%94%A8-Shell-%E8%84%9A%E6%9C%AC-adb-shell-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84-Android-%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[需求在 A 界面，点击跳转到 B 界面（该界面会执行一些业务），再点击返回键出现 Dialog 弹窗，点击确认退出按钮，返回 A 界面。不断循环。 思路一开始想到的就是按键精灵，下了 mac 版使用后发现功能太不完善，于是试了试 Windows 版，实在是操作不习惯。在搜索资料过程中了解到还可以使用 adb 来实现模拟设备操作，那肯定是写代码更顺手啊，配合使用脚本重复输入命令，就能实现简单的自动化重复操作了。 实现模拟设备操作常用的按钮都有特定的 keyevent 代号，例如返回键代号4（其他按键可参考文末文章中介绍），模拟返回键的点击只需要在命令行中输入 adb shell input keyevent 4 即可。 模拟点击屏幕中某点的命令是 adb shell input tap x y，(x,y)是相应的坐标点，这就涉及到了对坐标点的计算。巧的是，正好之前写了个涂鸦的 demo （Github 地址，App 下载地址），可以使用该 demo 来调试点击的坐标点是否符合我们的期望。 不同机型分辨率不同，坐标点位置肯定是不一样的。比较理想的结果应该是我们输入固定的坐标点，然后代码里自动获取机型的屏幕密度等信息并自动转换。这里为了快速开发出这个小功能，就简单使用了最耿直的不同机型设置不同坐标的方法 ╮(╯▽╰)╭。 所以单步实现上述需求的命令就是： 123adb shell input tap 200 300 //点击(200,300)坐标点（假设该点就是跳转按钮所在位置）adb shell input keyevent 4 //点击退出，弹出是否确认退出 Dialogadb shell input tap 500 600 //点击(500,600)坐标点（假设该点就是确认退出按钮所在位置） 一次模拟进出界面的测试就完成了。 自动化在命令行窗口输入命令便可实现单步操作，那想要自动化实现整个流程自然就是要做到自动输入命令。Shell 脚本可以实现这样的功能。后面要做的就简单了：确定需要实现的功能 –&gt; 学习相应的 Shell 脚本语法 –&gt; 编写脚本。 需要的功能Shell 脚本的第一行必须为 #!/bin/bash。使用命令：sh 脚本名.sh 运行脚本。 打印 log（时间、循环次数等）echo 在命令行输出一段日志。例如 echo &quot;Hello World&quot;。 打印当前时间：12time=$(date +%m-%d--%H:%M:%S)`echo &quot;时间：$time ####简单的交互 例如输入不同机型代号。read phoneModel 该语句会将用户的输入存储在 phoneModel 变量中，再根据变量做判断处理。使用变量在变量名前加 $ 符号即可。例如： 123echo &quot;What&apos;s your name?&quot;read myNameecho &quot;Hi, $myName&quot; 定义变量直接使用 变量名=值 方式定义。要注意变量名和值与 = 号中间不要有空格，且变量命名要符合规范： 首个字符必须为字母（a-z，A-Z） 中间不能有空格，可以使用下划线（_） 不能使用标点符号 不能使用bash里的关键字（可用help命令查看保留关键字） ####if else 判断 1234567echo &quot;What&apos;s your name?&quot;read myNameif [ &quot;$myName&quot; = &quot;yazhi&quot; ];then echo &quot;I know you!&quot;else echo &quot;Nice to see you!&quot;fi 这里要注意 [ 和] 符号前后的空格，少了空格会提示语法错误，语句最后要跟 fi。 休眠（业务是耗时的）sleep 5 ：休眠5秒 While 循环1234while [ &quot;1&quot; = &quot;1&quot; ] #死循环do echo &quot;do something&quot;done 基本用得到的语法就上述这些，最后贴一下我的脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/bin/bashecho &quot;开始自动化进出教室&quot;quitTime=10echo &quot;课程数据量是否很大？(y/n)&quot;read waitTimeif [ &quot;$waitTime&quot; = &quot;y&quot; ];then quitTime=25 #数据量多的课程elif [ &quot;$waitTime&quot; = &quot;n&quot; ]; then quitTime=10 #数据量少的课程else echo &quot;输入错误&quot; exit 0fienterRoomX=0 #进入教室按钮坐标enterRoomY=0quitRoomX=0 #确认退出按钮坐标quitRoomY=0echo &quot;选择机型：1（华为M2平板），2（小米平板2），3（Nexus5），4（红米2A）&quot;read phoneif [ &quot;$phone&quot; = &quot;1&quot; ];then echo &quot;当前选中机型：华为M2平板&quot; enterRoomX=400 enterRoomY=500 quitRoomX=1300 quitRoomY=610elif [ &quot;$phone&quot; = &quot;2&quot; ];then echo &quot;当前选中机型：小米平板2&quot; enterRoomX=400 enterRoomY=640 quitRoomX=1480 quitRoomY=820elif [ &quot;$phone&quot; = &quot;3&quot; ];then echo &quot;当前选中机型：Nexus5&quot; enterRoomX=200 enterRoomY=900 quitRoomX=1200 quitRoomY=610elif [ &quot;$phone&quot; = &quot;4&quot; ];then echo &quot;当前选中机型：红米2A&quot; enterRoomX=200 enterRoomY=600 quitRoomX=1000 quitRoomY=410else echo &quot;错误：未知机型&quot; exit 0fiecho &quot;开始自动化进出教室&quot; num=1while [ &quot;1&quot; = &quot;1&quot; ] #死循环do time=$(date +%m-%d--%H:%M:%S) echo &quot;时间：$time 第 $num 次进入教室&quot; num=$(($num + 1)) adb shell input tap $enterRoomX $enterRoomY #进入教室 sleep $quitTime #进教室休眠时间 adb shell input keyevent 4 #退出教室 sleep 1 adb shell input tap $quitRoomX $quitRoomY #退出教室确认 sleep 4 done 参考自己动手开发安卓版按键精灵 Shell 脚本语法]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义demo集合]]></title>
    <url>%2F2017%2F03%2F31%2F%E8%87%AA%E5%AE%9A%E4%B9%89demo%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[各种写着玩的自定义控件demo有时网上看到一些比较有意思的开源项目，有时间的话就会自己也撸一个出来，但是一般只关注实现样式、动画等，不会太去细致完整地完成，俗称占个坑~ 持续更新中… github地址 饿了么加入购物车按钮 渐变圆环真机效果没这么丑的~ 水波纹进度条]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[落户杭州攻略]]></title>
    <url>%2F2017%2F03%2F27%2F%E8%90%BD%E6%88%B7%E6%9D%AD%E5%B7%9E%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[步骤1，办理调档函（3.27）所需材料 劳动合同 身份证 档案所在单位名称（调档函抬头需要使用到） 办理地点杭州人才服务局：下城区东新路155号4楼（和平广场站） 电话：0571-85167766我是下午去办的，下午1:30是上班。 步骤2，调档（4.5）所需材料 调档函 离职证明(如果你的档案状态是在职，则需要该公司的离职证明) 办理地点厦门市人才服务中心：湖滨东路319号。上午12点下班，下午2:30上班。人不是很多。厦门不允许档案自带。不过你可以准备一份《档案自带声明》，大意就是自带档案，后果自负云云，具体可百度。然后说服档案部的人允许你自带档案，这样会快很多。 步骤3，落户申请表（4.18）档案已寄到杭州后，可以开始下一步（如果条件允许，也可以先提前准备好所需材料，免得一天跑太匆忙）。 所需材料 社保证明（打印2份，我是在杭州市西湖区行政服务中心（竞舟路农贸市场旁边）自助机打印，排队约半小时） 无房证明（打印2份，杭州市房产档案服务大厅自助机打印，排队约1小时） 劳动合同（原件、复印件） 身份证（原件、复印件） 户口本（原件、复印件） 毕业证书（原件、复印件） 学位证书（原件、复印件） 办理地点杭州人才服务局：下城区东新路155号4楼（和平广场站） 电话：0571-85167766将上述材料交于工作人员之后，工作人员会给你一份《进杭落户审批表》和一份《同意落户证明》。 《进杭落户审批表》拿回公司签名盖章 步骤4，落户审批（4.20）所需材料 社保证明 无房证明 劳动合同（原件、复印件） 身份证（原件、复印件） 户口本（原件、复印件） 毕业证书（原件、复印件） 学位证书（原件、复印件） 《进杭落户审批表》 《同意落户证明》 办理地点杭州市公安局办证中心：浙江省杭州市上城区华光路35号 电话：0571-87280478将上述材料上交，工作人员会给你一张《回执单》，之后就是耐心等待审批完成。 步骤5，拿准迁证（5.3）所需材料 《回执单》 办理地点杭州市公安局办证中心：浙江省杭州市上城区华光路35号 电话：0571-87280478凭《回执单》到公安局办证中心户籍科领取《准迁证》和《进杭落户审批表》红联。我早上9点过去取得号，约等到了11点。 步骤6， 回户口所在地派出所迁户（5.9）所需材料 《准迁证》 户口本原件及复印件 身份证原件及复印件 办理地点我是属于厦门梧村派出所的，位置是：思明区东浦路22号将上述材料上交，工作人员会给你一张《户口迁移证》和《准迁证》的迁入联，并回收户口本。 步骤7，拿同意落户证明(5.12)所需材料 《户口迁移证》 《准迁证》迁入联 《进杭落户审批表》红联 身份证 办理地点杭州人才服务局：下城区东新路155号4楼（和平广场站）电话：0571-85167766将上述材料交于工作人员之后，工作人员会给你一份《同意落户证明》和一份《进杭落户告知书》。拿到后可以立即去派出所完成落户，距离很近。 步骤8，派出所完成落户(5.12)所需材料 《户口迁移证》 《准迁证》迁入联 《进杭落户审批表》红联 《同意落户证明》 《进杭落户告知书》 身份证 办理地点文晖派出所：下城区闸弄口路127号流水东苑3幢1层 电话：0571-85373110将上述材料交于工作人员之后，完成落户。如有需要可以办理新的身份证。]]></content>
      <tags>
        <tag>经验分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout 学习笔记]]></title>
    <url>%2F2017%2F03%2F24%2FConstraintLayout%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[如何阅读 xml 属性与 Relativelayout 不同，ConstrainLayout 的属性需要同时说明需要怎么操作自己与目标控件，例如：layout_constraintLeft_toLeftOf 指自身左边缘与目标控件左边缘对齐 从此 match_parent 是故人ConstraintLayout 里不再使用 match_parent，想要铺满屏幕，只能设置宽度为 0，并添加左右边缘与父容器的约束。（ 想要实现 match_parent的效果，切记要设置该方向大小为 0dp ） 123android:layout_width=&quot;0dp&quot;app:layout_constraintLeft_toLeftOf=&quot;parent&quot;app:layout_constraintRight_toRightOf=&quot;parent&quot; 穿了马甲的 LinearLayout线性布局的 weight 属性可以轻松实现等分操作。在 ConstraintLayout 里你也可以实现类似的功能： 1app:layout_constraintHorizontal_bias=&quot;.3&quot; //数值范围：0~1 如果控件已约束了左右边缘且定义了 bias 为 0.3，则意味着控件与左边缘的距离占控件左右边缘间距的 30%，如图： 甚至想要实现 LinearLayout 的 weight=1 等分操作（例如水平方向上等分）也很简单，每个相邻控件互为约束并设置 width=0dp 即可。这样其实就组成了链（chaining）。 链想上面说到的，设置 width=0，且控件之间两两互相约束，即可实现水平方向等分。此时还可以给控件设置 layout_constraintHorizontal_weight 属性，该属性与 LinearLayout 中的 weight 类似。 链条头部的属性水平链的最左边，垂直链的最上边称之为头部，链的头部可以设置链的属性： 123app:layout_constraintHorizontal_chainStyle=&quot;spread&quot; app:layout_constraintVertical_chainStyle=&quot;packed&quot; spread 默认属性，平均分布 spread_inside 首尾无间距 packed 控件间无间距，可以同时搭配 layout_constraintHorizontal_bias 属性控制与父容器的间距 各属性值的样式如下： 厉害了，还能设宽高比1app:layout_constraintDimensionRatio=&quot;1:1&quot; //宽：高 该属性起作用的前提是宽或高至少有一个设为 0dp，设为 0dp 的边即为随比例缩放的边。举个栗子： 1234&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintDimensionRatio=&quot;1:1&quot;/&gt; 该文本框在随着内容文字的增加，宽度会越来越大，一旦设定了宽高比为1，则在宽度增大时高度也会等比增大，一直保持在宽高比1：1。 宽高比还有另外的妙用，比如一个控件左右边缘已存在与父容器约束，且同时将宽高都设为 0dp，便得到水平方向上铺满屏幕的效果，如图： 指示线 Guideline指示线不会被绘制到 UI 中，所以放心大胆地用。Guideline 的一些属性： 12345678910&lt;android.support.constraint.Guideline android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/guideline&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; //设置位置比例 android:orientation=&quot;vertical&quot;/&gt; //不注明该属性，则默认是水平方向 app:layout_constraintGuide_begin=&quot;30dp&quot; //设置与头部边距 app:layout_constraintGuide_end=&quot;30dp&quot; // 设置与尾部边距 其他 layout_goneMarginLeft 属性，当有约束关系的控件被置为 gone 状态时，可以通过设置该属性来控制间距 动画[译]Constraint Layout 动画 |动态 Constraint |用 Java 实现的 UI（这到底是什么）[第三部分]]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译] ConstraintLayout 可视化[Design]编辑器（这到底是什么）[第四部分]]]></title>
    <url>%2F2017%2F02%2F26%2F%E8%AF%91-ConstraintLayout-%E5%8F%AF%E8%A7%86%E5%8C%96-Design-%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%88%E8%BF%99%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[原文地址：Constraint Layout Visual [Design] Editor ( What the hell is this )[Part4] 原文作者：Hafiz Waleed Hussain 译文出自：掘金翻译计划 译者：yazhi1992 校对者：phxnirvana，tanglie1993 哇哦，又是新的一天。为了不浪费这宝贵的时光，让我们来学点新知识吧 🙂 。 大家好，希望各位都有所进步。在第一部分, 第二部分 和 第三部分这些文章中我们已经学习了许多关于 ConstraintLayout 的知识。现在是时候来学习这个神奇布局的剩余内容了。顺便一提，本文是 Constraint Layout（这到底是什么）系列的最后一篇文章了。 动机： 学习动机与先前在第一部分中讨论的是一样的。这篇文章里我们将会学习如何使用可视化编辑器（Visual Editor）。有一些地方我会引用到第二部分的内容。我将会使用可视化编辑器来实现一些，我们已经讨论过怎样在 XML 或者 Java 中实现的概念。通过这种方式我们可以节省许多的时间。 我们需要下载 2.3 版本的 Android studio。先前版本的可视化编辑器不太完善，有时会在 Design 面板上显示错误的信息。所以下载 2.3 beta 版是非常重要的，该版本在我写这篇文章时已经可以获取到了。 引言 在这篇文章里我们大部分都是使用可视化编辑器，用到 XML 的机会比较少。那么让我们开始吧！ 在上图中我标出了五个红色的方框。这就是整个可视化编辑器了。在开始介绍之前有一个问题。那就是：了解各个组成部分以及它们的名字真的那么重要吗？在我看来，如果我们只是想要独立完成某些工作，那么通过一遍又一遍地重复那些工作就可以掌握相应的技能，并不需要了解术语。但如果我们想要帮助社区里的成员，或者说我们想要成为一名优秀的团队合作者，我们就应该学习所有相关的术语。这确实很有用，我将会展示给你们看。 我知道大多数人不是很了解（或许有一些人了解 🙂）什么是 Palette, Component Tree, Properties 等等，但是我将会使用这些术语来描述流程。任何从事 UI 工作的开发人员都会遵循这些步骤。 从 Palette 窗口选取 UI 组件 -&gt; 拖拽到 Design 编辑器中 -&gt; 在 Property 窗口中改变组件的属性（宽度，高度，文字，外边距，内边距… 等等） -&gt; 在 Design 编辑器中调整约束关系。 总共四个步骤，我再重复一遍。 Palette 窗口 -&gt; Design 编辑器 -&gt; Properties 窗口 -&gt; Design 编辑器 我们构建 UI 时 90% 都是这样的基本流程。如果你知道这些术语，你就可以轻易地想象出我们说的是什么。接下来我会向大家介绍我刚刚提到的那些术语到底是什么，以及我们怎么在可视化编辑器中找到它们。 Palette: 提供了一系列的部件（widgets）和布局（layouts），你可以将其拖拽到位于编辑器中的布局里。（官方文档介绍） 在这里你可以获取到 Android 提供的所有 UI 组件。在右上角有一个搜索图标，你可以通过搜索节省寻找的时间。搜索图标的右边还有一个设置图标。点击这个酷炫的图标，你可以根据个人喜好更改 UI 组件的外观。 Design 编辑器: 通过设计（Design）视图和蓝图（Blueprint）视图来预览你的布局。（官方文档介绍） 上图就是 Design 编辑器。在 Design 编辑器里我们有两种模式可选，一种是设计模式（Design），另一种是文本模式（Text）。首先我们来看设计模式。 上图中我们看到的两个布局其实是同一个布局。左边那部分就是我们将在设备中看到的 UI 界面。右边那部分称之为蓝图（blueprint）。当你在设计时这些都非常有用。你可以很轻易地看到每个视图的外边距、边缘以及它们之间是否有冲突。我就当作你们已经知道了怎么去拖拽视图到 Design 编辑器中，并且知道怎么去创建与父布局或其他视图的约束关系。我要开始介绍下一个步骤了。 从上图中可以看到有许多的图标。是时候来介绍一下这些图标到底是什么以及使用它们可以带来什么好处。 在开始之前，为了便于后面解释，我会给这些图标起个名。从左到右开始分别是：眼睛图标、磁铁图标、交叉箭头图标、星星图标、数字盒子、背包图标、对齐图标、指示线图标、放大图标、缩小图标、适应屏幕图标、平移缩放图标、警告和错误图标。 眼睛图标： 这个图标很有用，尤其是当我们的界面上有大量的视图时。如果这个图标处于打开状态，这意味着我们同时可以看到所有视图的约束关系。比如当我只在调整一个按钮时，我却可以看到其他所有视图的约束关系。如果关闭了该功能，你就仅仅只能看到选中视图的约束，如下图所示。 磁铁图标： 如果你了解了这个图标会节省许多的时间。老实说我不太擅长使用这个图标，但是我会把我所知道的都告诉你。如果这个图标处于关闭状态，你在 Design 编辑器里可以拖拽或移动你的视图，但你必须手动构建约束。如果这个图标处于打开状态，这时编辑器就会自动构建与父视图的约束。 如上图所示。一开始图标处于关闭状态，我将我的 ImageView 移动到居中的位置，但什么都没有发生。之后我将磁铁图标打开了，神奇的事情发生了。我将我的 ImageView 移动到居中的位置，编辑器自动为我构建了约束。哇哦！ 交叉箭头图标： 这个图标非常简单也非常酷炫。如果我想要清空所有的约束，只要点击这个图标，然后所有的约束都会被移除掉。如下图所示。 如上图所示，自动约束（磁铁图标）是打开的，这就是为什么当我将视图移动到水平居中时会自动构建约束，但是当我点击了这个图标，所有的约束都被移除掉了。 星星图标： 这又是一个酷炫的图标。与交叉（清空约束）图标正好相反。我可以随意地拖拽视图而不用为它们构建约束。当我操作完成时只要点击一下这个图标，就可以自动构建出所有的约束，如下图所示。我很喜欢这个功能。 数字盒子： 作用是为你的父布局设置默认的外边距。 背包图标： 这个图标包含了许多功能。我会一个个地解释。 因为没有选中任何视图，所以一开始在 Design 编辑器中所有的图标都是不可点击的。有一些图标在选中了单个视图后可用，另外一些图标在选中多个视图后可用。首先我来解释一下那些选中单个视图后可用的图标。 当我选中了一个视图，有两个图标会变为可用的，如下图所示。让我们来看一下它们可以做些什么。 我点击了左边的图标，可以看到视图的宽度扩展到了屏幕边缘，但是请记住，这只是以 dp 为单位使用数值实现的效果而不是所谓的 match_parent(parent)。这就意味着如果在屏幕宽度更大的设备上，这个视图就无法扩展到屏幕边缘了。右边的图标也是一样的功能，只不过是作用于垂直方向的。如下图所示。 还有一件事别忘了。如果你点击了扩展宽度或高度的图标，而选中视图的宽高却只扩展到了相邻的视图边缘。不要感到困惑。因为在上面的例子中布局里只有一个视图，所以它填充满了父布局的宽高。下面的例子中我会给你看点不一样的。 在开始介绍那些与多选视图有关的图标之前，还有一点是值得注意的，你在选中多个视图时仍然可以使用那些单选视图时可用的图标，如下图所示。 现在让我们开始学习那些多选视图后可用的图标吧。 当我在 Design 编辑器里选中多个视图后，剩下的几个图标就都变为可用的了。如下图所示。 这两个图标功能是一样的的，只不过一个用于水平方向，另一个用于垂直方向。当我点击了水平方向的图标后，所有视图都会水平方向对齐。那么随之而来的问题是：这和上面刚学习过的那对图标有什么区别呢？ 区别在于，上面的图标通过扩展尺寸（来对齐）。而这两个图标并不会扩展尺寸，而是将视图平移至互相对齐。另外值得注意的是，这只是在 Design 编辑器中设定了值，如果你运行到设备上你是无法获得在 Design 编辑器中显示的效果的。你需要自己去构建约束。但其实你可以先通过使用这些图标来对齐视图，这样可以节省很多时间，然后再构建约束，这样你就可以在设备上得到适当的效果。让我们来看一下点击这些图标之后会发生什么吧。 接着再来解释剩下的两个图标。 同样的，这两个图标也有着一样的功能，只不过作用的方向不一样。 用不着去移动位置或者改变数值，我只要点击左边的图标，就可以为所有选中的视图构建水平方向的约束。如下图所示。 还可以通过双击图标将视图链接成链。如果你对链不太了解，你可以去阅读该系列博客的第二部分。那篇文章里介绍了什么是链以及使用链带来的好处。 在下图中你可以看到如何使用编辑器构建链。 对齐图标： 这个图标的弹出菜单里包含了多达 11 个图标。其中 4 个图标在选中单个视图时可用，其余的在选中多个视图时可用。 首先我来介绍一下底部那四个在选中单个视图时可用的图标吧。 第一个图标的作用是将视图相对于相邻视图水平居中并构建约束。 第二个图标的作用是将视图相对于相邻视图垂直居中并构建约束。 第三个图标的作用是将视图相对于父布局水平居中并构建约束。 第四个图标的作用是将视图相对于父布局垂直居中并构建约束。 这些图标实现的效果如下图所示。 现在就剩下那些选中多个视图后可用的图标了。 先来介绍上面的三个： 第一个图标的作用是将所有选中视图左对齐于所选中视图的左边缘并构建约束。 第二个图标的作用是将所有选中视图都水平居中并构建约束。 第三个图标的作用是将所有选中视图右对齐于所选中视图的右边缘并构建约束。 这些图标实现的效果如下图所示。 下面的四个图标的作用是一样的，只不过是作用于垂直反向。 指示线图标： 我们已经在第二部分中讨论过什么是指示线以及使用它会带来什么好处了。这里我就不再多介绍了。你可以放心地在 UI 中添加指示线因为它不算作视图。现在有了这个图标，我们可以使用它来添加指示线，如下图所示。 放大、缩小、适应屏幕图标： 这个大家应该都懂就不用多说了吧。 平移缩放图标： 当我处理一些要放大很多倍，并且还需要拖动界面的工作时，这个图标就非常有用了。如下图所示。 警告和错误图标： 当我在构建我的 UI 时，这个图标非常有用。只要点击一下这个图标，就可以看到是否有任何错误或者警告发生。 到这里，我们终于结束了对可视化编辑器设计模式（Design mode）的学习。是时候开始看看我是怎么在文本模式（Text mode）里工作的了。 除了通过编辑器来改变属性外，刚刚我们在设计模式中做的所有事情都可以在文本模式中做到。除此之外，我们还可以编写 XML。 工具栏： 提供了一些按钮用来配置编辑器中的布局外观以及编辑布局的属性。（官方文档介绍） 我只准备介绍工具栏中的前三个和最后一个图标。其他的图标以前就有了，我相信大家对它们都非常熟悉。 设计视图模式（Design View Mode）图标： 第一个会显示纯粹的 UI 布局。 第二个会显示我们的 UI 布局的蓝图。 第三个则两种都显示。 这些图标实现的效果如下图所示。 多布局图标： 当我想要为不同的布局创建不同的布局文件时这个图标就可以帮上大忙。就比如我想要单独创建一个横屏的布局。使用这个图标我可以很快地创建好而不用进入文件夹中。如下图所示。 组件树（Component Tree）： 展示你的布局的界面层级。单击某一项可以将其在编辑器中选中。（官方文档介绍） 这个窗口很有用，尤其是当我在 Design 编辑器中并且有大量的图标层层堆叠时，这时很难去选中某些视图旁边的一些视图。在这种情况下，我一般都会使用它来选中我想要的视图。如下图所示。 Properties： 提供了对当前选中视图的属性控制。（官方文档介绍） 面板由上图所示的两部分组成。这里我只介绍第一张图里的东西，因为第二张图里的东西在 Android Studio 诞生之初就已经存在了，所以应该不用我多说了吧。至于如何切换这两种视图，如下图所示。 让我们开始学习第一个属性窗口里的新东西吧！如下图所示。 我们要探索的主要分为两大部分。第一部分是方形内部，这部分是用来设置视图的尺寸。另一部分是方形外部的蓝色的线条，这些是用来调整视图的约束关系的。 方形内部： 在方形内部我们可以看到三种形态。 1.Wrap content: 所有的视图都有 wrap_content 的概念，这里也是一样。现在我们可以在 Design 编辑器中设定该属性了。如下图所示。 这里我将一个原本属性为 match_parent，match_parent 的按钮修改为了 wrap_content，wrap_content。 2.固定尺寸： 固定尺寸指的是像我们给宽度和高度设定 dp 值一样，现在我们可以直接在 UI 界面里做到。如下图所示。 这里我将一个属性为 wrap_content，wrap_content 的按钮更改成了固定尺寸，并通过拖拽来设定值。 3.任意尺寸： 任意尺寸在我们构建约束时非常有用。就比如我没有给视图设置任何约束，并将其设置为任意尺寸，视图就会变为 0 dp，0 dp。如下图所示。 现在我要对这个按钮施加左右约束，之后将其宽高设置为任意尺寸，这时按钮会填充所有剩余的空间。如下图所示。 现在是时候学习有关如何设置视图的约束值了。 上图中所有红色的方形区域包含了选中视图的所有约束设置。 这些线条的作用如下图所示。 上图中有一个按钮，我为该按钮构建了左侧值为 24 dp 的约束。之后我将值修改为 207 dp，最后我通过点击小圆点将约束移除。有一点值得注意的是，这些值不是约束，而是外边距。你只能在构建约束后设置该值。 希望你们喜欢我的 Constraint Layout（这到底是什么） 这一系列教程。今天我们完成了所有我对 Constraint Layout 了解的内容的介绍。 下次我们再一起学点新的知识吧。再见。周末愉快 🙂 。]]></content>
      <tags>
        <tag>掘金翻译计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》读书笔记]]></title>
    <url>%2F2017%2F01%2F28%2F%E3%80%8AEffective-Java%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[创建和销毁对象静态工厂模式 构造器里未传参的成员不会被初始化。int类型是0，布尔类型是false，String类型是null，List&lt;&gt;也是null。 重叠构造器 进阶1：javabean模式，使用set方法来初始化成员，缺点是构造过程中javabean可能处于不一致状态（可以理解成该模式下成员的设置的分步进行的，可能某处使用到该类的某个成员时其还未被初始化），并且该模式阻止了把类变成不可能的可能，需要考虑线程安全。 进阶2： Builder模式：类里定义一个静态类builder（其实就是javabean），对builder初始化完成后使用build（）返回该类，Buidler模式的状态不一致是builder，而不是类本身，并且类自身的成员也可设置成final。 修饰符 长度非零的数组总是可变的，即使是final类型： 12345678910public static final int[] VALUES=&#123;...&#125; //错误//正确1：增加一个公有的不可变列表private static final int[] VALUES=...public static final List&lt; intergeR &gt; VALUES=&#123;Collections.unmodifiableList(Arrays.adList(PRIVATE_VALUES));//正确2：返回私有数组的拷贝private static final int[] VALUES=...public static final int[] values() &#123; return VALUES.clone();&#125; 如果是公有类，直接暴露数据会有很大的隐患，因为当你将来想改变其内部表示法时已经不可能了，因为共有类的客户端代码已经遍布各处了。 1234567891011public class Point&#123; //错误 public int x; public int y;&#125;public class Point&#123; //正确 private int x; private int y; public int getX() &#123; return x;&#125;&#125; 类和接口使可变性最小化 线程安全最容易的做法：只提供访问方法，不提供设值方法，对对象的加减乘除都重新返回一个新的对象。对象不会变化，也就不要求同步。 可以把开销昂贵的计算结果缓存起来，例如String的hashcode方法，第一次计算后会将结果保存在成员hashCode里。 复合优先继承 子类脆弱：例如一个类继承HashSet，如果子类里重写了addAll和add方法来计数，就会导致错误，因为HashSet的addAll是基于add方法实现的。不能保证父类不随着版本而变化，因此extends 子类继承父类是非常脆弱的。 只有当子类真正是超类的子类型，即A和B，两者确实存在B is A的关系时，类B才应该扩展A，如果答案是否定的，通常情况下B应该包含A的一个私有实例，并且暴露一个较小的，简单的API：A本质上不是B的一部分，只是它的实现细节而已。 装饰者模式（Decorator模式）结合上面说到的，HashSet是implement Set类的，在HashSet里重写了Set接口定义的add,addAll等方法。因此新的子类继承Hashset重写add、addAll就不可避免会将HashSet里的实现继承下来。 使用装饰者模式：ForwardingSet implements Set，该类有成员private final Set s s，构造器里就是传入一个Set ，该类不具体实现Set的任何方法,例如： 123public boolean add(E e) &#123; return s.add(e);&#125; InstrumentedSet extends ForwardingSet，构造器super父类即可，在这个类里添加一些功能，例如： 12345@Overridepublic boolean add(E e)&#123; count++; return super.add(e);&#125; 这种模式下，InstrumentedSet 只是一个包装类，只是对其成员Set进行修饰，为它增加计数特性。包装类并不实现具体功能，构造器里传入的就是实现具体功能的Set,可以是HaseSet或者自己实现的Set。 另可参考阅读：Android源码学习之装饰模式应用 继承后构造方法的调用 如果子类没有定义构造方法，则调用父类的无参数的构造方法。 如果子类定义了构造方法，不论是无参数还是带参数,在创建子类的对象的时候,首先执行父类无参数的构造方法,然后执行自己的构造方法。 如果子类调用父类带参数的构造方法，可以通过super(参数)调用所需要的父类的构造方法,切该语句做为子类构造方法中的第一条语句。 如果某个构造方法调用类中的其他的构造方法，则可以用this(参数),切该语句放在构造方法的第一条。说白了:原则就是，先调用父亲的。(没有就默认调，有了就按有的调，反正只要有一个就可以了) 1234567891011121314151617181920212223242526272829303132333435public class Son extends Father &#123; public Son() &#123; // super(); //没加默认调用父类无参构造方法 super(&quot;from son&quot;); Log.e(&quot;zyz&quot;, &quot;son-constructor&quot;); &#125; public Son(String str) &#123;// super(); //没加默认调用父类无参构造方法 Log.e(&quot;zyz&quot;, str + &quot; son-constructor-with-params&quot;); &#125; @Override public void print() &#123; Log.e(&quot;zyz&quot;, &quot;son-print&quot;); &#125;&#125;public class Son extends Father &#123; public Son() &#123;// super(); //没加默认调用父类无参构造方法 super(&quot;from son&quot;); Log.e(&quot;zyz&quot;, &quot;son-constructor&quot;); &#125; public Son(String str) &#123;// super(); //没加默认调用父类无参构造方法 Log.e(&quot;zyz&quot;, str + &quot; son-constructor-with-params&quot;); &#125; @Override public void print() &#123; Log.e(&quot;zyz&quot;, &quot;son-print&quot;); &#125;&#125; 接口优于抽象类抽象类可以写实例方法，通过派生继承，实现代码复用(子类可直接调用父类方法)，但由于重用方法增加了耦合度，接口的方法一定需要重写，最大程度实现了解耦。 类层次优于标签类标签类：例如使用枚举或常量定义了圆和矩形，成员里有半径、长、宽。在公共方法 计算面积里，使用switch来判断是那种形状，再分别计算。类似的把多个实现乱七八糟地挤在单个类中，破坏可读性，又增加了内存占用，因为实例承担着属于其他类型的域。 应该使用类层次来优化：定义一个抽象类，包含抽象方法：将共有的方法（计算面积），如果有公有的成员还可以将其放在抽象类中。之后不同的类圆和矩形继承公共抽象类，另外添加自己的参数，并重写自己的计算面积的方法。 优先考虑静态成员如果成员类不要求访问外围实例，就要定义成静态内部类。非静态内部类始终要保持外围对象的引用，不仅消耗内存，还将导致外围实例无法被垃圾回收。例如Map实现的内部都有Entry对象，每个Entry都与Map关联，但是entry的方法（getKey/getValue）等并不需要访问Map，因此私有的静态成员类是最佳的选择。 如果一个嵌套类需要在单个方法之外可见，或者它太长了不适合放在方法内部，就使用成员类。 如果成员类的每个实例都需要一个指向外围实例的应用，就使用非静态成员类。否则就使用静态成员类。 如果嵌套类属于一个方法的内部，且你只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就使用匿名类。否则就使用局部类。 泛型列表优先于数组二者的不同点： 数组是协变的（covariant）如果B是A的子类，那么B[]就是A[]的子类型。 123//编译时不报错，运行时报错ArrayStoreExceptionObject[] test = new Long[1];test[0] = &quot;test&quot;; 而两个不同的类型A、B，List既不是List的子类也不是超类。 12List&lt;Object&gt; test2 = new ArrayList&lt;Long&gt;(); //编译时报错test2.add(&quot;123&quot;); 数组是具体化的（reified）数组在运行时才知道并检查他们的元素类型约束。泛型则是通过擦除（erasure）来实现的。泛型只在编译时强化类型信息，在运行时擦除元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意互用。 利用有限制通配符提升API的灵活性PECE producer-extends，consumer-siper如果参数化类型表示生产者T，就使用&lt;? extends T&gt;，如果表示消费者T，就使用&lt;? super T&gt; 12345678910//src产生E实例供使用，是生产者public void pushAll(Iterable&lt;? extands E&gt; src) &#123; for (E e : src) push(e);&#125;//dst消费E实例，是消费者public void popAll(Collection&lt;E&gt; dst) &#123; while(!isEmpty()) &#123; dst.add(pop()); &#125;&#125; 不要用通配符类型作为返回参数 枚举和注解用enum代替int常量（android不推荐使用enum） 枚举本质上是int值 枚举允许添加任意的方法和域 12345678910111213141516171819public enum Test &#123; APPLE(&quot;test1&quot;, 2), pen(&quot;test2&quot;, 1); private final String name; private final int num; Test(String name, int num) &#123; this.name = name; this.num = num; &#125; public void print() &#123; Log.e(&quot;zyz&quot;, APPLE.name + APPLE.num); &#125;&#125;//遍历枚举Test[] values = Test.values(); 用实例域代替序数 所有枚举都有一个ordinal方法，返回每个枚举常量在类型中的数字位置。避免使用ordinal方法，除非是编写EnumSet和EnumMap这种基于枚举的通用数据结构。使用实例域（类似成员变量）来保存与枚举相关的值。 注解 注解类型声明 12345@Retention(RetentionPolicy.RUNTIME) //运行时保留@Target(ElementType.METHOD) //只在方法声明中才是合适的public @interface MyTest &#123; &#125; 坚持使用Override注解覆盖equals时的参数是Object类型的，否则则变成了重载。但如果使用@Override注解后写错了编译器就会报错。 用标记接口定义类型 标记接口是没有包含方法声明的接口，只是指名了某个类实现了具有某种属性的接口（例如Serializable接口） 标记接口胜过标记注解的两点： 接口定义的类型是由被标记类的实例实现的，注解则没有定义这样的类型。这个类型允许你在编译时捕捉到错误，而不像注解需要在运行时才能捕捉到 接口可以被更加精确地锁定。假设一个标记只适用于特殊接口的实现，如果定义成标记接口就可以用它将唯一的接口扩展成它适用的接口。 注解胜过接口的两点： 注解可以不断演变。而接口通常不可能在实现后再给它添加方法。 注解是注解机制的一部分。注解可以作为支持注解作为编程元素之一的框架中具有一致性。 接口和注解使用场景： 如果标记是应用到任何程序元素而不是类或接口，就必须使用注解，因为只有类和接口可以用来实现或扩展接口。 如果标记只给类和接口，若要编写多个只接受有这种标记的方法则优先使用接口，这样可以在编译时进行类型检查。 如果要永远限制这个标记只用于特殊接口的元素，最好将标记定义成该接口的一个子接口。 如果2，3都是否定的，则应该使用注解。 方法检查参数的有效性 assert 对于有些参数，方法本身没有用到，却被保存起来供以后使用，可以使用断言检验这类参数的有效性。如果断言失败，则会抛AssertionError。 必要时进行保护性拷贝 如果类的成员是可变的，为了保护内部信息变化，对于构造器的每个可变can’shu参数进行保护性拷贝是必要的，使用被封对象作为实例的组件，而不使用原始的对象。但注意，保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象而不是原始对象。 慎用clone。如果对于非final的成员，不能保证clone方法一定返回同样的类的对象，它有可能返回专门出于恶意目的而设计的不可信子类的实例，例如这样的子类可以在每个实例被创建时把指向该实例的引用记录到一个私有的静态列表中，并且允许攻击者访问这个列表，这将使得攻击者可以自由地控制所有的实例。为了阻止这种攻击，对于参数类型可以被不可信任方子类话的参数，请不要使用clone方法进行保护性拷贝。 另外需要修改访问方法，返回可变内部域的保护性拷贝： 123public Data end() &#123; return new Data(end.getTime());&#125; 只要可能，都应该使用不可变的对象作为对象内部的组件，这样就不必再为保护型拷贝操心。 慎用重载 类型还是父类，虽然调用父类方法指向子类引用。 安全而保守的策略是：永远不要导出两个具有相同参数数目的重载方法。如果方法使用可变参数，保守的策略是根本不要重载它。 慎用可变参数 如果客户端调用这个方法时并没有传递参数进去，它就会在运行时而不是编译时失败。 1234567//带两个参数，避免没有传参导致的问题static init min(int firstArg, int... remainingArgs) &#123; int min = firstArg; for(int arg : remainingArgs) &#123; ... &#125;&#125; 在重视性能的情况下，使用可变参数要特别小型，可变参数方法的每次调用都会导致进行一次数组分配和初始化。可以使用多个重载方法，每个重载方法带有0至3个普通参数，当参数数目超过3个时，就使用可变参数方法。 返回零长度的数组或集合，而不是null通用程序设计for each循环优于传统的for循环 如果你在编写的类型是一组元素，实现Iterable可以允许用户利用for-each循环遍历你的类型。 三种常见的无法使用for-each的情况： 过滤——需要遍历集合并删除选定元素 转换——需要遍历集合并取代它的部分或全部元素值 平行迭代——需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量以便所有迭代器或索引变量都可以得到同步前移 了解和使用类库 伪随机数生成器 1234//错误Math.abs(new Random().nextInt());//正确Random.nextInt(int) 了解和使用标准类库提供的便利工具，而不用浪费时间为那些与工作不太相关的问题提供特别的解决方案。标准类库太庞大了，以至于不可能去学习所有文档，但是每个程序员都应该熟悉java.lang，java.util，某种程度上还有java.io种的内容。有两种工具值得特别一提。 Collections Framework 用来表示和操作集合 java.util.concurrentbao’zhong包中增加了一组并发使用工具 总而言之，不要重新发明轮子，如果你要做的事情看起来是十分常见的，有可能类库中已经有某个类完成了这样的工作。 如果需要精确的答案，请避免使用float和doublefloat和double类型尤其不适合用于货币计算，因为要让一个float或double精确地表示0.1（或者10的ren’he’qi’ta任何其他负数次方值）是不可能的。 改进使用BigDecimal代替double： 1BigDecimal bigDecimal = new BigDecimal(0.1); BigDecimal允许你完全控制舍入，每当一个操作设计舍入的时候，它允许你从8种舍入模式中选择其一。但是缺点是与基本运算类型比，不仅不方便，而且很慢。如果性能非常关键，并且又不介意自己记录是金子小数点，而且涉及的数值又不太大，就可以使用int或long（例如0.1改变单位计作10）。如果数值范围没超过9位十进制数字，就可以使用int。如果不超过18位数值，就可以使用long。如果数值超过18位数字，就必须使用BigDecimal。 基本类型优于装箱基本类型当程序装箱了基本类型值时，会导致高开销和不必要的对象创建。 当心字符串连接的性能连接操作符不适合运用在大规模的场景中，为连接n个字符串而重复地使用字符串连接操作符，需要n的平方级的时间。这是由于字符串不可变，当两个字符串被连接在一起时，它们的内容都要被拷贝。 使用StringBuilder：12StringBuilder test = new StringBuilder(&quot;test&quot;);test.append(&quot;test2&quot;) 通过接口引用对象如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类。 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 这样会使程序更灵活，当你决定更换实现时，只需要改变构造器中类的名称： 1List&lt;String&gt; list = new Vector&lt;&gt;(); 所有的代码都可以继续工作，代码并不知道原来的实现类型，所以对于这种变化并不在意。 接口优先于反射机制反射机制允许一个类使用另一个类，即使当前者被编译的时候后者还根本不存在，然而这种能力也是要付出代价的： 丧失了编译时类型检查的好处（包括异常检查） 执行反射访问所需要的代码非常笨拙和冗长 性能损失 异常只针对异常的情况才使用异常123456789//Dont&apos;t do thistry &#123; int i = 0; while (true) &#123; range[i++].climb(); &#125;&#125; catch (ArrayIndexOutOfBoundsException e) &#123; &#125; 不要优先使用基于异常的模式： 异常机制的设计初衷是用于不正常的情形，所以很少会有JVM实现试图对它们进行优化。 代码块放在try-catch块中反而阻止了现代JVM实现本来可能要执行的某些特定优化。 对数组进行比那里的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。 基于异常的循环模式不仅模糊了代码的意图，还降低了性能，而且它还不能保证正常工作，如果出现不想关的bug，这个模式会悄悄地失效。 努力使失败保持原子性一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法被称为具有失败原子性（failure atomic)。有几种途径可以实现这种效果： 在执行操作前检查参数的有效性，这可以使在对象状态被修改前先抛出适当的异常。 调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修之前发生。 编写一段恢复代码，由它来拦截操作过程发生的失败，以及使对象回滚到操作开始之前的状态，这种办法主要用于永久性的数据结构。 在对象的一份临时拷贝上执行操作，操作完成之后再用临时拷贝中的结果代替对象的内容。 不要忽略异常忽略一个异常非常容易，只需将方法调用通过try语句包围起来，并包含一个空的catch块。空的catch块会使异常达不到应有的目的，至少，catch块也应该包含一条说明，解释为什么可以忽略这个异常。 并发正确地使用同步可以保证没有任何方法会看到对象处于不一致的状态中。它还可以保证刚进入同步方法或者同步代码块的每个线程，都看到由同一个锁保护的之前所有的修改效果。换句话说，读取一个非long或double类型的变量，可以保证返回的值是某个线程保存在该变量中的，即使多个线程在没有同步的情况下并发地修改这个变量也是如此。 不要使用 Thread.stop方法。要阻止一个线程妨碍另一个线程，建议做法是让第一个线程轮训一个boolean域，这个域一开始为false，但是可以通过第二个线程设置为true，以表示第一个线程将终止自己。由于boolean域的读写操作都是原子的，程序员在访问这个域的时候不再使用同步。 实际上，如果读和写操作没有都被同步，同步就不会起作用。 如果变量修饰符是volatile，则读取变量时不需要锁，虽然volatile修饰符不执行互斥访问，但它可以保证任何一个线程在读取该域的时候都将看到最近刚刚被写入的值。 使用volatile的时候务必要小心。123456//错误private static volatile int number = 0;//需要使用synchronizationpublic static int getNumber() &#123; return number++;&#125; 虽然number是原子的，但是增量操作符不是原子的，它首先读取值，然后写回一个新值。如果第二个线程在第一个线程读取旧值和返回新值期间读取这个域就会出错。 避免过度同步在一个被同步的区域内部，不要调用设计成要被覆盖的方法，或者是由客户端以函数对象的形式提供的方法。这样的方法是外来的，这个类不知道方法会做什么事情，也无法控制它，从同步区域中调用它很可能会导致异常、死锁或者数据损坏。 通常，你应该在同步区域内做尽可能少的工作。如果你必须要执行某个很耗时的动作，应该设法把这个动作移到同步区域的外面。 executor 和 task 优先于线程Java1.5增加了java.util.concurrent，这个包中包含了一个Executor Framework：12345ExecutorService executorService = Executors.newSingleThreadExecutor();//执行提交一个runnable方法executorService.execute(runnable);//告诉executor如何优雅地终止executor.shutdonw(); 你可以利用executor service完成更多的事情。例如，可以等待一个任务集合中的任何任务或所有任务完成（invokeAny或invokeAll），你可以等待executor service优雅地完成终止（awaitTermination），可以在任务完成时逐个地获取这些任务的结果（ExecutorCompletionService）等。 并发工具优于wait和notify自从java1.5发型版本开始，java就提供了更高级的并发工具，他们可以完成以前必须在wait和notify上手写代码来完成的各项工作。其分成三类： Executor Framework 并发集合（Concurrent Collectionin） 同步器（Synchronizer）并发集合为标准的集合接口（如List、Queue、Mpa）提供了高性能的并发实现。为了提供高并发性，这些实现在内部自己管理同步，因此，并发集合中不可能排除并发活动，将它锁定没有什么作用，只会是程序的速度变慢。 同步器（Synchronizer）是一些使线程能够等待另一个线程的对象，允许他们协调动作。最常用的同步器是CountDownLatch和Semaphore。 倒计数锁存器（CountDown Latch）是一次性的障碍，允许一个或者多个线程等待一个或者多个其他线程来做某些事情。CountDownLatch是唯一构造器带有一个int类型的参数，这个int参数是指允许所有在等待的线程被处理之前，必须在锁存器上调用countDown方法的次数。 例如：一个方法带有一个执行该动作的executor，一个并发级别（表示要并发执行该动作的次数），以及表示该动作的runnable。所有的工作线程自身都准备好，要在time线程启动时钟之前运行该动作（为了实现准确的定时）。当最后一个工作线程准备好运行该动作时，timer线程就“发起头炮”，同事允许工作线程执行该动作，一旦最后一个工作线程执行完该动作，timer线程就立即停止计时。直接在wait和notify上实现这个逻辑至少来说会很混乱，而在CountDownLatch之上实现则相当简单： 12345678910111213141516171819202122232425public long getTime(Executor executor, int councurrency, final Runnable action) throws InterruptedException &#123; final CountDownLatch ready = new CountDownLatch(councurrency); final CountDownLatch start = new CountDownLatch(1); final CountDownLatch done = new CountDownLatch(councurrency); for (int i = 0; i &lt; councurrency; i++) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; ready.countDown(); try &#123; start.await(); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; finally &#123; done.countDown(); &#125; &#125; &#125;); &#125; ready.await(); long startNano = System.nanoTime(); start.countDown(); done.await(); return System.nanoTime() - startNano; &#125; 用ready来告诉timer线程他们已经准备好了。然后工作线程会在start上等待。当最后一个工作线程调用ready.countDown时，timer线程记录下起始时间，并调用start.countDown，允许所有的工作线程继续进行。然后timer线程在done上等待，直到最后一个工作线程运行完该动作，并调用donw.countDown。一旦调用这个，timer线程就会苏醒过来，并记录下结束时间。 wait方法的标准模式： 12345synchronized(obj) &#123; while() &#123; obj.wait(); //release lock, and reacquires on wakeup &#125;&#125; 始终应该使用wait循环模式来调用wait方法；永远不要在循环之外调用wait方法。循环会在等待之前和之后测试条件。 线程安全性的文档化线程安全性的几种级别。（这份列表并没有涵盖所有的可能，而只是些常见的情形： 不可变的（immutable）：这个类的实例是不变的。所以不需要外部的同步，例如String、Long、BigInteger。 无条件的线程安全（unconditionnally thread-safe)：这个类的实例是可变的，但是这个类有着足够的内部同步，所以它的实例可以被并发使用，无需任何外部同步。 例如：Random和ConcurrentHashMa 有条件的线程安全(conditionally thread-safe)：除了有些方法为进行安全的并发而使用需要外部同步 非线程安全（not thread-safe）：这个类的实例是可变的。为了并发地使用它们，客户必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如ArrayList和HashMap。 线程对立的（thread-hostile）：这个类不能安全地被多个线程并发使用，即使所有的方法调用都被外部同步包围。线程对立的根源通常在于，没有同步地修改静态数据。Java平台类库中，线程对立的类或者方法非常少。System.runFinalizersOnExit方法是线程对立的，但已经被废除了。 12345678//私有锁对象private final Object lock = new Object();public void foo() &#123; synchronized(lock) &#123; ... &#125;&#125; 私有锁对象模式只能用在无条件的线程安全类上。有条件的线程安全类不能使用这种模式，因为它们必须在文档中说明：在执行某些方法调用序列时，它们的客户端程序必须获得哪把锁。 私有锁对象模式特别适用于那些专门为继承而设计的类。如果这种类使用它的实例作为锁对象，之类可能很容易在无意中妨碍基类的操作，反之亦然，出于不同的目的而使用相同的锁，子类和基类很可能会“互相绊住对方的脚”。 有条件的线程安全类必须在文档中指明哪些方法调用序列需要外部同步，以及在执行这些序列的时候需要获得哪把锁。如果你编写的是无条件的线程安全类，就应该考虑使用私有锁对象来代替同步的方法以防止客户端程序和子类的不同步干扰。 慎用延迟初始化如果处于性能的考虑需要对静态域使用延迟初始化： 12345private static class FieldHolder &#123; static final FieldType field = computeFieldValue();&#125;static FieldHolder getField() &#123; 如果处于性能的考虑需要对实例域使用延迟初始化： 12345678910111213private volatile FieldType field; FieldTpye getField() &#123; FieldType result = field; if(result == null) &#123; //First check(no locking) synchronized (this) &#123; result = field; if(result == null) //Second check(with locking) field = result = computeFieldValue(); &#125; &#125; return result;&#125; 如果需要延迟初始化一个可以接受重复初始化的实例域： 123456789private volatile FieldType field; private FieldType getField() &#123; FieldType result = field; if(result == null) &#123; field = result = computeFiedlValue(); &#125; return result;&#125; 不要依赖于线程调度器线程不应该一直处于忙-等状态，即反复地检查一个共享对象，以等待某些事情的发生。 不要让应用程序的正确性依赖于线程调度器，否则结果得到的应用程序将既不健壮，也不具有可移植性。不要依赖Thread.yield或者线程优先级。线程优先级可以用来提高一个已经能够正常工作的程序的服务质量，但永远不应该用来“修正”一个原本能不能工作的程序。 序列化谨慎地实现Serializable接口实现Serializable接口而付出的巨大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。如果一个类实现了Serializable接口，它的字节流编码（序列化形式）就变成了它的导出的API的一部分，一旦这个类被广泛使用，往往必须永远支持这种序列化形式。 第二个代价是，它增加了出现bug和安全漏洞的可能性。你可能会忘记确保：反序列化过程必须也要保证所有“由真正的构造器建立起来的约束关系”，并且不允许攻击者访问正在构造过程中的对象的内部信息。 第三个代价是，随着类发行新的版本，相关的测试负担也增加了。可序列化的类被修订后，你必须既要确保“序列化-反序列化”过程成功，也要确保结果产生的对象真正是原始对象的复制品。 内部类不应该实现Serializable。 如果一个类为了继承而设计，要更加小心。对于这样的类而言，在“允许子类实现Serializable接口”或者“禁止子类实现serialzable”两者间的一个折衷方案是：提供一个可访问的无参构造器，这种方案允许（但不要求）子类实现Serializable接口。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App Shortcuts 快捷方式 Android7.1 的'3D Touch']]></title>
    <url>%2F2017%2F01%2F10%2FApp-Shortcuts-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F-Android7-1-%E7%9A%84-3D-Touch%2F</url>
    <content type="text"><![CDATA[Hello Shortcuts从Android7.1（API level25）开始，开发者可以为自己的app定制shortcuts。shortcuts使用户更便捷、快速的使用app。我个人感觉有点像ios的压力感应，但是我认为Google的shortcuts动画做的更好看：）。 shortcuts分为两种： Static shortcuts：静态shortcuts是在资源文件中定义的，所以你只能通过升级你的app来更新静态shortcuts的相关信息。 Dynamic shortcuts：动态shortcuts是通过ShortcutManager相关的API来实现运行时新增、修改、移除shortcuts的。 另外关于shortcuts有以下几点小tips： 最多可以设置5个快捷方式，（但经测试最多只能显示4个）。有些启动器（launcher app）不会显示出你添加的所有的快捷方式。 用户可以长按shortcuts将其固定到桌面，Google称其为“pinned shortcuts”，pinned shortcuts的数量是没有限制的，并且开发者无权移除这些pinned shorcuts(只能用户自己移除或者删除app后自动移除，如果某个shortcuts已经被固定到桌面，即使动态删除了该shortcuts，桌面的shortcuts也不会消失且可以正常使用)，但可以将其设为不可用状态（disbale）。 虽然其他app无法通过shortcuts访问你的app的元数据（metadata），但启动器（laucher）可以，所以在使用shortcuts时要注意保护用户的隐私信息。 静态shortcuts（Static Shortcuts）的使用 清单文件Manifest中在启动页添加meta-data 12345678&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.app.shortcuts&quot; android:resource=&quot;@xml/shortcuts&quot; /&gt;&lt;/activity&gt; res文件夹内新建文件夹xml，新建文件shortcuts.xml 12345678910111213141516171819202122232425262728293031323334//shortcuts.xml&lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;shortcut android:shortcutId=&quot;shortCutId1&quot; android:enabled=&quot;true&quot; android:icon=&quot;@drawable/icon_android&quot; android:shortcutShortLabel=&quot;@string/compose_shortcut_short_label1&quot; android:shortcutLongLabel=&quot;@string/compose_shortcut_long_label1&quot; android:shortcutDisabledMessage=&quot;@string/compose_disabled_message1&quot;&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetPackage=&quot;com.example.zengyazhi.myapplication&quot; android:targetClass=&quot;com.example.zengyazhi.myapplication.Main1Activity&quot; /&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetPackage=&quot;com.example.zengyazhi.myapplication&quot; android:targetClass=&quot;com.example.zengyazhi.myapplication.Main2Activity&quot; /&gt; &lt;categories android:name=&quot;android.shortcut.conversation&quot; /&gt;&lt;/shortcut&gt;&lt;shortcut android:shortcutId=&quot;shortCutId2&quot; android:enabled=&quot;true&quot; android:icon=&quot;@drawable/icon_google&quot; android:shortcutShortLabel=&quot;@string/compose_shortcut_short_label2&quot; android:shortcutLongLabel=&quot;@string/compose_shortcut_long_label2&quot; android:shortcutDisabledMessage=&quot;@string/compose_disabled_message2&quot;&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetPackage=&quot;com.example.zengyazhi.myapplication&quot; android:targetClass=&quot;com.example.zengyazhi.myapplication.Main2Activity&quot; /&gt; &lt;categories android:name=&quot;android.shortcut.conversation&quot; /&gt;&lt;/shortcut&gt; 解释一下shortcut标签里的各个的属性： shortcutId：shortcuts的ID enabled：如果为false则不会在长按shortcuts列表中显示 icon：shortcuts的图标 shortcutShortLabel：当shortcuts固定到桌面时的标题（注意字符串只能使用string资源文件引用，不可以直接使用字符串） shortcutLongLabel：长按app出现shortcuts时的标题，如果太长或未设置默认会显示shortcutShortLabel shortcutDisabledMessage： 当pinned shortcuts不可用时的toast提示信息 shortcuts标签内的标签可以有多个，例如页面1、页面2、页面3，用户点击shortcuts后进入的是列表的最后一个（即页面3），并且可以依次回退到页面2、页面1. 动态shortcuts（Dynamic Shortcuts）的使用使用ShortcutManager相关API来创建、更新、移除shortcuts。几种API的使用方法都类似。 使用 setDynamicShortcuts() 和 addDynamicShortcuts() 来动态增加shortcuts。这两个方法有点相似，使用时要注意区别。addDynamicShortcuts()：添加shortcuts，如果存在相同的ID的shortcuts则更新信息。setDynamicShortcuts()：替换掉已有的动态shortcuts列表，如果存在相同的ID的shortcuts则更新信息。举个例子：例如原本有shortcuts列表： 标签一（lable：张三， id：one） 标签二（lable：李四， id：two） 标签三（lable：王五， id：three） 使用 setDynamicShortcuts() 方法并传入两个ShortcutInfo： 标签三（lable：赵六， id：three） 标签四（lable：钱七， id：four） 调用方法后会使shortcuts列表则变为： 标签三（lable：赵六， id：three） 标签四（lable：钱七， id：four） 因为标签三的ID相同，所以更新标签三，而shortcuts列表中原来的标签一、二被移除，而且一开篇介绍shortcuts时也提到过是：如果shortcuts已被固定到桌面成为pinned shortcuts，即使shortcuts从列表中被移除了，但桌面的pinned shortcuts依然可以正常使用，除非你将其设置disable状态，即如果张三、李四被固定到桌面，即使调用 setDynamicShortcuts() 后长按app不会显示张三、李四，但桌面上的张三李四不会消失且可以正常使用。 使用 updateShortcuts() 更新shortcuts的信息 123456789ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);ShortcutInfo shortCutId1 = new ShortcutInfo.Builder(MainActivity.this, &quot;shortCutId3&quot;) .setShortLabel(&quot;更改桌面标签3&quot;) .setLongLabel(&quot;更改快捷方式标签3&quot;) .setIcon(Icon.createWithResource(this, R.drawable.icon_chrome)) .setDisabledMessage(&quot;更改不可用时提示信息3&quot;) .setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.baidu.com/&quot;), this, Main1Activity.class)) .build();shortcutManager.updateShortcuts(Arrays.asList(shortCutId1, shortCutId4)); 动态shortcuts也可以像静态shortcuts一样同时添加多个intent意图 12345678Intent intent1 = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.baidu.com/&quot;), this, Main1Activity.class);Intent intent2 = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.baidu.com/&quot;), this, Main2Activity.class);Intent[] intents = &#123;intent1, intent2&#125;;....setIntents(intents).build();... 使用 removeDynamicShortcuts() 移除单个或多个动态shortcuts，使用 removeAllDynamicShortcuts() 移除所有的动态shortcuts 123shortcutManager.removeDynamicShortcuts(Arrays.asList(&quot;shortCutId31&quot;, &quot;shortCutId4&quot;));shortcutManager.removeAllDynamicShortcuts(); 设置shortcuts为不可用状态： 123shortcutManager.disableShortcuts(Arrays.asList(&quot;shortCutId3&quot;));//另一个重载的方法，可以在用户点击该shortcuts时显示错误信息shortcutManager.disableShortcuts(Arrays.asList(&quot;shortCutId4&quot;), &quot;快捷方式4已不可用&quot;); 需要注意的是：以上API只能操作动态shortcuts（包括pinned shortcuts），不可操作静态shortcuts，如果传入静态shortcuts的id会报IllegalArgumentException错误：Manifest shortcut ID=*** may not be manipulated via APIs 追踪shortcuts的使用官网文档中提到以下两种情景需要调用reportShortcutUsed(): 用户点击了shortcuts 用户操作了与shortcuts关联的操作 上报shortcuts的使用来预测shortcuts的优先级，帮助开发者更好得使用shortcuts。 shortcuts设计规范App Shortcuts Design Guidelines Android从material design设计规范推出开始到今天的Android7，个人觉得真的是不输iOS，然而至今没有广泛地被推崇，实在令人不免一声叹息。另外手上2013年发布的Nexus5升级Android7之后竟然感觉比以前还顺滑，什么叫良心？跟我一起大喊：Google大法好！]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fresco 二三事：图片处理之旋转、缩放、裁剪切割图片]]></title>
    <url>%2F2016%2F12%2F03%2FFresco-%E4%BA%8C%E4%B8%89%E4%BA%8B%EF%BC%9A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E4%B9%8B%E6%97%8B%E8%BD%AC%E3%80%81%E7%BC%A9%E6%94%BE%E3%80%81%E8%A3%81%E5%89%AA%E5%88%87%E5%89%B2%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[关于Fresco加载图片的处理，例如旋转、裁剪切割图片，在官方文档也都有提到，只是感觉写的不太详细，正好最近项目里有类似需求，所以分享一些使用小tip，后面的朋友就不用再走弯路浪费时间了。（测试图片分辨率1200*800） 原图： 裁剪图片实现旋转图片123456789101112131415/** * 旋转图片 * * @param rotate ，例如：RotationOptions.ROTATE_90 */private void rotate(SimpleDraweeView img, int rotate) &#123; RotationOptions rotationOptions = RotationOptions.forceRotation(rotate); ImageRequest build = ImageRequestBuilder.newBuilderWithSource(getUriForFresco(this, R.mipmap.test_img)) .setRotationOptions(rotationOptions) .build(); PipelineDraweeController controller = (PipelineDraweeController) Fresco.newDraweeControllerBuilder() .setImageRequest(build) .build(); mImageView.setController(controller);&#125; 使用效果： 监听图片下载首先构造监听器： 123456789//监听图片下载进度，这里只重写了onFinalImageSet，当图片下载完成时获得图片宽高等信息ControllerListener controllerListener = new BaseControllerListener&lt;ImageInfo&gt;() &#123; @Override public void onFinalImageSet(String id, com.facebook.imagepipeline.image.ImageInfo imageInfo, Animatable animatable) &#123; int viewWidth = imageInfo.getWidth(); int viewHeight = imageInfo.getHeight(); Toast.makeText(MainActivity.this, viewWidth + &quot;--&quot; + viewHeight, Toast.LENGTH_SHORT).show(); &#125; &#125;; 123456789101112/** * 获得图片宽高 * * @param controllerListener 图片下载监听器 */private void getImageInfo(ControllerListener&lt;? super ImageInfo&gt; controllerListener) &#123; PipelineDraweeController controller = (PipelineDraweeController) Fresco.newDraweeControllerBuilder() .setControllerListener(controllerListener) .setUri(getUriForFresco(this, R.mipmap.test_img)) .build(); mImageView.setController(controller);&#125; 如果我想要1：1在手机端展示呢？我首先想到的是1：1按照图片的尺寸设置SimpleDraweeView的宽高并设置缩放方式为fitXY，但是果不其然，view超出屏幕的部分是无效的。 裁剪切割图片既然view超出屏幕无效，那就曲线救国，让图片超出屏幕部分不显示在view里就好了。裁剪图片首先要写一个processor类： 1234567891011121314151617181920212223242526272829303132/** * 切割图片processor类 * 四个成员变量和createBitmap时的参数一致，即起点的X/Y坐标、要裁剪的宽高。因为项目里还涉及到缩放，所以我调整了下参数设成百分比方便换算 */public class CutProcess extends BasePostprocessor &#123; private float mBeginXPercent; private float mBeginYPercent; private float mCutWidthPercent; private float mCutHeightPercent; public CutProcess(float beginXPercent, float beginYPercent, float cutWidthPercent, float cutHeightPercent) &#123; this.mBeginXPercent = beginXPercent; this.mBeginYPercent = beginYPercent; this.mCutWidthPercent = cutWidthPercent; this.mCutHeightPercent = cutHeightPercent; &#125; @Override public CloseableReference&lt;Bitmap&gt; process( Bitmap sourceBitmap, PlatformBitmapFactory bitmapFactory) &#123; int viewWidth = sourceBitmap.getWidth(); int viewHeight = sourceBitmap.getHeight(); int beginx = (int) (mBeginXPercent * viewWidth); int beginy = (int) (mBeginYPercent * viewHeight); int width = (int) (mCutWidthPercent * viewWidth); int height = (int) (mCutHeightPercent * viewHeight); CloseableReference&lt;Bitmap&gt; bitmapRef = bitmapFactory.createBitmap (sourceBitmap, beginx, beginy, width, height); return CloseableReference.cloneOrNull(bitmapRef); &#125;&#125; 然后在ImageRequest里setProcessor： 123456789101112131415/** * 裁剪图片 * @param processor */ private void cutPic(BasePostprocessor processor) &#123; ImageRequest build = ImageRequestBuilder.newBuilderWithSource(getUriForFresco(this, R.mipmap.test_img)) .setPostprocessor(processor) .build(); PipelineDraweeController controller = (PipelineDraweeController) Fresco.newDraweeControllerBuilder() .setImageRequest(build) .build(); mImageView.setController(controller); &#125; 调用方法： 123mImageView.setLayoutParams(new RelativeLayout.LayoutParams(600, 400));CutProcess cutProcess = new CutProcess(0, 0, 0.5f, 0.5f);cutPic(cutProcess); 图片是1200800的，这里设置view的宽高为600400，可以看到图片成功裁剪只保留原图左上四分之一。通过设置view宽高，配合裁剪图片，即可达到1：1显示的效果。 旋转+裁剪如果是要旋转90度后再裁剪呢？那还不简单，直接在裁剪的基础上，在ImageRequest里调用旋转方法不就好了。 123456789101112131415161718/** * 旋转+裁剪图片 * @param processor */ private void rotateAndcutPic(BasePostprocessor processor, int rotate) &#123; RotationOptions rotationOptions = RotationOptions.forceRotation(rotate); ImageRequest build = ImageRequestBuilder.newBuilderWithSource(getUriForFresco(this, R.mipmap.test_img)) .setPostprocessor(processor) .setRotationOptions(rotationOptions) .build(); PipelineDraweeController controller = (PipelineDraweeController) Fresco.newDraweeControllerBuilder() .setImageRequest(build) .build(); mImageView.setController(controller); &#125; 然后调用： 1234//例如我需要旋转90度且宽度不变，高度方向裁剪掉一半（即保留(0,0)-（1200,400））mImageView.setLayoutParams(new RelativeLayout.LayoutParams(400, mScreenHeight));CutProcess cutProcess = new CutProcess(0, 0, 1f, 0.5f);rotateAndcutPic(cutProcess, RotationOptions.ROTATE_90); 然而得到的并不是我们想要的 可以看到得到的是左半边(0,0)-(600,800)的图，即宽度方向被裁剪掉一般，高度方向不变，明明我在cutProcess里是设置宽度方向不变，高度方向裁剪50%，但是因为旋转了90度，结果却正好相反。难道是因为旋转90度后横纵方向也发生改变？那调换一下横纵方向的切割比例试试看： 12CutProcess cutProcess = new CutProcess(0, 0, 0.5f, 1f);rotateAndcutPic(cutProcess, RotationOptions.ROTATE_90); 可以看到，调换横纵切割比例后，却得到的是下半边(0,400)-(1200,800)。还是不正确，难道是原点也改变了？再测试一下，如果要裁剪后保留右下四分之一(600,400)-(1200,800)区域，正常无旋转的情况下是这样的： 123mImageView.setLayoutParams(new RelativeLayout.LayoutParams(600, 400));CutProcess cutProcess = new CutProcess(0.5f, 0.5f, 0.5f, 0.5f);rotateAndcutPic(cutProcess, RotationOptions.NO_ROTATION); 但如果旋转270度后，同样代码得到的结果却是这样的： 看到这里我们就清楚了，旋转图片后，其实(0,0)点，也就是所谓的原点也随之变换。默认情况下，原点是（0,0），顺时针旋转90度后，原点就变成了(0,800)，以此类推旋转180度原点为(1200,800)，旋转270度原点为(1200,0)（和旋转后的图片的左上角相对应）。虽然是在构建ImageRequest时同时传入旋转和裁剪参数的，但实际上可以看作是先完成了旋转，然后在旋转后的基础上，以屏幕的左上角为原点，左上角往右为x正方向，左上角往下为y正方向。 小试牛刀一下，旋转270度后，想要裁剪后只保留原图的左上四分之一(0,0)-(600,600)，那推测就应该是(0, 0.5f, 0.5f, 0.5f)。 123mImageView.setLayoutParams(new RelativeLayout.LayoutParams(400, 600));CutProcess cutProcess = new CutProcess(0, 0.5f, 0.5f, 0.5f);rotateAndcutPic(cutProcess, RotationOptions.ROTATE_270); Bingo！推测正确。 旋转+裁剪就是这个原点的变换要注意下。另外看代码里的几个方法，裁剪、旋转、获得宽高等，有没有觉得老是要重复写PipelineDraweeController、ImageRequest的代码好麻烦啊。其实裁剪、旋转等方法无非也就是添加一个参数，类似这种可变参数的复杂类的构造可以使用Builder模式封装一下。封装代码就不贴在这里了。demo下载地址 123456//Builder模式封装后new FrescoBuilder(mImageView, getUriForFresco(this, R.mipmap.test_img)) .cutPic(0f, 0.5f, 0.5f, 0.5f) //裁剪 .setRotate(RotationOptions.ROTATE_270) //旋转 .setControllerListener(controllerListener) //设置监听 .build(); 使用Matrix实现继承 SimpleDraweeView 自定义控件，使用Matrix实现旋转缩放： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class MyFresco extends SimpleDraweeView &#123; private Matrix mMatrix; private float mScaleX = 1f; private float mScaleY = 1f; private int mViewWidth = -1; private int mViewHeight = -1; private RectF mDisplayRect = new RectF(); private int mDegree = -1; public MyFresco(Context context, GenericDraweeHierarchy hierarchy) &#123; super(context, hierarchy); init(); &#125; public MyFresco(Context context) &#123; super(context); init(); &#125; public MyFresco(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public void setViewInfo(int width, int Height) &#123; mViewWidth = width; mViewHeight = Height; &#125; private void init() &#123; mMatrix = new Matrix(); mMatrix.postScale(mScaleX, mScaleY); &#125; /** * 缩放 * @param scaleX 缩放倍数 */ public void setScale(float scaleX, float scaleY) &#123; mScaleX = scaleX; mScaleY = scaleY; mMatrix.postScale(scaleX, scaleY); invalidate(); &#125; /** * 旋转 * @param degree 角度 */ public void rotate(int degree) &#123; if (mDegree == -1) &#123; mDegree = degree; if (mDegree != 0) &#123; mMatrix.postRotate(degree); invalidate(); if (mDegree == 90) &#123; //旋转后图片超出边界，所以要再做平移 mMatrix.postTranslate(getRectWidth(), 0); &#125; else if (mDegree == 180) &#123; mMatrix.postTranslate(getRectWidth(), getRectHieght()); &#125; else if (mDegree == 270) &#123; mMatrix.postTranslate(0, getRectHieght()); &#125; &#125; &#125; else &#123; mDegree += degree; mMatrix.postRotate(degree); //getRectWidth是旋转后的width invalidate(); mMatrix.postTranslate(getRectWidth(), 0); &#125; invalidate(); &#125; /** * 还原设置 */ public void reset() &#123; mScaleX = 1f; mScaleY = 1f; mMatrix = new Matrix(); mMatrix.setScale(mScaleX, mScaleY); mViewWidth = -1; mViewHeight = -1; mDegree = -1; &#125; /** * 获得旋转后超出边界的高度 * @return */ public float getRectHieght() &#123; RectF displayRect = getDisplayRect(mMatrix); if (displayRect != null) &#123; return displayRect.height(); &#125; else &#123; return -1; &#125; &#125; /** * 获得旋转后超出边界的宽度 * @return */ public float getRectWidth() &#123; RectF displayRect = getDisplayRect(mMatrix); if (displayRect != null) &#123; return displayRect.width(); &#125; else &#123; return -1; &#125; &#125; private RectF getDisplayRect(Matrix matrix) &#123; if (mViewWidth == -1 || mViewHeight == -1) &#123; return null; &#125; mDisplayRect.set(0.0F, 0.0F, mViewWidth, mViewHeight); getHierarchy().getActualImageBounds(mDisplayRect); //将matrix映射到rectf matrix.mapRect(mDisplayRect); return mDisplayRect; &#125; @Override protected void onDraw(Canvas canvas) &#123; int save = canvas.save(); canvas.concat(mMatrix); super.onDraw(canvas); canvas.restoreToCount(save); &#125;&#125; 就是酱~]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native Android 环境搭建]]></title>
    <url>%2F2016%2F10%2F29%2FReact-Native-Android-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[因为工作需要，最近正在学习React Native Android。温故而知新，把学习的内容记录下来巩固一下知识，也给有需要的人一些帮助。 需要说明的是，我刚接触React Native也不久，对它的认识肯定还是比较浅薄甚至无知的，如有不对的地方恳请指出，求之不得，谢谢！ 那么让我们开始吧，对程序员来说，入门的第一课毫无疑问就是搭建环境。 环境搭建ChocolateyChocolatey是Windows上的一个包管理工具。官方推荐使用Chocolatey来安装Node.js和Python2。安装方法是直接在cmd里输入 1@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot; 第一步就报错了- -，不过从log可以很简单的看出，安装Chocolatey需要在管理员权限下的命令行中运行才可以。Win8启动管理员cmd是在左下角右键，就可以看到命令提示符（管理员）选项了，再次输入命令安装，安装成功后可见下图。 Node.js安装好Chocolatey后就可以在命令行里直接安装Node.js和Python了 1choco install nodejs.install Python2命令行里输入 1choco install python2 react-native-clireact-native-cli是React Native的命令行工具，用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。npm是随Node.js一起安装的包管理工具，所以利用npm安装react-native-cli，命令行里输入 1npm install -g react-native-cli Android Studio、SDK及环境变量配置这个可从官网直接下载带sdk的安装包直接安装即可，安装后配置一下环境变量ANDROID_HOME： 到这里，环境搭建就已经完成了。 新建项目环境配置好了，新建个项目来试试吧！打开cmd，进入要新建项目的位置，例如我要在F盘的根目录新建一个名为HelloReact的项目，cmd进入相应位置后输入： 1react-native init HelloReact 可以看到npm就会自动创建项目并下载相关的包 项目建立完成后，从命令行中可以看到 从cmd的提示中我们可以看到提示，项目建立后，要运行我们的android app的话，只要进入项目所在的地址，再输入命令react-native run-android就可以了，我们输入试试看 可以看到，输入命令后，会自动开启一个js server，默认运行在8081端口，app上通过load js bundle来加载js。但是令人纠结的是，自动创建的项目的gradle版本和本机的gradle版本不同，所以它同时也会自动下载项目对应的gradle，但是限于网络原因你懂的，有时候gradle真是要下到猴年马月，不过小 case，cmd里ctrl+c取消下载任务。参照我之前的一篇文章eclipse再见，android studio 新手入门教程（三）Github（.ignore忽略规则）的使用，修改HelloReact项目的gradle版本。修改后cmd再次输入react-native run-android，可以看到 如果可以看到BUILD SUCCESSFUL的话，应该app就已经安装到手机上了。如果一切顺利的话，你就会看到 看到这个的话就说明app跑成功啦。但这肯定不够令人满意，说好的Hello World呢？那我们就尝试修改一下，让app显示出我们自己想要的东西。 Android Studio中编译进入到刚才新建的HelloReact项目中我们可以看到项目的结构 使用记事本打开package.json，可以看到这里面记录了一些项目的信息，例如使用的react-native的版本号，等等。看到熟悉的android文件夹，点进去看，是不是很熟悉的结构？没错，这就是一个完整的android项目结构，使用Android Studio导入项目看看吧。 可以看到，在manifest中入口是MainApplication，并且activity中除了MainActivity外，还注册了一个DevSettingsActivity，这其实是一个设置界面，在app中通过摇一摇手机调出。 Application集成了ReactApplication，getPackages()实现了native和js的桥接。 我们再看MainActivity，其继承了ReactActivity，通过getMainComPonentName()方法返回了‘HelloReact’字符串，从注释可以粗略了解，MainActivity应该是作为一个main component（入口组件？）注册到了js中。整个app的机构中并没有看到熟悉的layout布局，那之前看到的那个界面是怎么实现的呢？还记得app上的字样吗？ To get started, edit index.android.js 答案就在项目根目录的index.android.js文件中，这个文件才是react native android的入口。打开看看吧 是不是看到了熟悉的字样？我们暂且偷偷懒，修改一下字符串看看效果怎么样。 修改保存后，从Android Studio里运行看看吧。 那么问题来了，package bundle是什么鬼？不过看起来是不是有点熟悉？还记不记得刚才使用命令行react-native run-android时会开启的js server，里面就有一个log显示React Packager ready，但我们已经编译好项目了，总不能每次都使用react-native run-android再重新编译安装一遍吧？当然不用，命令行里（注意，要进入项目根目录，也就是HelloReact，而不是HelloReact\Android。快捷一点的方式就是选中HelloReact文件夹后按住shift+右键，选择在此处打开命令行）输入react-native start就可以开启js server啦。试试看吧 开启成功后，手机摇一摇出现菜单，选择Reload 如果看到命令行中出现这些字样就说明加载js bundle成功啦。有时候你可能会看报这类错 解决方法是摇一摇手机，菜单里选Dev Settings，选Debug server host，填入你电脑的ip:8081，（命令行输入ipconfig，看IPv4地址，例如192.168.1.1:8081），填好后返回，Reload。 很快你也就可以在手机上看到 Hello World！缝缝补补总算看到啦。今天就先到这吧，下次再来写写怎么自己动手写一些简单的js，以及后续的在js中调用原生组件。 下篇博客见。]]></content>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin简单使用手册]]></title>
    <url>%2F2016%2F07%2F15%2FKotlin%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[在昨天和做android的前辈一番交谈后，觉得很惭愧，许多东西还只是知其然而不知其所以然，也深感自己的技术还太浅薄。以后要更加努力地学习，要着重学习原理、方法论，不能只停留在会用的阶段。 今天又要献丑分享一些关于使用Kotlin这门新兴的编程语言的一些要注意的地方。因为上一个项目全部使用了kotlin，算是给后面接手的朋友的一份交接文档吧。 先分享三篇文章：Kotlin for android developers为什么说Kotlin值得一试Kotlin: Java 6 废土中的一线希望 这三篇文章都是我反复阅读参考很多遍的关于kotlin使用的中文教程，当然，有时候遇到了中文教程里讲的不清楚，或者是感觉翻译不太对胃口的，可以直接去查阅官方文档。 遇到问题请善用资料，基本上都能从中得到解答。以下简单介绍一下常见的几个注意点。 变量类型：可空kotlin的特性之一是类型安全。定义变量时需要定义该变量是否为空，一旦要求变量不能为空，那后续的空指针问题自然也不复存在。我们先来看kotiln里是如何定义变量的： 1234567891011java：String str = &quot;test&quot;;final String str2 = &quot;test2&quot;；String str3;kotlin：var str = &quot;test&quot;val str2 = &quot;test2&quot;var str3:String ?= null kotlin使用var，val关键字定义变量，如果在定义变量时直接赋值，则可以不用指定变量类型，否则需要在变量名后使用“：”来指定类型。在类型后加“？”表示该变量可空。如果变量可空，那在后续使用变量时，就必须先判断是否为空。另外从代码中可以看出很重要的一点，那就是：从此再也不用写分号啦 123456789var a:Int = null //错误，类型后没？，即不可空类型，自然不能等于nullvar a:Int? = null //正确val canNull: Int ? = 0 canNull.toFloat //错误，可空变量调用时要判断空canNull?.toFloat //正确，(如果是null，什么都不做)canNull!!.Float //正确，(如果null，报空指针)val canNotNull: Int = 0 canNotNull.toFloat //正确 那如果在定义变量时（例如定义成员变量），又想该变量不为空，又不想子定义时就初始化要怎么办呢？使用lateinit关键字 123lateinit var test:String //正确lateinit val test：String //错误lateinit var test:Float //错误 关于lateinit关键字的使用限制： lateinit modifier is allowed only on mutable propertieslateinit modifier is not allowed on primitive type properties 可见，lateinit修饰符只能修饰不可空类型，并且不允许修饰基础类型（四类八种基础类型int， double，boolean等）。 常用语法：switch123456789101112131415161718java：int test = 1;switch（test） &#123; case 1: ... break; default: break;&#125;kotlin:when (test) &#123; 1 -&gt; fragment = ShopFragment() else -&gt; &#123; &#125;&#125; 这只是when最简单的用法，但kotlin里when的用处要比switch强大得多，when可以返回值，甚至可以在匹配条件里检测参数类型等，例如： 123456789101112131415161718val result = when (x) &#123; //返回值 0, 1 -&gt; &quot;test&quot; else -&gt; &quot;else&quot;&#125;when(view) &#123; //检测参数类型，并且可见，在kotlin里，instanceof使用is代替 is TextView -&gt; view.setText(&quot;I&apos;m a TextView&quot;) else -&gt; view.visibility = View.GONE&#125;var test = 3when（view） &#123; //检测参数范围 in 0..10 -&gt; &#123; ... &#125; else -&gt; &#123; ... &#125; 更多用法详见教程。 for循环123456789101112131415161718192021java：for（int i =0; i &lt; 5; i++） &#123;&#125;kotlin：for(i in 0..4) &#123;&#125;for (item in listData) &#123; //遍历列表，直接操作列表内的对象 item.method()&#125;for (i in listData.indices) &#123; //遍历列表带行index&#125;for（（i， item） in list.witnIndex()） &#123; //加强版&#125;listData.forEach &#123; it.method() &#125; //变种的for循环]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adnroid源码学习笔记：Handler 线程间通讯]]></title>
    <url>%2F2016%2F06%2F29%2FAdnroid%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AHandler-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[常见的使用Handler线程间通讯：123456789101112131415主线程：Handler handler = new Handler() &#123;@Override public void handleMessage(Message msg) &#123; ... &#125;&#125;;子线程：Message message = new Message(); message.arg1 = 1; Bundle bundle = new Bundle(); bundle.putString(&quot;test&quot;, &quot;test&quot;); message.setData(bundle); handler.sendMessage(message); 这类操作一般用于在子线程更新UI。在主线程创建一个handler，重写handlermessage方法，然后在子线程里发送消息，主线程里就会接受到消息。这就是简单的线程间通讯。如果在子线程创建handler对象则会报错。根据Log提示，子线程创建handler需要调用Looper.prepare() (在main函数中已经调用了Looper.prepareMainLooper()，该方法内会调起Looper.prepare())，Looper.loop()方法 。但是即使子线程调用Looper.prepare()创建Looper对象，这个Looper也是子线程的，不可以用于更新UI操作。那到底Handler、Looper这几个类之间是如何工作的呢？我们从源头看起，以下是Looper类的prepare()方法： 1234567891011121314151617181920public final class Looper &#123; ... final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); //threadLocal是线程内部的数据存储类，该类存储了线程的所有数据信息。 public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); //创建一个Looper（Looper的构造器里也创建了一个MessageQueue，），将Looper与线程关联起来 &#125; public static @Nullable Looper myLooper() &#123; //下面会看到的，设置Handler类里的Looper时会调用该方法 return sThreadLocal.get(); //获得Looper对象 &#125; ...&#125; 当handler传输message时，不论是调用sendMessage(Message msg)还是sendMessageDelayed(),最后都会指向sendMessageAtTime()方法： 1234567891011121314public class Handler &#123; ... public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; ...&#125; mQueue即消息队列，用于将收到的消息以队列形式排列，提供出队和入队方法，该变量是Looper的成员变量，在Handler创建时赋值给handler 12345678public class Handler &#123; ... final Looper mLooper; final MessageQueue mQueue; mLooper = Looper.myLooper(); //创建Handler前调用Looper.prepare()时定义并设置了Looper，这里调用Looper.myLooper()来获得该Looper mQueue = mLooper.mQueue; ...&#125; 上面调用的enqueueMessage(queue, msg, uptimeMillis)方法作用是消息入队 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; //把handler本身赋值给要入队的消息，用来待会儿出队使用 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 可以看到最后是由消息队列queue调用自身MessageQueue类的入队方法enqueueMessage() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; mMessages是MessageQueue类的一个成员变量，用以记录排在最前面的消息，msg是我们传入的message，msg.next是Message类的成员变量，可以理解成下一条消息。入列方法重点看这几句： 123Message p = mMessages;msg.next = p; //把mMessages赋值给新入队的这条消息的nextmMessages = msg; //把新入队的消息赋值给mMessages 就像排队一样，msg是来插队的，排第一的mMessages自愿排到msg的后面，并让msg站到自己原来的位置上，这样就完成的msg的入队操作,整个消息入队操作是按照时间来排序的。至于出队操作，就在一开始所提到的ActivityTread中的main方法里调用的Looper.loop（）方法里： 1234567891011121314public static void loop() &#123; ... for (;;) &#123; ... Message msg = queue.next(); //获取下一条消息 ... msg.target.dispatchMessage(msg); //传递消息 ... msg.recycleUnchecked(); //清空状态，循环往复 &#125; &#125; ...&#125; 提炼出来就是在loop方法里一直死循环，从MessageQueue消息队列里使用next()方法获得下一条消息，next方法简单看就是： 1234Message msg = mMessages;mMessages = msg.next;msg.next = null;return msg; 这就是简单的解释消息出列，把排第一的消息作为方法的返回值，然后让排第二的排到第一去。获得消息后使用msg.target（上面入队时赋值的handler）来传递消息： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); //如果有callback参数则调用处理回调的方法 &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); //将消息作为参数传递出去 &#125;&#125; 至此，handler传递消息的整个流程走完。另外还有一个我们经常用到handler的方法post： 123456789public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; //将runnable变成message自身的callback变量 Message m = Message.obtain(); m.callback = r; return m;&#125; 可以看到，post的runnable参数经过getPostMessage()方法最后被赋值给要传递下去的消息的callback这个变量，等到消息出列时，如果消息带有callback参数则调用处理回调的方法handleCallback(msg) 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 可以看到，不论是从sendMessage里发出的消息，还是在post传递的runnable里执行的代码，最后都是殊途同归，都是在UI线程运行的。最后总结一下吧，线程间通讯原理大概就是： Looper.prepare()创建Looper和MessageQueue，并与所在线程关联 Looper.loop()通过一个for死循环不断对MessageQueue进行轮询 创建handler时，会把Looper和MessageQueue赋值给handler，将三者关联起来。当handler调用sendMessage传递消息，消息会被发送到Looper的消息队列MessageQueue里 一旦loop()方法接收到消息，则将消息通过该消息携带的handler（msg.target）的handleMessage方法处理]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Python!用 Python 写一个抓取 CSDN 博客文章的简单爬虫]]></title>
    <url>%2F2016%2F06%2F25%2FHello%20Python!%E7%94%A8python%E5%86%99%E4%B8%80%E4%B8%AA%E6%8A%93%E5%8F%96CSDN%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9A%84%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[网络上一提到 Python,总会有一些不知道是黑还是粉的人大喊着：Python 是世界上最好的语言。最近利用业余时间体验了下 Python 语言，并写了个爬虫爬取我 csdn 上关注的几个大神的博客，然后利用leancloud一站式后端云服务器存储数据，再写了一个 android app 展示数据，也算小试了一下这门语言，给我的感觉就是，像 Python 这类弱类型的动态语言相比于 Java 来说，开发者不需要分太多心去考虑编程问题，能够把精力集中于业务上，思考逻辑的实现。下面分享一下我此次写爬虫的一下小经验，抛砖引玉。 开发环境的搭建登录 Python 官网下载客户端，Python 现在分为 Python3 和 Python2, 即对应的官网上的版本为3.5和2.7，二者的异同有兴趣可以搜索一下，就我的了解，2和3的语法会有不同，而且有的库支持2不支持3，有的支持3不支持2等等；又比如urllib2库（一个用来获取URLs的模块）在 Python2 上引用要 import urllib2, 而在 Python3 里就变成import urllib.request。等等。纠结使用哪个版本没有意义，代码是为逻辑服务的，无论2或3很明显都可以满足我们这些初学者的需求。这里推荐一下廖学峰老师的 Python 教程。很高质量的教程，2和3都有，嫌看视频学得慢的朋友可以试试。 但是这里有一个坑要提醒一下：如果你也和我一样想要使用leancloud做后端服务器，那得使用 Python2，无他，因为人家文档里写着暂不支持 Python3。╮(╯_╰)╭（6.28 更正：leancloud 现已支持 Python3） 搭建环境的一些小坑：error2502/2503下载客户端后，如果你点击安装后一切正常，那你可以忽略此步。如果出现安装失败 error2502/2503，解决办法如下： 打开命令提示符（管理员），如果你是win8：按win键进入桌面模式，左下角右键打开命令提示符（管理员） 输入 msiexec /package “你安装程序包的路径”(例如：F:\python) 安装成功后配置环境变量（我的电脑-右键 属性-高级系统设置-环境变量）添加安装的目录（C:\Python27）到path。之后打开命令行输入python，如果出现如下图三个小箭头则说明 Python 解释器已经安装成功了。 安装pip和beautifulsoup：pip，大家可以理解成相当于android studio的gradle，可以一键配置开源库到项目中（后续配置leancloud服务器也可以很方便的导入他们的模块）。beautifulsoup则是一个HTML解析器，使用它解析html标签方便又简单。 首先下载pip，下载 pip-8.1.2.tar.gz (md5, pgp) 解压后，打开cmd命令行，切换盘符，再cd 进入解压的目录，例如： cd D:\pip-8.1.2 命令行里输入 python setup.py install ，看到finished processing等字样即安装成功 配置环境变量到path： C:\Python27\Scripts; cmd 运行 pip install beautifulsoup4 ，看到successfully installed即安装成功 另外再推荐一款编辑器：pycharm，JetBrains出品你懂的，InteliJ系列风格，使用这款编辑器你会感觉像是在使用android studio一样，至少设置个字体大小啥的都不陌生。 万事俱备，Let’s begin! 初识爬虫因为我也才刚接触 Python，所以有一些代码可能很无脑且未经过优化，仅仅只为实现需求，so~下面就开始分享我写的一些 Python 代码，以及写爬虫时遇到的一些小坑 伪装浏览器CSDN禁止爬虫，所以要爬取之前就要把爬虫伪装成浏览器，在访问之前增加一个header： user_agents = [ &apos;Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11&apos;, &apos;Opera/9.25 (Windows NT 5.1; U; en)&apos;, &apos;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&apos;, &apos;Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.5 (like Gecko) (Kubuntu)&apos;, &apos;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12&apos;, &apos;Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9&apos;, &quot;Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.7 (KHTML, like Gecko) Ubuntu/11.04 Chromium/16.0.912.77 Chrome/16.0.912.77 Safari/535.7&quot;, &quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0 &quot;, ] agent = random.choice(user_agents) #每次随机抽取一个伪装的客户端浏览器版本号 req = urllib2.Request(self.url) #将要请求的地址映射成request对象，然后可以对其添加HTTP头 req.add_header(&apos;User-Agent&apos;, agent) req.add_header(&apos;Host&apos;, &apos;blog.csdn.net&apos;) req.add_header(&apos;Accept&apos;, &apos;*/*&apos;) req.add_header(&apos;Referer&apos;, &apos;http://blog.csdn.net/mangoer_ys?viewmode=list&apos;) req.add_header(&apos;GET&apos;, url) html = urllib2.urlopen(req) #将request对象传入urlopen方法，返回一个response对象 page = html.read().decode(&apos;utf-8&apos;) #调用read方法就可以获得html网页的信息了，主要还要对其转码为utf-8 这里就已经爬取到网页内容了（page），后面只要通过正则来解析你需要的数据，简单的爬虫其实就已经完成了。 现在来整理一下，我们到底需要一些什么数据？我的目的是爬取一个，甚至几个博主的全部博客，然后在手机上展示。那么就需要： 先访问给定的网址（博主的博客首页），并获取一篇博客的链接地址，然后让爬虫去访问该地址 获得这篇博文的标题，作者，发表时间、文章内容。这些是最基础的，也是必要的展示内容 获得这篇博文的id，作者的id，用来做后端存储数据的唯一标识 获得这篇博文底部的上一篇/下一篇博文按钮所链接的地址，并让爬虫访问改地址 循环往复，直到不存在上一篇/下一篇博文 创建一个类来执行第一个业务：要注意的是： Python 的规定方法定义必须有额外的参数self指代其本身，类似java的this。 class Get_First_Url: #用于获取博客首页第一篇博文的地址的类 def __init__(self, url2): #类构造器，这里我们还传入一个url，即博客首页的地址 self.url = url2 #将参数赋值给类，python里可以任意添加成员变量而不用提前声明，要用的时候直接调用self.xxx &apos;&apos;&apos; 伪装浏览器 &apos;&apos;&apos; self.page = page #获取的网页信息 self.beginurl = self.getFirstUrl() #下面我们会定义一个方法来解析网页并保存一篇的地址 解析html标签上面获得的 page 包含了所有的网页里的 html 标签，我们现在就要解析标签，获得信息，举个例子，在我的博客主页里右键-查看源代码，可以看到整个网址包含的所有html标签，如何从中找到自己想要的信息是哪个标签呢？ 以获取第一篇博客的链接地址为例，右键标题，审查元素，就可以看到该链接的html标签了 &lt;span class=&quot;link_title&quot;&gt; &lt;a href=&quot;/yazhi1992/article/details/51497576&quot;&gt; eclipse再见，android studio 新手入门教程（三）Github（.ignore忽略规则）的使用 &lt;/a&gt; &lt;/span&gt; 很容易看出，博客地址就是 csdn 网址拼接span标签内的a标签的key为href对应的value值。为了得到这个值，就要使用 breautifulsoup 解析，我们定义一个方法： def getFirstUrl(self): bs = BeautifulSoup(self.page) #创建breautifulsoup对象 html_content_list = bs.find(&apos;span&apos;, class_=&apos;link_title&apos;) #获得key为class，value为link——title的span标签，因为class与python语法的关键字冲突，所以要使用 class_ 代替 if (html_content_list == None): #如果未找到该标签则返回&apos;nourl&apos; return &quot;no url&quot; try: #异常捕获 return &apos;http://blog.csdn.net&apos; + html_content_list.a[&apos;href&apos;] except Exception, e: return &quot;nourl&quot; 所以到这里，我们就已经可以得到我们所需要的第一个数据了： first_spider = Get_First_Url(now_url) begin_url = first_spider.beginurl 获取其他数据方法类似，值得一提的是另一种标签的解析，需要的数据是标签内部的文字： &lt;div class=&quot;article_r&quot;&gt; &lt;span class=&quot;link_postdate&quot;&gt;I want this&lt;/span&gt; &lt;/div&gt; 想要获得标签的内容 bs = BeautifulSoup(self.page) #创建breautifulsoup对象 html_content_list = bs.find(&apos;span&apos;, class_=&apos;link_postdate&apos;) print html_content_list.string 我还遇到过想要获取时间2015-10-10 16:24这个值，但是执行上述代码会报错，提说说soup没有string这个值，那就需要对其做个转变为字符串的操作 1print str(html_content_list.string) 更多breautifulsoup的用法可以参考Python爬虫利器二之Beautiful Soup的用法 编码问题：python Non-ASCII character ‘\xe5’ in file如果你运行程序后报这个错，解决办法是在文件头添加： #coding=utf-8 import sys default_encoding = &apos;utf-8&apos; if sys.getdefaultencoding() != default_encoding: reload(sys) sys.setdefaultencoding(default_encoding) 关于 Python 的一些注意点：talk is cheap, show you the code. 切割字符串str = &apos;this is test&apos; print str[:4] #输出结果 this print str[3:] #输出结果 s is test print str[1:4] #输出结果 his 不用多说，冒号“ ： ”代表首或尾，和java一样的包左不包右。如果首尾都是数字，中间用冒号分割。 关于数组list = [] print list[-2] #数组倒数第二个的值 关于全局变量直接在外部定义全局变量，但是使用时需要用globla关键字表示 TEST = &apos;this is global variable&apos; class ... def... global TEST #使用关键字标识这个TEST是全局变量 print TEST #使用该变量 关于导包IDE好像不能自动导包（我也没认真去翻setting）导包的话直接在文件头import相应的包，例如 from bs4 import BeautifulSoup #导breatifulsoup的包 import urllib2 import random ...等等 关于布尔类型True、FalsePython 的布尔类型是首字母大写的（或者IDE可以设置忽略大小写联想，我没有去仔细翻）。(╯‵□′)╯︵┻━┻ 其他if(list==null||list.size == 0) { //java ... } else { ... } if (list == None or len(list) == 0): #python ... else: ... 因为我是爬取正文的html标签，然后在android端上使用webview展示，但是有个问题是webview里会显示电脑端的效果，字很小。查看手机端网页源代码后，发现在html标签头添加以下代码，就可以适配移动端浏览器： 1234567891011121314151617181920&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;yes&quot;&gt; &lt;script src=&quot;http://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;!--link( rel=&quot;stylesheet&quot; href=&quot;http://c.csdnimg.cn/public/common/toolbar/css/index.css&quot; )--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://csdnimg.cn/public/common/libs/bootstrap/css/bootstrap.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://csdnimg.cn/public/static/css/avatar.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/common.css&quot;&gt; &lt;!-- [if IE 7]--&gt; &lt;!--link( rel=&quot;stylesheet&quot; href=&quot;assets/css/font-awesome-ie7.min.css&quot; )--&gt; &lt;!-- [endif]--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/main.css&quot;&gt; &lt;!-- [if lt IE 9]--&gt; &lt;script src=&quot;/static/js/libs/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;!-- [endif]--&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/static/js/apps/blog_mobile.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 另外，关于webview网页里图片自适应，4.4以前只需要： 12WebSettings webSettings= contentWeb.getSettings();webSettings.setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN); 但是在Android 4.4系统上 Google已经将系统默认的Webkit内核替换成自己的开源项目chromium，导致的一个问题就是上述代码失效了，解决方法请参考Android 中 WebView 与 js 简单交互实现图文混排效果,解决图片自适应屏幕与查看大图问题，亲测有效。 Python 爬虫源码下载，请替换自己的leancloud应用的id和key，具体如何在爬虫里上传数据，以及在app里如何读取数据，请阅读leancloud官方开发文档。 Stay hungry, Stay foolish。下篇博客见。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse再见，android studio 新手入门教程（三）Github（.ignore忽略规则）的使用]]></title>
    <url>%2F2016%2F05%2F25%2Feclipse%E5%86%8D%E8%A7%81%EF%BC%8Candroid-studio-%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89Github%EF%BC%88-ignore%E5%BF%BD%E7%95%A5%E8%A7%84%E5%88%99%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[上传代码到githubandroid studio里集成了上传代码到github的功能，所以使用上还是很简单的，设置里添加账号并测试，之后就可以很方便地上传代码到github了 如果你的项目是使用android studio新建的，那么关于github基本就没什么问题了。android studio新建项目是自带.ignore文件的，也就是说默认是使用了忽略规则上传。默认忽略的是 12345678*.iml.gradle/local.properties/.idea/workspace.xml/.idea/libraries.DS_Store/build/captures 但是如果你的项目是之前从eclipse导入的，这里你就要注意了，按照上述操作，在github上新建项目后，在接下来的同步选项中，你会看到项目里的所有文件都会被上传，包括apk、iml、idea文件夹、gradle文件夹等。 很明显，我并不需要把每次编译就发生变动的文件（例如debug的apk文件）都上传，我需要有所忽略的上传，这也正是.ignore文件的作用。为了使用忽略规则，我拷贝了.ignore文件进项目，再重复上传操作，文件并没有起作用，后来进过一番探索，发现要这样操作： 移除已有的版本控制： 关闭android studio，进入项目的文件夹中删除.git文件夹（如果没有看到该文件夹请打开显示隐藏文件选项） 复制一份.gitignore文件到项目根目录（可使用as新建项目，其根目录就有该文件，或使用插件.gitignore生成，插件在as里搜索就有）附上我使用的忽略规则： 123456789101112131415161718192021222324252627282930313233343536373839*.iml.gradle/local.properties/.idea/workspace.xml/.idea/libraries.DS_Store/build/captures# OSX*.DS_Store# Gradle filesbuild/.gradle/*/build/# Intellij project files*.iml*.ipr*.iws.idea/# Built application files*.apk*.ap_# Files for the Dalvik VM*.dex# Java class files*.class# Eclipse project files.classpath.project# Generated filesantLauncher/binantLauncher/gen# generated filesbin/gen/# Local configuration file (sdk path, etc)local.properties# Log Files*.log 启动as，将项目加入版本控制 再重复之前的操作，import into Version Control–share Project onGithub，这样就使用上了忽略规则上传代码到github。 之后每次commit只需要右键项目，先点击add添加版本，再点击commit上传 以及查看历史、对比版本等，使用都比较简单，不必赘述。 导入github上的项目除了上传自己的代码到github，方便进行版本控制外，我们还经常需要导入github上别人的优秀项目进行学习，在android studio新建项目时就可以很方便的从github上直接导入项目 然并卵。。理想很美好，现实很残酷。因为国内网络环境的问题，使用这种方式导入github的项目，十有八九会因为gradle版本不同而被各种gradle错误搞得生不如死，这里分享一些快速而又愉快的离线导入github项目的方法： 从github上下载项目，举个栗子，项目名字为Test 修改第一个文件，位置位于根目录，即Test\build.gradle 将红框所示的地方改成你的gradle版本，如果不知道自己的gradle版本，很简单，新建一个项目看它的gradle版本是多少 修改第二个文件，位置位于目录 Test\gradle\wrapper\gradle-wrapper.properties 将红框所示的地方改成你的gradle版本 修改第三个文件，位置位于目录Test\app\build.gradle，修改项目的buildToolsVersion 版本号 就我所遇到的情况，一般修改这两个文件后就可以正常导入项目了。再也不会被gradle的问题困扰。以上。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个开源控件：Google官方下拉刷新控件SwipeRefreshLayout强化版，支持上拉刷新]]></title>
    <url>%2F2016%2F04%2F22%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E6%8E%A7%E4%BB%B6%EF%BC%9AGoogle%E5%AE%98%E6%96%B9%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E6%8E%A7%E4%BB%B6SwipeRefreshLayout%E5%BC%BA%E5%8C%96%E7%89%88%EF%BC%8C%E6%94%AF%E6%8C%81%E4%B8%8A%E6%8B%89%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[最近比较闲，所以趁着这时间撸了个SwipeRefreshLayout的加强版，Github地址。 原版只支持下拉刷新，强化之后支持上拉刷新和一进入页面就加载刷新，整个控件的加载动画是一致的，毫无违和感：），也算是为开源社区尽了点绵薄之力啦。 很惭愧，就做了一点微小的工作，谢谢大家。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse再见，android studio 新手入门教程（二）项目的导入]]></title>
    <url>%2F2016%2F04%2F18%2Feclipse%E5%86%8D%E8%A7%81%EF%BC%8Candroid-studio-%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[上一篇博客介绍了AS的一些常用设置方法，当工具调教妥当后，自然就要开始项目的开发啦。从零开始新建一个项目，这个简单，不必多说，这篇博客会分享我从旧平台eclipse导入项目到AS的过程，以及遇到的一些问题并如何解决。开篇先粗略的提一些需要注意的地方。 结构目录和eclipse不同，在android 视图下的项目目录分为java，res和manifests。 manifests目录存放清单文件，不必多说。 java目录会默认生成三个文件夹，其中test为在本机执行单元测试代码的目录， androidTest为在Android设备上执行单元测试代码的目录，第一个不带后缀的目录就是存放我们代码的目录。 res目录存放资源文件，包括图片资源文件、layout布局等，这个和eclispe类似，但有个新东西：mipmap目录，进入会看到里面存放着app的启动图标。查看官方文档，看到这么一句： To avoid these display issues, apps should use the mipmap/ resource folders for launcher icons. The Android system preserves these resources regardless of density stripping, and ensures that launcher apps can pick icons with the best resolution for display.出处：http://developer.android.com/tools/projects/index.html#mipmap 大意是为了避免设备显示问题，app应该使用mipmap目录存放应用图标。所以app的启动图标应该放置在mipmap文件夹中，至于其他的用处还不是很清楚，之前也遇到过导入eclipse项目时.9图片报错，网络上有人说.9图应该放在mipmap里，但是我把.9图片放到mipmap目录后仍然不能解决我的问题，最后因为项目里.9图不多，使用AS的工具重绘后解决了问题。 库依赖eclipse里添加存在本地的第三方库的方式： 将第三方库导入workspace- 右键项目-android-add LibraryAS里添加库的方式： 导入第三方库工程到project，第三方库作为一个新的module存在于project中- File-project structure，选择项目，添加库 通过对比可以发现，AS里的project就相当于eclipse里的workspace的概念，module相当于eclipse里独立的项目。也可以发现，其实二者在依赖存在于本地的第三方库的操作上是类似的，添加jar包的操作也是一样，只要把jar包复制到lib目录下（切换到Project Files视图下会看到Lib目录），然后同样操作project structure，选择file dependency后选择依赖lib库下刚添加进的jar包即可。 但是如果是添加线上开源库的话，二者的差距就体现出来了，以往在github上看到优秀的开源库，想要应用到自己的项目中，就得先把项目下载下来，然后再添加依赖，虽然操作不繁琐，但是我渐渐发现github上越来越多的开发者都转向AS，不再单独提供eclipse上使用的版本。这个不赘述，因为想转平台，能看到这篇博客的朋友，肯定或多或少都有些同感。总之一句话：google大法好。退eclipse保平安，赶紧转AS吧。 初识gradle在android视图gradle目录下，可以看到有多个build.gradle，其中后缀module + 项目名 的就是平时添加第三方库时需要配置的gradle文件了，以Github上CircleImageview这个开源库为示例，其github主页上有这么一段代码： 我们唯一要做的，就是将这段代码拷贝到项目的gradle-dependencies语句块下 然后点击工具栏图标 之后gradle就会自动从远程仓库下载该库所需要的jar包等依赖文件，一键搞定，简直不要太爽！ 然而gradle爽是爽，但是后续也会提到在导入项目时因为gradle版本不同而出现一些麻烦的地方。 导入Eclipse项目上面说了如何依赖库，但有些朋友需要开发旧项目而不是新建项目，光导入eclipse项目时报的错都够喝一壶了，更别提如何正确的依赖库，所以接下来就示范一下如何正确的导入eclipse的项目。不同项目会出现的问题不尽相同，这里权且算是抛砖引玉，给大家提供一些解决问题的思路。首先在eclipse里，右键-export，导出项目的gradle目录 选中要导出的项目，一路next，最后一步建议force overriding一栏打勾（我理解为是已存在gradle文件，选中的话将强制重写），导出成功后会出现提示： 请选择以下目录： …build.gradle，不要导入Eclipse项目本身！ 别人我不知道，反正我是照着这个提示在AS里导入目录下的build.gradle文件，然后结果就把整个工作目录里的项目都给导入了(╯‵□′)╯︵┻━┻。什么鬼！一定是我打开的方式不对！后来在AS里尝试 导入时选择项目本身，而不是build.gradle文件，这才导入成功。但是不要高兴的太早，这才只是麻烦的开始。 问题1 找不到类 解决办法：找不到相关的类，定位到代码，发现是recyclerview的一些类报错，于是猜测是因为依赖的问题，在项目依赖库里添加recyclerview库，问题解决！ 问题2 库重复依赖 错误提示中可以看到是因为有多个同名的库报错，因为我从eclipse导出项目时就自带了supportV7的recyclerview的库，而我刚刚有添加了新的recyclerview库，所以二者重复依赖了，解决办法很简单，去除之前的recyclerview依赖即可，问题解决！ 问题3 清单文件合并出错 Manifest merger failed 整个报错信息是这样的： java.lang.RuntimeException: Manifest merger failed : uses-sdk:minSdkVersion 1 cannot be smaller than version 7 declared in library [com.android.support:appcompat-v7:23.2.1] D:\studioCode\NewOneBuy\lib_CircleImageView\build\intermediates\exploded-aar\com.android.support\appcompat-v7\23.2.1\AndroidManifest.xmlSuggestion: use tools:overrideLibrary=”android.support.v7.appcompat” to force usage 可以看到是是因为circleimageview的minSdkVersion低于appcompatV7定义的version而导致的清单文件合并出错，提示中也告诉了我们解决方法，只要在circleimageview的清单文件中配置好即可。 问题4 程序包不存在 这个问题也简单，定位到相关的代码，使用快捷键：ctrl+alt+O， 去除无效的导包即可。 重复文件（jar包） Duplicate files 提示信息中也标明了是在File1，File2中两个不同的库含有相同的文件（jar包）导出出错，在prodect视图下查看lib目录，可以看到确实是有重复文件 解决问题也很简单：删除jar包，去除依赖即可 问题6 finished with non-zero exit value 2 What went wrong:Execution failed for task ‘:newOneBuy:transformClassesWithDexForDebug’.&gt; com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process ‘command ‘C:\Program Files (x86)\Java\jdk1.8.0_60\bin\java.exe’’ finished with non-zero exit value 2 这个没看懂错误原因，但是最后通过在项目的module的build.gradle里添加配置multiDexEnabled true后解决了问题，但是不知其所以然。123456defaultConfig &#123; applicationId &quot;com.example.newonebuy&quot; minSdkVersion 11 targetSdkVersion 21 multiDexEnabled true&#125; 在导入之前，看着一行又一行红彤彤的报错我的内心是崩溃的，但其实只要耐着性子根据提示逐个排查，遇到不懂的就谷歌，毕竟这都是些很初级的问题，总是会解决的。最近生活里的烦心事不少，在码代码时渐渐能感受到一种很奇妙的感情。在代码的世界里，1是1，0是0，只要你愿意付出心血，错误总会消失，bug总会修复。不像现实世界，很多事情人心难测，即便人心可测本心也难移，很多时候会感觉到深深的无力和无可奈何。 不多扯了，这篇先分享这些吧。下篇博客会分享一下在AS上使用github进行版本控制的一些事，还有在导入module时因为gradle版本而导致的一些问题。 另外最近看到kotlin这门新兴的语言似乎挺有意思，等到下个项目尝试一下看kotlin能否高效、有效的解决一些问题，如果后面有什么收获，也有写出来分享的。 有一分热发一分光，写的文章只要有一个人看到，解决了一个人的问题，那文章就有价值。即使都没人看，那就当做写给自己，作为对所思所学的一个总结吧。 但行善事，莫问前程。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse再见，android studio 新手入门教程（一）基本设置]]></title>
    <url>%2F2016%2F03%2F29%2Feclipse%E5%86%8D%E8%A7%81%EF%BC%8Candroid-studio-%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[写在前面：作为一个刚半只脚踏入android开发的新手，在使用eclipse开发了两个自我感觉不甚成熟的商城类app之后，遇到了一些问题，总结为如下： 代码复用性。findviewById，onclick事件等，一遍遍重复这类无聊的代码简直浪费生命，这个问题推荐通过依赖注入框架ButterKnife解决，直接一键生成布局中的所有控件，包括onclick点击事件，但是诸如行布局item里的控件，以及布局中include复用的布局要如何使用框架解决，这个有待后续再看。另一个代码重复率很高的地方便是对HTTP回调的处理，与服务端交互免不了要对返回的json数据进行解析，并根据不同状态下的status做相应的处理，这个问题通过对回调监听器listener的封装，可以减少一部分重复的代码。 代码复用性。在使用github使用一些大神的开源库时会发现eclipse越来越被边缘化了。参照我博客百分比布局的文章，许多工具类/库的使用，android studio用户只要在gradle中添加一行代码即可轻松集成，eclipse用户只能眼巴巴自己去复制相关java类和文件，先搞个demo测一下，可用了再集成进项目，费时费力。因此，要解决这个问题，学习android studio就显得很有必要了。我自己在android studio的使用上暂时也是一知半解，但是有一些问题的解决也花费了我不少的精力，所以即使是一些简单的知识，也希望能够帮到同样碰到这些问题的朋友。 那么正文开始吧。首先是android studio入门的第一步： android studio的安装：国内镜像地址安装过程就不用教学了吧。装好之后，有部分人可能会遇到点击程序后就闪一下，打开不了。解决方法：修改配置文件：Android-Studio\android-studio\bin\idea.properties，在文件结尾增加：disable.android.first.run=true 教程第一篇就先设置一些参数配置吧，工欲善其事必先利其器。 基本设置进入settings的方法有：（1）启动界面：Configure - settings，（2）File - settings， （3）点击顶部工具栏图标 部分配置设置方法： 主题的设置，Darcula就是传说中的极客范的黑色主题啦 字体设置，搜索栏搜索font，直接修改，下方实时预览，建议修改后点击save as 保存一份 显示行号，方便后续根据错误日志定位bug位置 重头戏来喽，快捷键风格设定，不过即使直接设定eclipse仍然会有部分快捷键冲突，这个下面会提到 联想快捷键。有冲突，我选择了忽视冲突强行修改成和eclipse一样的alt+/，毕竟这个太常用了。 设置联想不区分大小写。不过在xml界面编辑时，例如要输入 “&lt; Button &gt;” ， 必须先输入“&lt;”才会联想，还没有找到在哪里设置成像eclipse那样，任意符号字母都可联想。 编码 有些朋友想一打开as就直接进入项目，跳过选择项目的启动界面，取消勾选reopen lase project即可 代码区背景色设置 android studio与eclipse不同，eclipse联想出方法后，方法内会默认带有该方法的参数，我们只要对着修改就好了，studio联想出方法后，括号里为空。但是会有悬浮框提示： 这个悬浮窗会极大便利我们对方法的书写，修改相应的参数方法如下： 10.1 ：修改方法写完后悬浮窗出现的时间 10.2：如果你写完方法后，移到别处后又移回来，忘记了方法里需要的参数，那么此时有两种方法：1，鼠标放在方法名上，便会出现对该方法的介绍。2，使用快捷键显示上图的悬浮窗，快捷键修改方法：（我修改成alt+。，这个快捷键也是冲突的，但是暂时没发现有什么不妥） ，eclipse中还有一个很常用的快捷键ctrl+1，比如我们在new一个类时，new A（），按下ctrl + 1，自动联想为A a = new A（）；studio中还需要另外设置一下： 修改默认注释信息。每次新建java文件时会在文件顶部添加的注释信息。 快捷键这里提供一下android studio中一些与eclipse不同的快捷键：向上插入空行：ctrl + 空格错误提示：alt + enter生成构造方法，set和get等：alt + insert局部变量变为全局变量：ctrl + alt + F提炼方法：shift+ alt + M资源文件重命名：alt+shift+R查看方法在哪里被使用：ctrl+G清楚无效包：ctrl+alt+o 其他的后续使用过程中继续补全。想修改相关的快捷键，只要在keymap中的快捷键内任意点一个，修改成原本的键。例如错误提示alt + enter用的不习惯想改键，但是又不知道错误提示键的位置在哪里，这是只要在keymap中任意选中一个修改成alt + enter，提示框内就会提示这个组合键和哪个功能冲突，根据红字的提示找到位置，该位置就是你想修改的功能的位置啦。关于android studio的基本设置就是这样啦。Stay hungry, Stay foolish。下篇博客再见。]]></content>
  </entry>
</search>
