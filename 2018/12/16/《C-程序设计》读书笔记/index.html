<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="8UOZuQDq-BH1tVPdDgSiPq7FkqJB3-3wRwcvzozjmac">
<meta name="baidu-site-verification" content="oN4T9YsHyS">
<meta name="referrer" content="no-referrer">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,读书笔记,">





  <link rel="alternate" href="/atom.xml" title="美丽新世界" type="application/atom+xml">






<meta name="description" content="本文联合编辑：小辣辣。向她致以最崇高的敬（爱）意 ❤   第一章 C++的初步认识在程序进行编译时，先对所有的预处理命令进行处理，将头文件的具体内容代替 #include 指令，然后再对该程序单元进行整体编译。 对函数做声明，它的作用是通知 C++ 编译系统。 第二章 数据的存储、表示形式和基本运算C++ 没有规定每一种数据所占的字节数，只规定 int 型数据所占的字节数不大于 long 型，不">
<meta name="keywords" content="C++,读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++ 程序设计》读书笔记">
<meta property="og:url" content="https://yazhidev.github.io/2018/12/16/《C-程序设计》读书笔记/index.html">
<meta property="og:site_name" content="美丽新世界">
<meta property="og:description" content="本文联合编辑：小辣辣。向她致以最崇高的敬（爱）意 ❤   第一章 C++的初步认识在程序进行编译时，先对所有的预处理命令进行处理，将头文件的具体内容代替 #include 指令，然后再对该程序单元进行整体编译。 对函数做声明，它的作用是通知 C++ 编译系统。 第二章 数据的存储、表示形式和基本运算C++ 没有规定每一种数据所占的字节数，只规定 int 型数据所占的字节数不大于 long 型，不">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-06-07T22:58:54.441Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《C++ 程序设计》读书笔记">
<meta name="twitter:description" content="本文联合编辑：小辣辣。向她致以最崇高的敬（爱）意 ❤   第一章 C++的初步认识在程序进行编译时，先对所有的预处理命令进行处理，将头文件的具体内容代替 #include 指令，然后再对该程序单元进行整体编译。 对函数做声明，它的作用是通知 C++ 编译系统。 第二章 数据的存储、表示形式和基本运算C++ 没有规定每一种数据所占的字节数，只规定 int 型数据所占的字节数不大于 long 型，不">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yazhidev.github.io/2018/12/16/《C-程序设计》读书笔记/">





  <title>《C++ 程序设计》读书笔记 | 美丽新世界</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-125080992-2', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?638091a8d8717585b52d0e3ef0b65002";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">美丽新世界</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yazhidev.github.io/2018/12/16/《C-程序设计》读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Taki">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/link.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="美丽新世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《C++ 程序设计》读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T10:20:38+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文联合编辑：小辣辣。向她致以最崇高的敬（爱）意 ❤</p>
</blockquote>
<hr>
<h2 id="第一章-C-的初步认识"><a href="#第一章-C-的初步认识" class="headerlink" title="第一章 C++的初步认识"></a>第一章 C++的初步认识</h2><p>在程序进行编译时，先对所有的预处理命令进行处理，将头文件的具体内容代替 <code>#include</code> 指令，然后再对该程序单元进行整体编译。</p>
<p>对函数做声明，它的作用是通知 C++ 编译系统。</p>
<h2 id="第二章-数据的存储、表示形式和基本运算"><a href="#第二章-数据的存储、表示形式和基本运算" class="headerlink" title="第二章 数据的存储、表示形式和基本运算"></a>第二章 数据的存储、表示形式和基本运算</h2><p>C++ 没有规定每一种数据所占的字节数，只规定 int 型数据所占的字节数不大于 long 型，不小于 short 型。</p>
<h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PRICE 30</span><br></pre></td></tr></table></figure>
<p>符号常量虽有名字，但它不是变量。在进行编译预处理时，所有的 PRICE 都被置换为字符 30，在正式进行编译时已经没有 PRICE 这个标识符了。但 C++ 程序员一般更喜欢用 const 定义常变量。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p><code>/</code> 除法运算符<br>结果是整数，如果有一个是负数，则舍入方向是不固定的。多数编译系统采取向零取整的方法</p>
</li>
<li><p><code>%</code> 模运算符<br>两侧均应为整型数据，如 7%4 的值为 3</p>
</li>
</ul>
<p>+，–，*，/ 运算中的两个数中有一个数为 float 型数据，则运算结果是 double 型，因为 C++ 在运算时对所有 float 型数据都按 double 型数据处理。</p>
<p>进行运算时，不同类型的数据都要先转换成同一类型，然后进行运算。</p>
<h3 id="自增（减）运算符"><a href="#自增（减）运算符" class="headerlink" title="自增（减）运算符"></a>自增（减）运算符</h3><p>也用于指针变量，使指针指向下一个地址。</p>
<h3 id="赋值运算符和赋值表达式"><a href="#赋值运算符和赋值表达式" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h3><h4 id="赋值过程中的类型转换"><a href="#赋值过程中的类型转换" class="headerlink" title="赋值过程中的类型转换"></a>赋值过程中的类型转换</h4><p>将浮点型数据赋值给整型变量时，舍弃其小数部分。</p>
<p>不同类型的整型数据间的赋值归根到底就是一条：按存储单元中的存储形式直接传送。</p>
<h2 id="程序初步设计"><a href="#程序初步设计" class="headerlink" title="程序初步设计"></a>程序初步设计</h2><h3 id="关系运算和逻辑运算"><a href="#关系运算和逻辑运算" class="headerlink" title="关系运算和逻辑运算"></a>关系运算和逻辑运算</h3><p>运算符优先级：</p>
<p>算数运算符 ＞ 关系运算符 ＞赋值运算符</p>
<p>在 C 和 C++ 中都用数据 1 代表真，0 代表假。编译系统在处理逻辑型数据时，将 false 处理为 0，将 true 处理为 0。逻辑变量在内存中占 1 个字节，用来存放 0 或 1。</p>
<h3 id="用-for-语句构成循环"><a href="#用-for-语句构成循环" class="headerlink" title="用 for 语句构成循环"></a>用 for 语句构成循环</h3><p>for（表达式1；表达式2；表达式3）语句</p>
<p>表达式 1 可以省略，但其后得分号不可省略。</p>
<p>如果表达式 2 省略，即不判断循环条件，循环无休止地进行下去。</p>
<h2 id="第四章-利用函数实现指定的功能"><a href="#第四章-利用函数实现指定的功能" class="headerlink" title="第四章 利用函数实现指定的功能"></a>第四章 利用函数实现指定的功能</h2><h3 id="函数参数和函数的值"><a href="#函数参数和函数的值" class="headerlink" title="函数参数和函数的值"></a>函数参数和函数的值</h3><p>在调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放，实参单元仍保留并维持原值。因此，在执行一个被调用函数时，形参的值如果发生改变，并不会改变主调用函数中实参的值。</p>
<h3 id="对被调用函数的声明和函数原型"><a href="#对被调用函数的声明和函数原型" class="headerlink" title="对被调用函数的声明和函数原型"></a>对被调用函数的声明和函数原型</h3><p>在函数声明中可以不写形参名，只写形参类型</p>
<h3 id="内置函数（内联函数）"><a href="#内置函数（内联函数）" class="headerlink" title="内置函数（内联函数）"></a>内置函数（内联函数）</h3><p>转去被调用函数前，要记下当时执行的指令的地址，还要记下当时有关的信息，以便在函数调用后继续执行，如果有的函数需要频繁使用，则所用时间会很长，从而降低执行效率。可以使用内置函数将所调用的函数的代码直接嵌入到主调函数中，而不是将流程转出去。使用关键字 inline。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt; typename T &gt; //类似 Java 的泛型</span><br></pre></td></tr></table></figure>
<h3 id="有默认参数的函数"><a href="#有默认参数的函数" class="headerlink" title="有默认参数的函数"></a>有默认参数的函数</h3><p>注意点：如果函数的定义在函数调用之前，则应在函数定义中给出默认值。如果函数的定义在函数调用之后，则在函数调用之前需要有函数声明，此时必须许多函数声明中给出默认值，函数定义时可以不给出默认值。</p>
<h3 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h3><ul>
<li><p>auto（默认）</p>
<p>  自动变量，动态局部变量，函数调用结束后释放</p>
</li>
<li><p>static</p>
<p>  静态局部变量在静态存储区内分配存储单元，在程序整个运行期间都不释放。<br>  加上 static 声明，则该变量只能用于本文件</p>
</li>
<li><p>register</p>
<p>  寄存器变量，如果有一些变量使用频繁，则为存取变量的值要花不少时间，为提高效率，C++ 允许将局部变量的值放在 cpu 的寄存器中</p>
</li>
<li><p>extern</p>
<p>  全局变量（外部变量），作用域从变量的定义开始，到本程序文件的末尾<br>  注意 extern 是用作变量声明，而不是变量定义。它只是对一个已定义的外部变量做声明，以扩展其作用域。</p>
</li>
</ul>
<h3 id="内部函数和外部函数"><a href="#内部函数和外部函数" class="headerlink" title="内部函数和外部函数"></a>内部函数和外部函数</h3><h4 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h4><p>如果在函数的首部的最左端冠以关键字 <code>extern</code>，则表示此函数是外部函数，可供其他文件调用。</p>
<h2 id="第五章-利用数组处理批量数据"><a href="#第五章-利用数组处理批量数据" class="headerlink" title="第五章 利用数组处理批量数据"></a>第五章 利用数组处理批量数据</h2><h3 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h3><ul>
<li>可以只给一部分元素赋值（后面的元素默认为 0）</li>
<li>对全部数组元素赋初值时，可以不指定数组长度</li>
</ul>
<h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><ul>
<li>可以对部分元素赋值</li>
</ul>
<h3 id="用数组作函数参数"><a href="#用数组作函数参数" class="headerlink" title="用数组作函数参数"></a>用数组作函数参数</h3><p>数组名作实参和形参，传递的是数组的起始地址。</p>
<p>数组名代表数组首元素的地址。</p>
<p>用数组名作实参，如果改变了形参数组元素的值将同时改变实参数组元素的值。</p>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><h4 id="定义和初始化字符数组"><a href="#定义和初始化字符数组" class="headerlink" title="定义和初始化字符数组"></a>定义和初始化字符数组</h4><p>如果提供的初值个数大于数组长度，则按语法错误处理。如果小于数组长度，则只将字符赋值给数组中前面的元素，其余的元素自动定义为空字符 <code>\0</code></p>
<h4 id="字符数组的赋值和引用"><a href="#字符数组的赋值和引用" class="headerlink" title="字符数组的赋值和引用"></a>字符数组的赋值和引用</h4><p>只能对字符数组的元素赋值，而不能用赋值语句对整个数组赋值。</p>
<h4 id="结束标志"><a href="#结束标志" class="headerlink" title="结束标志"></a>结束标志</h4><p>遇到字符 <code>\0</code> 就表示字符串到此结束。对于一个字符串常量，系统会自动在所在字符的后面加一个 <code>\0</code> 作为结束符，然后再把它存在字符数组中。</p>
<p>可以用字符串常量来初始化字符数组。</p>
<h4 id="字符数组的输入和输出"><a href="#字符数组的输入和输出" class="headerlink" title="字符数组的输入和输出"></a>字符数组的输入和输出</h4><ul>
<li>输出得字符不包含结束符 <code>\0</code></li>
</ul>
<h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>比较函数 strcmp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcmp（str1，str2）</span><br></pre></td></tr></table></figure>
<p>对两个字符串自左至右逐个字符相比(按 ASCII 值大小比较)</p>
<p>两个字符串比较，不能用以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(str1 ＞ str2) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面写法表示将两个数组的地址进行比较。</p>
<h4 id="字符串变量的定义和引用"><a href="#字符串变量的定义和引用" class="headerlink" title="字符串变量的定义和引用"></a>字符串变量的定义和引用</h4><p>和其他类型变量一样，字符串变量必须先定义后使用。</p>
<h2 id="第六章-善于使用指针和引用"><a href="#第六章-善于使用指针和引用" class="headerlink" title="第六章 善于使用指针和引用"></a>第六章 善于使用指针和引用</h2><p><code>i_pointer</code> 是一个指针变量，<code>* i_pointer</code> 表示 i_pointer 所指向的变量。<br><code>*</code> 不是指针变量名的一部分，在变量名前加一个 <code>*</code> 表示该变量是指针变量。</p>
<p>不能用一个整数给指针变量赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * pointer = 2000;</span><br></pre></td></tr></table></figure>
<p>编译系统并不把 2000 认为是地址，而认为是整数。可以将一个已定义的变量的地址作为指针变量的初值。</p>
<p>一个指针只能指向同一个类型的变量。</p>
<h3 id="引用指针变量"><a href="#引用指针变量" class="headerlink" title="引用指针变量"></a>引用指针变量</h3><p><code>&amp;</code> ： 取地址运算符</p>
<p><code>&amp;a</code> 为变量 a 的地址， <code>*p</code> 为指针变量 p 所指向的存储单元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * pointer = &amp; a //定义指针变量</span><br></pre></td></tr></table></figure>
<p>pointer：指针变量</p>
<p><code>* pointer</code> 等效于 a（对指针变量 pointer 做 <code>*</code> 运算，指向 pointer 指向的存储单元，即 a）</p>
<p><code>&amp;</code> 和 <code>*</code> 两个运算符的优先级别相同，但按自右而左方向结合。例如已知 <code>pointer = &amp;a</code>，<code>&amp; * pointer</code>的含义是：先进行 <code>*pointer</code> 的运算，它就是变量 a，再执行 <code>&amp;</code> 运算，因此 <code>&amp; * pointer</code> 与 <code>&amp; a</code> 相同，即变量 a 的地址。</p>
<h3 id="用指针作函数参数"><a href="#用指针作函数参数" class="headerlink" title="用指针作函数参数"></a>用指针作函数参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    void swap(int * p1, int * p2)</span><br><span class="line">    int * pointer_1, * pointer_2, a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    pointer_1 = &amp;a;</span><br><span class="line">    pointer_2 = &amp;b;</span><br><span class="line">    swap(pointer_1, pointer_2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int * p1, int * p2) &#123; //定义指针变量 p1, p2，即 swap 的形参须是指针</span><br><span class="line">    int temp;</span><br><span class="line">    temp = * p1; // * p1：对指针变量做 * 运算，指向值</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能试图通过改变形参指针变量的值而使实参指针变量的值改变。实参和形参之间的数据传递是单向的“值传递”的方式，指针变量作函数参数也要遵循这一规则，调用函数时不会改变实参指针变量的值，但可以改变实参指针变量指向变量的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) </span><br><span class="line">&#123;</span><br><span class="line">    void myswap(int * p1, int * p2);</span><br><span class="line">    int * point1, * point2, a, b;</span><br><span class="line">    a = 10, b = 20;</span><br><span class="line">    point1 = &amp;a;</span><br><span class="line">    point2 = &amp;b;</span><br><span class="line">    cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    if(a &lt; b) myswap(point1, point2);</span><br><span class="line">    cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    if(a &lt; b) realswap(point1, point2);</span><br><span class="line">    cout&lt;&lt;&quot;a&quot;&lt;&lt;a&lt;&lt;&quot;b&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指针变量也是值传递，形参修改并不影响实参 point1 指针</span><br><span class="line">void myswap(int * p1, int * p2) &#123;</span><br><span class="line">    int * temp;</span><br><span class="line">    temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void realswap(int * p1, int * p2) &#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = * p1;</span><br><span class="line">    * p1 = * p2; //* p1，直接修改 p1 指向的值（a）的值</span><br><span class="line">    * p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出 </span><br><span class="line">a10b20</span><br><span class="line">a10b20</span><br><span class="line">a20b10</span><br><span class="line"></span><br><span class="line">//分析</span><br><span class="line">point1 = &amp; a</span><br><span class="line">* point1 即 point1 所指向的变量</span><br></pre></td></tr></table></figure>
<h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><h4 id="指向数组元素的指针"><a href="#指向数组元素的指针" class="headerlink" title="指向数组元素的指针"></a>指向数组元素的指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[10]; //定义一个数组，有 10 个元素</span><br><span class="line">int *p;</span><br><span class="line">p = &amp;a[0] //将元素 a[0] 的地址赋给指针变量 p，使 p 指向 a[0]</span><br></pre></td></tr></table></figure>
<p>在 C++ 中，数组名代表数组中的第 1 个元素（即序号为 0 的元素）的<strong>地址</strong>，因此以下语句等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[0];</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure>
<p>数组名 a 不代表整个数组，<code>p=a</code> 的作用是把 a 数组的首元素的地址赋给指针变量 p。</p>
<p>如果指针变量 p 已指向数组中的一个元素，则 p + 1 指向同一个数组中的下一个元素。</p>
<p>如果 p 的初值为 &amp;a[0]，那么 <code>p + i</code> 和 <code>a + i</code> 就是 a[i] 的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(p+5)</span><br><span class="line">*(a+5)</span><br><span class="line">a[5]</span><br></pre></td></tr></table></figure>
<p>这三种表示方法等价。</p>
<p>可以看出，数组名后面的括号 []，实际上是变址运算符，指向数组元素的指针变量也可以带下标，如 <code>p[i]</code> 与 <code>*(p+i)</code> 等价。</p>
<p>效率比较：</p>
<ol>
<li><p>下标法：a[i]</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针法：*(a + i)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*(a + i)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用指针变量指向数组元素</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int i;</span><br><span class="line">for(p = a; p &lt; (a + 10); p++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>1 和 2 的执行效率相同，C++ 编译系统是将 a[i] 转换为 *(a + 1) 处理的，对每个 a[i] 都分别计算地址 a + i x d，然后访问该元素。3 比 1 和 2 快，用指针变量直接指向元素，不必每次都重新计算地址。</p>
<p>在使用指针变量指向数组元素是，应切实保证指向数组中有效的元素。</p>
<p>C++ 编译系统将形参数组名一律作为指针变量来处理。</p>
<h3 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a>函数与指针</h3><p>只须将函数名 max 赋给 p，不能写成 p ＝ max(a,b)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * a(int x, int y);</span><br></pre></td></tr></table></figure>
<p>a 是函数名，调用它以后m能得到一个指向整型数据的指针（地址）。</p>
<h3 id="指针数组和指向指针的指针"><a href="#指针数组和指向指针的指针" class="headerlink" title="指针数组和指向指针的指针"></a>指针数组和指向指针的指针</h3><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * p[4]</span><br></pre></td></tr></table></figure>
<p>由于 [] 比 * 优先级高，因此 p 先与 [4] 结合，形成 p[4] 形式，这显然是数组形式。不要写成 int 这是指向一维数组的指针变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* (name + i ++)</span><br></pre></td></tr></table></figure>
<p>表示先求 * 的值，即 name 它是一个地址。将它赋给 p，然后 i 加 1，最后输出以 p 地址开始的字符串。</p>
<h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>由于 name[i] 的值是地址(即指针)，因此 name + i 就是指向指针型数据的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 指针变量（比如变量 a 的地址）</span><br><span class="line">char * p </span><br><span class="line"></span><br><span class="line">// 存储 a 的地址的指针的地址</span><br><span class="line">char *(* p) </span><br><span class="line"></span><br><span class="line">* p = &apos;C++&apos;</span><br><span class="line">** p 指向 ‘C++’ 的第一个字符元素的内容</span><br></pre></td></tr></table></figure>
<h3 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h3><p>用指向常量的指针变量只是限制了通过指针变量改变它指向的对象的值。</p>
<ul>
<li><p>const 类型名 * p （指向常量的指针变量）</p>
<p>  p 的指向可变，但 p 指向的对象的值不可变。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 12;</span><br><span class="line">int b = 15;</span><br><span class="line">const int * p = &amp; a;</span><br><span class="line"></span><br><span class="line">p = &amp;b; //合法，p 的指向可变</span><br><span class="line">* p = 20; //非法，p 指向的对象的值不可变</span><br><span class="line">a = 15; //合法，a 不是 const 常量</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>如果想绝对保证 a 的值始终不变，应当把 a 定义为常变量。
</code></pre><ul>
<li><p>int * const p （常指针变量）</p>
<p>  指针变量的指向不可变，但指向变量的值可变</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 12;</span><br><span class="line">int b = 15;</span><br><span class="line">int * const p = &amp; a;</span><br><span class="line"></span><br><span class="line">p = &amp;b; //非法，p 的指向不可变</span><br><span class="line">* p = 20; //合法，p 指向变量的值可变</span><br></pre></td></tr></table></figure>
</li>
<li><p>const int a</p>
<p>  a 的值不可变</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int a = 12;</span><br><span class="line"></span><br><span class="line">a = 20; //非法</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="void-指针类型"><a href="#void-指针类型" class="headerlink" title="void 指针类型"></a>void 指针类型</h3><p>该空间尚未使用，其中没有数据，谈不上指向什么类型的数据，故返回一个 <code>void *</code> 类型的指针，表示它不指向确定的具有类型的数据。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>指针变量可以有空值，即该指针变量不指向任何变量，它可以这样表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// iostream 头文件中已定义了符号常量 NULL 代表整数 0</span><br><span class="line">p = NULL;</span><br></pre></td></tr></table></figure>
<p>如果两个指针不指向同一个数组，则比较是无意义的。如果一定要对不同类型的指针变量赋值，可以用到强制类型转换。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在数据类型名后面出现的 &amp; 是引用声明符号，在其他场合出现的都是地址符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char &amp;d = c; // 引用的声明符</span><br><span class="line">int * p = &amp; a; //地址符</span><br></pre></td></tr></table></figure>
<p>在声明一个引用后，不能再使之作为另一变量的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1, a2;</span><br><span class="line">int &amp;b = a1;</span><br><span class="line">int &amp;b = a2; //非法</span><br></pre></td></tr></table></figure>
<p>引用其实就是一个指针常量，它的指向不可改变。</p>
<h3 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h3><p>传递变量的地址：形参是指针变量，实参是一个变量的地址。调用函数时，形参（指针变量）得到实参变量的地址，因此指向实参变量单元。</p>
<p>实参不是地址而是整型变量名，由于形参是引用，系统会自动将实参的地址传递给形参，注意：此时传送的是实参变量的地址而不是实参变量的值。实参是地址，传递的是地址，故仍然是值传递。方式（3）中实参是变量名，而传递的是变量的地址，这才是传址方式。</p>
<h2 id="第七章-用户自定义数据类型"><a href="#第七章-用户自定义数据类型" class="headerlink" title="第七章 用户自定义数据类型"></a>第七章 用户自定义数据类型</h2><h3 id="引用结构体变量"><a href="#引用结构体变量" class="headerlink" title="引用结构体变量"></a>引用结构体变量</h3><p><code>.</code> 是成员运算符，它在所有运算符中优先级最高，因此可以把 <code>student.num</code> 作为一个整体来看待。</p>
<h3 id="指向结构体变量的指针"><a href="#指向结构体变量的指针" class="headerlink" title="指向结构体变量的指针"></a>指向结构体变量的指针</h3><p>C 和 C++ 提供了指向结构体变量的运算符 <code>-&gt;</code>,形象的表示“指向”关系。例如，<code>p-&gt;num</code> 表示指针 p 当前指向的结构体变量中的成员 num。</p>
<p><code>p-&gt;n++</code> 得到p指向的结构体变量中的成 员 n的值，用完该值后使它加 1。</p>
<p><code>++p-&gt;n</code> 得到 p 指向的结构体变量中的成员 n 的值，并使之加 1，然后再使用它。</p>
<h4 id="用结构体变量和指向结构体变量的指针构成链表"><a href="#用结构体变量和指向结构体变量的指针构成链表" class="headerlink" title="用结构体变量和指向结构体变量的指针构成链表"></a>用结构体变量和指向结构体变量的指针构成链表</h4><p>用结构体变量和指向结构体变量的指针构成链表，最有一个元素不再指向其他元素，它成为“表尾”，它的地址部分放到一个“NULL”（表示“空地址”），链表到此结束。</p>
<p>所有节点（结构体变量）都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表成为静态链表。</p>
<p>动态链表则是指个结点是可以随时插入和删除的，这些节点并没有变量名，只能先找到一个结点上，才能根据它提供的下一个结点的地址找到下一个结点。</p>
<h3 id="结构体类型数据最为函数参数"><a href="#结构体类型数据最为函数参数" class="headerlink" title="结构体类型数据最为函数参数"></a>结构体类型数据最为函数参数</h3><p>调用函数时形参要单独开辟内存单元，如果结构体变量占的存储空间很大，则在虚实结合时控件和时间的开销都比较大，效率是不高的。</p>
<h3 id="用-new-和-delete-运算符进行动态分配和撤销存储空间"><a href="#用-new-和-delete-运算符进行动态分配和撤销存储空间" class="headerlink" title="用 new 和 delete 运算符进行动态分配和撤销存储空间"></a>用 new 和 delete 运算符进行动态分配和撤销存储空间</h3><p>new 运算符使用的一般格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new 类型 [初值]</span><br></pre></td></tr></table></figure>
<p>注意：用 new 分配数组空间时不能指定初始值</p>
<p>delete 运算符使用的一般格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete 指针变量</span><br><span class="line">或</span><br><span class="line">delete [] 指针变量</span><br></pre></td></tr></table></figure>
<p>在指针变量前面加一对方括号，表示是对数组空间的操作。</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举元素按常量处理，故称枚举常量，它们不是常量，不能对它们赋值，即枚举元素的值是固定的。</p>
<h2 id="第八章-类和对象的特性"><a href="#第八章-类和对象的特性" class="headerlink" title="第八章 类和对象的特性"></a>第八章 类和对象的特性</h2><h3 id="声明类类型"><a href="#声明类类型" class="headerlink" title="声明类类型"></a>声明类类型</h3><p>如果在类的定义中既不指定 private，也不指定 public，则系统就默认为是私有的。</p>
<p>除了 private 和 public之外，还有一种成员访问限定符 protect（受保护的），用protect声明的成员不能被类外访问（这点与私有成员类似），但可以被派生类的成员函数访问。</p>
<h3 id="成员函数的性质"><a href="#成员函数的性质" class="headerlink" title="成员函数的性质"></a>成员函数的性质</h3><p><code>::</code> 是作用域限定符（field qualifier）或称作用域运算符，用它声明函数是属于哪个子类的。</p>
<p>函数名前既无类名又无作用域运算符，表示函数不属于任何类，这个函数不是成员函数，而是全局函数。</p>
<h3 id="内置成员函数"><a href="#内置成员函数" class="headerlink" title="内置成员函数"></a>内置成员函数</h3><p>在类体中定义的成员函数的规模一般都很小，而系统调用函数的过程所花费的时间开销相对是比较大的，为减少时间的开销，如果在类体中定义的成员函数中不包括循环等控制结构，C++ 系统就自动把它们作为内置（inline）函数来处理。</p>
<h3 id="成员函数的存储方式"><a href="#成员函数的存储方式" class="headerlink" title="成员函数的存储方式"></a>成员函数的存储方式</h3><p>每个对象所占用的存储空间只是该对象的数据成员所占的存储空间，而不包括函数代码所占用的存储空间。</p>
<h2 id="第九章-怎样使用类和对象"><a href="#第九章-怎样使用类和对象" class="headerlink" title="第九章 怎样使用类和对象"></a>第九章 怎样使用类和对象</h2><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>不能在类生命中对数据成员初始化，因为类并不是一个实体，而是一种抽象类型，并不占存储空间，显然误触容纳数据。</p>
<h3 id="用构造函数实现数据成员的初始化"><a href="#用构造函数实现数据成员的初始化" class="headerlink" title="用构造函数实现数据成员的初始化"></a>用构造函数实现数据成员的初始化</h3><p>在类外定义构造成员函数，要加上类名和域限定符。</p>
<p>在建立对象时系统为该对象分配存储单元，此时执行构造函数。</p>
<h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><p>无参构造函数应注意正确书写定义对象的语句</p>
<p>请记住：构造函数是不能被用户显式调用的</p>
<h3 id="使用默认参数的构造函数"><a href="#使用默认参数的构造函数" class="headerlink" title="使用默认参数的构造函数"></a>使用默认参数的构造函数</h3><p>由于不需要实参也可以调用构造函数，因此全部参数都指定了一个默认值的构造函数也属于默认的构造函数。</p>
<p>编译系统无法识别应该调用那个构造函数，出现歧义性</p>
<p>在一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>如果用户没有定义析构函数，C++ 编译系统会自动生成一个析构函数，但它只是徒有析构函数的名称和形式，实际上什么操作都不进行。</p>
<h3 id="调用构造函数和析构函数的顺序"><a href="#调用构造函数和析构函数的顺序" class="headerlink" title="调用构造函数和析构函数的顺序"></a>调用构造函数和析构函数的顺序</h3><p>先构造的后析构，后构造的先析构。相当于一个栈，先进后出。</p>
<h3 id="指向对象成员的指针"><a href="#指向对象成员的指针" class="headerlink" title="指向对象成员的指针"></a>指向对象成员的指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time * pt; //定义 pt 是指向 Time 类对象的指针变量</span><br><span class="line">Time tl; //定义 tl 为 Time 类对象</span><br><span class="line">pt = &amp; tl; //将 tl 的起始地址赋给 pt</span><br><span class="line"></span><br><span class="line">* pt; //pt 所指向的对象，即 tl；</span><br><span class="line">//以下表示是等价的</span><br><span class="line">(* pt).hour; </span><br><span class="line">pt -&gt; hour;</span><br></pre></td></tr></table></figure>
<p>指针变量的类型必须与赋值号右侧函数的类型相匹配，要求在以下3方面都要匹配：1.函数参数的类型和参数个数；2、函数返回值类型；3.所属的类</p>
<p>定义指向公用成员函数的指针变量的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据类型名 （类名 :: * 指针变量名）（参数列表）;</span><br><span class="line"></span><br><span class="line">//形如：</span><br><span class="line">void(Time:: *p2)()</span><br></pre></td></tr></table></figure>
<p>使指针变量指向一个公用成员函数的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指针变量名 = &amp; 类名 :: 成员函数名</span><br><span class="line">//形如</span><br><span class="line">p2 = &amp;Time::get_time;</span><br></pre></td></tr></table></figure>
<h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><p>常对象必须有初值，在常对象的生命周期中，对象中的所有数据成员的值都不能被修改</p>
<p>定义常对象的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 const 对象名[(实参表)]；</span><br></pre></td></tr></table></figure>
<p>也可以把const写在最左边：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const 类名 对象名[(实参表)]；</span><br></pre></td></tr></table></figure>
<p>与上面的格式是等价的。</p>
<p>在定义常对象时，必须同时对之初始化，之后不能再改变。</p>
<h3 id="常对象成员"><a href="#常对象成员" class="headerlink" title="常对象成员"></a>常对象成员</h3><ul>
<li><p>常成员函数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意const的位置在函数名和括号之后</span><br><span class="line">viod get_time() const;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="指向对象的常指针"><a href="#指向对象的常指针" class="headerlink" title="指向对象的常指针"></a>指向对象的常指针</h3><p>指向对象的常指针变量的值不能改变，即始终指向同一个对象，但可以改变其所指向的对象的值。</p>
<p>往往常指针作为函数的形参，目的是不允许在函数执行过程中改变指针变量的值，使其始终指向原来的对象。</p>
<h3 id="指向常对象的指针变量"><a href="#指向常对象的指针变量" class="headerlink" title="指向常对象的指针变量"></a>指向常对象的指针变量</h3><p>一个对象已经被声明为常变量，只能用指向常变量的指针变量指向它。</p>
<p>指向常变量的指针变量除了可以指向常变量，还可以指向未被声明为const的变量。此时不能通过此指针变量来改变该变量的值。</p>
<p>指向常对象的指针最常用于函数的形参，目的是在白虎形参指针所指向的对象，使它在函数执行过程中不被修改。</p>
<p>以下是非法的：</p>
<ul>
<li>形参：指向非 const 型变量的指针；实参 const 变量的地址； </li>
</ul>
<p>因为参数传递本质是值传递/地址传递。过程：形参指向实参。因为非 const 型变量指针只能指向非 const 型变量。所以以上是非法的。</p>
<p>在函数调用时将建立一个新的对象，它是实参对象的拷贝</p>
<h3 id="对象的动态建立和释放"><a href="#对象的动态建立和释放" class="headerlink" title="对象的动态建立和释放"></a>对象的动态建立和释放</h3><p>用new运算符动态地分配内存后，将返回一个指向新对象的指针。</p>
<h3 id="对象的赋值"><a href="#对象的赋值" class="headerlink" title="对象的赋值"></a>对象的赋值</h3><p>对象的赋值只对其中数据成员赋值，而不对成员函数赋值。</p>
<p>不同对象的成员函数时同一个函数代码段，不需要，也无法对它赋值。</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态数据成员可初始化，但只能在类体外进行初始化。</p>
<p>公用静态数据成员与全局变量不同，静态数据成员的作用域只限于定义该类的作用域内（如果是在一个函数中定义类，那么其中静态数据成员的作用域就是在此函数内）</p>
<h3 id="静态数据成员函数"><a href="#静态数据成员函数" class="headerlink" title="静态数据成员函数"></a>静态数据成员函数</h3><p>非静态成员函数有 this 指针，而静态成员函数没有this指针。由此决定了静态成员函数不能访问本类中的非静态成员。</p>
<p>在 C++ 程序中最好养成这样的习惯：只用静态成员函数引用静态数据成员，而不引用非静态数据成员。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>在类外定义的且未用类最限定的函数，是非成员函数，不属于任何类。</p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><ol>
<li>友元的关系是单向的而不是双向的。</li>
<li>友元的关系不能传递。</li>
</ol>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模板名 &lt;实际类型名&gt; 对象名（参数表);</span><br></pre></td></tr></table></figure>
<h2 id="第十章-运算符重载"><a href="#第十章-运算符重载" class="headerlink" title="第十章 运算符重载"></a>第十章 运算符重载</h2><h3 id="重载运算符的规则"><a href="#重载运算符的规则" class="headerlink" title="重载运算符的规则"></a>重载运算符的规则</h3><p>重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象（或类对象的引用），参数不能全是 C++ 的标准类型</p>
<h3 id="运算符重载函数作为类成员函数和友元函数"><a href="#运算符重载函数作为类成员函数和友元函数" class="headerlink" title="运算符重载函数作为类成员函数和友元函数"></a>运算符重载函数作为类成员函数和友元函数</h3><p>将双目运算符重载为友元函数时，由于友元函数不是该类的成员函数，因此在函数的形参表中必须有两个参数，不能省略。</p>
<h3 id="用转换构造函数进行不同类型数据的转换"><a href="#用转换构造函数进行不同类型数据的转换" class="headerlink" title="用转换构造函数进行不同类型数据的转换"></a>用转换构造函数进行不同类型数据的转换</h3><p>通常把有一个参数的构造函数作类型转换，所以，称为转换构造函数。</p>
<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>类型转换函数的作用是将一个类的对象转换成另一个类型的数据。形式如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operator 类型名（） </span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在函数名前不能指定函数类型，函数没有参数。类型转换函数只能作为成员函数，因为转换的主体是本类的对象，不能作为友元函数或普通函数。</p>
<p>如果运算符重载函数为成员函数，它的第一个参数必须是本类的对象。当第一个操作数不是类对象时，不能将运算符函数重载为成员函数，如果将运算符“+” 重载为类的成员函数，交换律不适用。</p>
<p>类型转换函数与运算符重载不共存。因为可能出现二义性。</p>
<h2 id="第十一章-继承与派生"><a href="#第十一章-继承与派生" class="headerlink" title="第十一章 继承与派生"></a>第十一章 继承与派生</h2><h3 id="派生类的声明方式"><a href="#派生类的声明方式" class="headerlink" title="派生类的声明方式"></a>派生类的声明方式</h3><p>基类名前有 public 的称为公用继承。如果不写此项，默认为 privite（私有的）</p>
<h3 id="派生类成员的访问属性"><a href="#派生类成员的访问属性" class="headerlink" title="派生类成员的访问属性"></a>派生类成员的访问属性</h3><p>基类的成员函数只能访问基类的成员，而不能派生类的成员。</p>
<ul>
<li><p>公用继承</p>
<p>  基类的公用成员和保护成员在派生类中保持原有访问属性，私有成员仍为基类私有</p>
</li>
<li><p>私有继承</p>
<p>  基类的公有成员和保护成员在派生类中成了私有成员，私有成员仍为基类私有</p>
</li>
<li><p>受保护继承</p>
<p>  基类的公有成员和保护成员在派生类中成了保护成员，私有成员仍为基类私有</p>
</li>
</ul>
<h3 id="派生类的构造函数和析构函数"><a href="#派生类的构造函数和析构函数" class="headerlink" title="派生类的构造函数和析构函数"></a>派生类的构造函数和析构函数</h3><p>基类的构造函数式不能继承的，对继承过来的基类成员初始化的工作也要由派生类的构造函数承担。解决这个问题的思路是：在执行派生类的构造函数时，调用基类的构造函数。</p>
<h4 id="简单的派生类构造函数"><a href="#简单的派生类构造函数" class="headerlink" title="简单的派生类构造函数"></a>简单的派生类构造函数</h4><p>在类中对派生类构造函数作声明时，不包括上面给出的一般形式中的基类的构造函数名（参数表）部分</p>
<h4 id="有子对象的派生类的构造函数"><a href="#有子对象的派生类的构造函数" class="headerlink" title="有子对象的派生类的构造函数"></a>有子对象的派生类的构造函数</h4><p>应当在建立对象时对它的数据成员初始化。</p>
<p>派生类构造函数的任务应该包括：</p>
<ol>
<li>对基类数据成员初始化</li>
<li>对子对象数据成员初始化</li>
<li>对派生类数据成员初始化</li>
</ol>
<p>定义派生类构造函数的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">派生类构造函数名（总参数表）：基类构造函数名（参数表），子对象名（参数表）</span><br><span class="line">&#123; 派生类中新增数据成员初始化语句 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="派生类构造函数的特殊形式"><a href="#派生类构造函数的特殊形式" class="headerlink" title="派生类构造函数的特殊形式"></a>派生类构造函数的特殊形式</h3><p>如果在基类中没有定义构造函数，或定义了没有参数的构造函数，那么，在定义派生类构造函数时可以不写基类构造函数。因此此时派生类构造函数没有向基类构造函数传递参数的任务。在调用派生类构造函数时，系统会自动首先调用基类的默认构造函数。</p>
<h3 id="派生类的析构函数"><a href="#派生类的析构函数" class="headerlink" title="派生类的析构函数"></a>派生类的析构函数</h3><p>在执行派生类的析构函数时，系统会自动调用基类的析构函数和子对象的析构函数。调用的顺序与构造函数相反：先执行派生类自己的析构函数，然后调用子对象的析构函数，最后调用基类的析构函数。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>形式如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">派生类构造函数名（总参数表）：基类 1 构造函数（参数表），基类 2 构造函数（参数表）, 基类 3 构造函数（参数表）</span><br><span class="line">&#123; 派生类中新增数据成员初始化语句 &#125;</span><br></pre></td></tr></table></figure>
<p>声明基类的顺序决定了基类构造函数的调用顺序</p>
<h3 id="多重继承引发的二义性问题"><a href="#多重继承引发的二义性问题" class="headerlink" title="多重继承引发的二义性问题"></a>多重继承引发的二义性问题</h3><p>基类的同名成员在派生类中被屏蔽。成为不可见的。因此如果在定义派生类对象的模块中通过对象名访问同名的成员，则访问的是派生类的成员。请注意：不同的成员函数，只有在函数名和参数个数相同、类型相匹配的情况下才发生同名覆盖。</p>
<h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><p>虚基类使得在继间接共同基类时只保留一份成员。</p>
<p>需要注意，为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。</p>
<p>由于虚基类在派生类中只有一份数据成员，所以这份数据成员的初始化必须由派生类直接给出。</p>
<p>C++ 编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类对虚基类的构造函数的调用，这就保证了虚基类的数据成员不会被多次初始化。</p>
<h3 id="基类与派生类的转换"><a href="#基类与派生类的转换" class="headerlink" title="基类与派生类的转换"></a>基类与派生类的转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A al; //定义基类 A 对象 al</span><br><span class="line">B bl; //B 是 A 的派生类</span><br><span class="line">A&amp; r = al; //定义基类 A 对象的引用 r，并引用 al 对其初始化</span><br></pre></td></tr></table></figure>
<p>这时，r 是 al 的引用（别名），r 和 al 共享同一段存储单元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&amp; r = bl;</span><br></pre></td></tr></table></figure>
<p>此时 r 并不是 bl 的别名，也不是与 bl 共享同一段存储单元，它只是 bl 中基类部分的别名，r 与 bl 中基类部分共享同一段存储单元，r 与 bl 具有相同的其实地址。</p>
<p>即基类的引用类型，指向了派生类的变量。指向的也是派生类中从基类继承的部分。</p>
<h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><p>在一个类中以另一个类的对象作为数据成员的，称为类的组合。</p>
<h2 id="第十二章-多态性与虚函数"><a href="#第十二章-多态性与虚函数" class="headerlink" title="第十二章 多态性与虚函数"></a>第十二章 多态性与虚函数</h2><p>派生类对象可以替代基类对象向基类对象的引用初始化或赋值。调用的不是在 Circle 中声明的运算符重载函数，而是在 Point 中声明的运算符重载函数，输出的是“点”的信息，而不是“圆”的信息。</p>
<p>这两个 area 函数不是重载函数，它们不仅函数名相同，而且函数类型和参数个数都相同，两个同名函数不在同一个类中，而是分别在基类和派生类中，属于同名覆盖。</p>
<h3 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a>虚函数的作用</h3><p>编译系统按照同名覆盖的原则决定调用的对象。</p>
<p>C++ 的虚函数就是用来解决动态多态的问题的。所谓虚函数，就是在基类声明函数是虚拟的，并不是实际存在的函数，然后在派生类中才正式定义此函数。</p>
<p>本来，基类指针是用来指向基类对象的，如果用它指向派生类对象，则自动进行指针类型转换，将派生类的对象的指针先转换为基类的指针，这样，基类指针指向的是派生类中的基类部分。</p>
<p>有时在基类中定义的非虚函数会在派生类中被重新定义，如果用基类指针调用该成员函数，则系统会调用对象中基类部分的成员函数；如果用派生类指针调用该函数，则系统会调用派生类对象中的成员函数，这并不是多态性行为（使用的是不同类型的指针）</p>
<h3 id="静态关联和动态关联"><a href="#静态关联和动态关联" class="headerlink" title="静态关联和动态关联"></a>静态关联和动态关联</h3><p>确定调用的具体对象的过程称为关联。</p>
<p>函数重载和通过对象名调用的虚函数，在编译时即可确定其调用的虚函数属于哪一个类，其过程称为静态关联。</p>
<p>由于是在运行阶段把虚函数和类对象“绑定”在一起的，因此称为动态关联。</p>
<h3 id="在什么情况下应当声明虚函数"><a href="#在什么情况下应当声明虚函数" class="headerlink" title="在什么情况下应当声明虚函数"></a>在什么情况下应当声明虚函数</h3><p>一个成员函数被声明为虚函数后，在同一类族中的类就不能定义一个非 virtual 的但与该虚函数具有相同的参数。</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>先调用了派生类的析构函数，再调用了基类的析构函数。当基类的析构函数为虚函数，无论指针指的是同一类族中的哪一个类对象。</p>
<p>如果将基类的析构函数声明为虚函数时，由该函数所派生的所有派生类的析构函数有都自动成为虚函数，即使派生类的析构函数与基类的析构函数名字不相同。</p>
<h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual 函数类型 函数名（参数类别） = 0;</span><br></pre></td></tr></table></figure>
<p>纯虚函数只有函数的名字而不具备函数的功能，不能被调用。它只是通知编译系统：在这里声明一个虚函数，待派生类中定义。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>凡是包含纯虚函数的类的都是抽象类。因为纯虚函数是不能被调用的，包含纯虚函数的类是无法建立对象的。抽象类的作用是作为一个类族的共同基类。</p>
<p>抽象基类不能也不必要定义对象。</p>
<h4 id="区别静态关联和动态关联"><a href="#区别静态关联和动态关联" class="headerlink" title="区别静态关联和动态关联"></a>区别静态关联和动态关联</h4><p>在编译阶段就能确定调用的是哪一个类的虚函数，所以属于静态关联。如果是通过基类指针调用虚函数，在编译阶段无法从语句本身确定调用哪一个类的虚函数，只有在运行时，指针指向某一类对象后，才能确定调用的是哪一个类的虚函数，故为动态关联。</p>
<h2 id="第十三章-输入输出流"><a href="#第十三章-输入输出流" class="headerlink" title="第十三章 输入输出流"></a>第十三章 输入输出流</h2><h3 id="istream-类的其他成员函数"><a href="#istream-类的其他成员函数" class="headerlink" title="istream 类的其他成员函数"></a>istream 类的其他成员函数</h3><p>如果到达文件末尾（遇到文件结束符），eof 函数值为非零值（表示真），否则为 0（假）。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/18/APK-的前世今生：从-Android-源码到-apk-的编译打包流程/" rel="next" title="APK 的前世今生：从 Android 源码到 apk 的编译打包流程">
                <i class="fa fa-chevron-left"></i> APK 的前世今生：从 Android 源码到 apk 的编译打包流程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/12/从字节码层面理解泛型/" rel="prev" title="从字节码层面理解泛型">
                从字节码层面理解泛型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/link.png" alt="Taki">
            
              <p class="site-author-name" itemprop="name">Taki</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yazhidev" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-C-的初步认识"><span class="nav-number">1.</span> <span class="nav-text">第一章 C++的初步认识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-数据的存储、表示形式和基本运算"><span class="nav-number">2.</span> <span class="nav-text">第二章 数据的存储、表示形式和基本运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#符号常量"><span class="nav-number">2.1.</span> <span class="nav-text">符号常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">2.2.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自增（减）运算符"><span class="nav-number">2.3.</span> <span class="nav-text">自增（减）运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值运算符和赋值表达式"><span class="nav-number">2.4.</span> <span class="nav-text">赋值运算符和赋值表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#赋值过程中的类型转换"><span class="nav-number">2.4.1.</span> <span class="nav-text">赋值过程中的类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序初步设计"><span class="nav-number">3.</span> <span class="nav-text">程序初步设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系运算和逻辑运算"><span class="nav-number">3.1.</span> <span class="nav-text">关系运算和逻辑运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-for-语句构成循环"><span class="nav-number">3.2.</span> <span class="nav-text">用 for 语句构成循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-利用函数实现指定的功能"><span class="nav-number">4.</span> <span class="nav-text">第四章 利用函数实现指定的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数参数和函数的值"><span class="nav-number">4.1.</span> <span class="nav-text">函数参数和函数的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对被调用函数的声明和函数原型"><span class="nav-number">4.2.</span> <span class="nav-text">对被调用函数的声明和函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内置函数（内联函数）"><span class="nav-number">4.3.</span> <span class="nav-text">内置函数（内联函数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数模板"><span class="nav-number">4.4.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有默认参数的函数"><span class="nav-number">4.5.</span> <span class="nav-text">有默认参数的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的存储类型"><span class="nav-number">4.6.</span> <span class="nav-text">变量的存储类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部函数和外部函数"><span class="nav-number">4.7.</span> <span class="nav-text">内部函数和外部函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外部函数"><span class="nav-number">4.7.1.</span> <span class="nav-text">外部函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-利用数组处理批量数据"><span class="nav-number">5.</span> <span class="nav-text">第五章 利用数组处理批量数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一维数组的初始化"><span class="nav-number">5.1.</span> <span class="nav-text">一维数组的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二维数组的初始化"><span class="nav-number">5.2.</span> <span class="nav-text">二维数组的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用数组作函数参数"><span class="nav-number">5.3.</span> <span class="nav-text">用数组作函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符数组"><span class="nav-number">5.4.</span> <span class="nav-text">字符数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义和初始化字符数组"><span class="nav-number">5.4.1.</span> <span class="nav-text">定义和初始化字符数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符数组的赋值和引用"><span class="nav-number">5.4.2.</span> <span class="nav-text">字符数组的赋值和引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结束标志"><span class="nav-number">5.4.3.</span> <span class="nav-text">结束标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符数组的输入和输出"><span class="nav-number">5.4.4.</span> <span class="nav-text">字符数组的输入和输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串处理函数"><span class="nav-number">5.4.5.</span> <span class="nav-text">字符串处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串变量的定义和引用"><span class="nav-number">5.4.6.</span> <span class="nav-text">字符串变量的定义和引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章-善于使用指针和引用"><span class="nav-number">6.</span> <span class="nav-text">第六章 善于使用指针和引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用指针变量"><span class="nav-number">6.1.</span> <span class="nav-text">引用指针变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用指针作函数参数"><span class="nav-number">6.2.</span> <span class="nav-text">用指针作函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组和指针"><span class="nav-number">6.3.</span> <span class="nav-text">数组和指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指向数组元素的指针"><span class="nav-number">6.3.1.</span> <span class="nav-text">指向数组元素的指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数与指针"><span class="nav-number">6.4.</span> <span class="nav-text">函数与指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针数组和指向指针的指针"><span class="nav-number">6.5.</span> <span class="nav-text">指针数组和指向指针的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指针数组"><span class="nav-number">6.5.1.</span> <span class="nav-text">指针数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指向指针的指针"><span class="nav-number">6.5.2.</span> <span class="nav-text">指向指针的指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-指针"><span class="nav-number">6.6.</span> <span class="nav-text">const 指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void-指针类型"><span class="nav-number">6.7.</span> <span class="nav-text">void 指针类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针运算"><span class="nav-number">6.8.</span> <span class="nav-text">指针运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用"><span class="nav-number">6.9.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用作为函数参数"><span class="nav-number">6.10.</span> <span class="nav-text">引用作为函数参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章-用户自定义数据类型"><span class="nav-number">7.</span> <span class="nav-text">第七章 用户自定义数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用结构体变量"><span class="nav-number">7.1.</span> <span class="nav-text">引用结构体变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指向结构体变量的指针"><span class="nav-number">7.2.</span> <span class="nav-text">指向结构体变量的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用结构体变量和指向结构体变量的指针构成链表"><span class="nav-number">7.2.1.</span> <span class="nav-text">用结构体变量和指向结构体变量的指针构成链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体类型数据最为函数参数"><span class="nav-number">7.3.</span> <span class="nav-text">结构体类型数据最为函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-new-和-delete-运算符进行动态分配和撤销存储空间"><span class="nav-number">7.4.</span> <span class="nav-text">用 new 和 delete 运算符进行动态分配和撤销存储空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类型"><span class="nav-number">7.5.</span> <span class="nav-text">枚举类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第八章-类和对象的特性"><span class="nav-number">8.</span> <span class="nav-text">第八章 类和对象的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明类类型"><span class="nav-number">8.1.</span> <span class="nav-text">声明类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员函数的性质"><span class="nav-number">8.2.</span> <span class="nav-text">成员函数的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内置成员函数"><span class="nav-number">8.3.</span> <span class="nav-text">内置成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员函数的存储方式"><span class="nav-number">8.4.</span> <span class="nav-text">成员函数的存储方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第九章-怎样使用类和对象"><span class="nav-number">9.</span> <span class="nav-text">第九章 怎样使用类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的初始化"><span class="nav-number">9.1.</span> <span class="nav-text">对象的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用构造函数实现数据成员的初始化"><span class="nav-number">9.2.</span> <span class="nav-text">用构造函数实现数据成员的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数的重载"><span class="nav-number">9.3.</span> <span class="nav-text">构造函数的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用默认参数的构造函数"><span class="nav-number">9.4.</span> <span class="nav-text">使用默认参数的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#析构函数"><span class="nav-number">9.5.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用构造函数和析构函数的顺序"><span class="nav-number">9.6.</span> <span class="nav-text">调用构造函数和析构函数的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指向对象成员的指针"><span class="nav-number">9.7.</span> <span class="nav-text">指向对象成员的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常对象"><span class="nav-number">9.8.</span> <span class="nav-text">常对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常对象成员"><span class="nav-number">9.9.</span> <span class="nav-text">常对象成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指向对象的常指针"><span class="nav-number">9.10.</span> <span class="nav-text">指向对象的常指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指向常对象的指针变量"><span class="nav-number">9.11.</span> <span class="nav-text">指向常对象的指针变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的动态建立和释放"><span class="nav-number">9.12.</span> <span class="nav-text">对象的动态建立和释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的赋值"><span class="nav-number">9.13.</span> <span class="nav-text">对象的赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态成员"><span class="nav-number">9.14.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态数据成员函数"><span class="nav-number">9.15.</span> <span class="nav-text">静态数据成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#友元函数"><span class="nav-number">9.16.</span> <span class="nav-text">友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#友元类"><span class="nav-number">9.17.</span> <span class="nav-text">友元类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模板"><span class="nav-number">9.18.</span> <span class="nav-text">类模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十章-运算符重载"><span class="nav-number">10.</span> <span class="nav-text">第十章 运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重载运算符的规则"><span class="nav-number">10.1.</span> <span class="nav-text">重载运算符的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符重载函数作为类成员函数和友元函数"><span class="nav-number">10.2.</span> <span class="nav-text">运算符重载函数作为类成员函数和友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用转换构造函数进行不同类型数据的转换"><span class="nav-number">10.3.</span> <span class="nav-text">用转换构造函数进行不同类型数据的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换函数"><span class="nav-number">10.4.</span> <span class="nav-text">类型转换函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十一章-继承与派生"><span class="nav-number">11.</span> <span class="nav-text">第十一章 继承与派生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类的声明方式"><span class="nav-number">11.1.</span> <span class="nav-text">派生类的声明方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类成员的访问属性"><span class="nav-number">11.2.</span> <span class="nav-text">派生类成员的访问属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类的构造函数和析构函数"><span class="nav-number">11.3.</span> <span class="nav-text">派生类的构造函数和析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单的派生类构造函数"><span class="nav-number">11.3.1.</span> <span class="nav-text">简单的派生类构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有子对象的派生类的构造函数"><span class="nav-number">11.3.2.</span> <span class="nav-text">有子对象的派生类的构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类构造函数的特殊形式"><span class="nav-number">11.4.</span> <span class="nav-text">派生类构造函数的特殊形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类的析构函数"><span class="nav-number">11.5.</span> <span class="nav-text">派生类的析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承"><span class="nav-number">11.6.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承引发的二义性问题"><span class="nav-number">11.7.</span> <span class="nav-text">多重继承引发的二义性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚基类"><span class="nav-number">11.8.</span> <span class="nav-text">虚基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基类与派生类的转换"><span class="nav-number">11.9.</span> <span class="nav-text">基类与派生类的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承与组合"><span class="nav-number">11.10.</span> <span class="nav-text">继承与组合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十二章-多态性与虚函数"><span class="nav-number">12.</span> <span class="nav-text">第十二章 多态性与虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数的作用"><span class="nav-number">12.1.</span> <span class="nav-text">虚函数的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态关联和动态关联"><span class="nav-number">12.2.</span> <span class="nav-text">静态关联和动态关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在什么情况下应当声明虚函数"><span class="nav-number">12.3.</span> <span class="nav-text">在什么情况下应当声明虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚析构函数"><span class="nav-number">12.4.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纯虚函数与抽象类"><span class="nav-number">12.5.</span> <span class="nav-text">纯虚函数与抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">12.6.</span> <span class="nav-text">抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#区别静态关联和动态关联"><span class="nav-number">12.6.1.</span> <span class="nav-text">区别静态关联和动态关联</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十三章-输入输出流"><span class="nav-number">13.</span> <span class="nav-text">第十三章 输入输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#istream-类的其他成员函数"><span class="nav-number">13.1.</span> <span class="nav-text">istream 类的其他成员函数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Taki</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
